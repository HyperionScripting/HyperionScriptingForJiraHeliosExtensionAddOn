module Java {
	export interface Object {
	}
	export module Object {
		export interface Static {
		}
	}

	export interface Serializable {
	}
	export module Serializable {
		export interface Static {
		}
	}

	export interface String {
	}
	export module String {
		export interface Static {
		}
	}

	export interface Map<K = any, V = any> {
	}
	export module Map {
		export interface Static {
			Entry: Map$Entry.Static;
		}
	}
	export interface Map$Entry<K = any, V = any> {
	}
	export module Map$Entry {
		export interface Static {
		}
	}

	export interface Queue<E = any> {
	}
	export module Queue {
		export interface Static {
		}
	}

	export interface URI {
	}
	export module URI {
		export interface Static {
		}
	}

	export interface List<E = any> {
	}
	export module List {
		export interface Static {
		}
	}

	export interface Class<T = any> {
	}
	export module Class {
		export interface Static {
			MethodArray: Class$MethodArray.Static;
		}
	}
	export interface Class$MethodArray {
	}
	export module Class$MethodArray {
		export interface Static {
		}
	}

	export interface Cloneable {
	}
	export module Cloneable {
		export interface Static {
		}
	}

	export interface InetAddress {
	}
	export module InetAddress {
		export interface Static {
			InetAddressHolder: InetAddress$InetAddressHolder.Static;
			CacheEntry: InetAddress$CacheEntry.Static;
			Cache: InetAddress$Cache.Static;
		}
	}
	export interface InetAddress$InetAddressHolder {
	}
	export module InetAddress$InetAddressHolder {
		export interface Static {
		}
	}
	export interface InetAddress$CacheEntry {
	}
	export module InetAddress$CacheEntry {
		export interface Static {
		}
	}
	export interface InetAddress$Cache {
	}
	export module InetAddress$Cache {
		export interface Static {
		}
	}
	export interface InetAddress$Cache$Type {
	}
	export module InetAddress$Cache$Type {
		export interface Static {
		}
	}

	export interface Collection<E = any> {
	}
	export module Collection {
		export interface Static {
		}
	}

	export interface Throwable {
	}
	export module Throwable {
		export interface Static {
		}
	}

	export interface InputStream {
	}
	export module InputStream {
		export interface Static {
		}
	}

	export interface IOException {
	}
	export module IOException {
		export interface Static {
		}
	}

	export interface File {
	}
	export module File {
		export interface Static {
		}
	}
	export interface File$PathStatus {
	}
	export module File$PathStatus {
		export interface Static {
		}
	}

	export interface HostnameVerifier {
	}
	export module HostnameVerifier {
		export interface Static {
		}
	}

	export interface SSLSession {
	}
	export module SSLSession {
		export interface Static {
		}
	}

	export interface IllegalStateException {
	}
	export module IllegalStateException {
		export interface Static {
		}
	}

	export interface Enum<E extends Enum<E> = any> {
	}
	export module Enum {
		export interface Static {
		}
	}

	export interface Random {
	}
	export module Random {
		export interface Static {
			RandomIntsSpliterator: Random$RandomIntsSpliterator.Static;
			RandomLongsSpliterator: Random$RandomLongsSpliterator.Static;
			RandomDoublesSpliterator: Random$RandomDoublesSpliterator.Static;
		}
	}
	export interface Random$RandomIntsSpliterator {
	}
	export module Random$RandomIntsSpliterator {
		export interface Static {
		}
	}
	export interface Random$RandomLongsSpliterator {
	}
	export module Random$RandomLongsSpliterator {
		export interface Static {
		}
	}
	export interface Random$RandomDoublesSpliterator {
	}
	export module Random$RandomDoublesSpliterator {
		export interface Static {
		}
	}

	export interface Charset {
	}
	export module Charset {
		export interface Static {
		}
	}

	export interface AbstractList<E = any> {
	}
	export module AbstractList {
		export interface Static {
		}
	}

	export interface ThreadFactory {
	}
	export module ThreadFactory {
		export interface Static {
		}
	}

	export interface TimeUnit {
	}
	export module TimeUnit {
		export interface Static {
		}
	}

	export interface Thread {
	}
	export module Thread {
		export interface Static {
			UncaughtExceptionHandler: Thread$UncaughtExceptionHandler.Static;
			WeakClassKey: Thread$WeakClassKey.Static;
		}
	}
	export interface Thread$UncaughtExceptionHandler {
	}
	export module Thread$UncaughtExceptionHandler {
		export interface Static {
		}
	}
	export interface Thread$WeakClassKey {
	}
	export module Thread$WeakClassKey {
		export interface Static {
		}
	}
	export interface Thread$State {
	}
	export module Thread$State {
		export interface Static {
		}
	}

	export interface Runnable {
	}
	export module Runnable {
		export interface Static {
		}
	}

	export interface Date {
	}
	export module Date {
		export interface Static {
		}
	}

	export interface OutputStream {
	}
	export module OutputStream {
		export interface Static {
		}
	}

	export interface InetSocketAddress {
	}
	export module InetSocketAddress {
		export interface Static {
		}
	}

	export interface CharsetDecoder {
	}
	export module CharsetDecoder {
		export interface Static {
		}
	}

	export interface CharsetEncoder {
	}
	export module CharsetEncoder {
		export interface Static {
		}
	}

	export interface Socket {
	}
	export module Socket {
		export interface Static {
		}
	}

	export interface Comparator<T = any> {
	}
	export module Comparator {
		export interface Static {
		}
	}

	export interface Set<E = any> {
	}
	export module Set {
		export interface Static {
		}
	}

	export interface TimeZone {
	}
	export module TimeZone {
		export interface Static {
		}
	}

	export interface Principal {
	}
	export module Principal {
		export interface Static {
		}
	}

	export interface RuntimeException {
	}
	export module RuntimeException {
		export interface Static {
		}
	}

	export interface SimpleDateFormat {
	}
	export module SimpleDateFormat {
		export interface Static {
		}
	}

	export interface Closeable {
	}
	export module Closeable {
		export interface Static {
		}
	}

	export interface SSLContext {
	}
	export module SSLContext {
		export interface Static {
		}
	}

	export interface ProxySelector {
	}
	export module ProxySelector {
		export interface Static {
		}
	}

	export interface WeakReference<T = any> {
	}
	export module WeakReference {
		export interface Static {
		}
	}

	export interface X509Certificate {
	}
	export module X509Certificate {
		export interface Static {
		}
	}

	export interface Inflater {
	}
	export module Inflater {
		export interface Static {
		}
	}

	export interface InterruptedIOException {
	}
	export module InterruptedIOException {
		export interface Static {
		}
	}

	export interface SSLSocketFactory {
	}
	export module SSLSocketFactory {
		export interface Static {
		}
	}

	export interface URL {
	}
	export module URL {
		export interface Static {
		}
	}

	export interface ConnectException {
	}
	export module ConnectException {
		export interface Static {
		}
	}

	export interface Reader {
	}
	export module Reader {
		export interface Static {
		}
	}

	export interface Exception {
	}
	export module Exception {
		export interface Static {
		}
	}

	export interface Iterable<T = any> {
	}
	export module Iterable {
		export interface Static {
		}
	}

	export interface InflaterInputStream {
	}
	export module InflaterInputStream {
		export interface Static {
		}
	}

	export interface ExecutorService {
	}
	export module ExecutorService {
		export interface Static {
		}
	}

	export interface FutureTask<V = any> {
	}
	export module FutureTask {
		export interface Static {
			WaitNode: FutureTask$WaitNode.Static;
		}
	}
	export interface FutureTask$WaitNode {
	}
	export module FutureTask$WaitNode {
		export interface Static {
		}
	}

	export interface Callable<V = any> {
	}
	export module Callable {
		export interface Static {
		}
	}

	export interface Locale {
	}
	export module Locale {
		export interface Static {
			Builder: Locale$Builder.Static;
			LanguageRange: Locale$LanguageRange.Static;
		}
	}
	export interface Locale$Builder {
	}
	export module Locale$Builder {
		export interface Static {
		}
	}
	export interface Locale$LanguageRange {
	}
	export module Locale$LanguageRange {
		export interface Static {
		}
	}
	export interface Locale$Category {
	}
	export module Locale$Category {
		export interface Static {
		}
	}
	export interface Locale$FilteringMode {
	}
	export module Locale$FilteringMode {
		export interface Static {
		}
	}

	export interface Future<V = any> {
	}
	export module Future {
		export interface Static {
		}
	}

	export interface CodingErrorAction {
	}
	export module CodingErrorAction {
		export interface Static {
		}
	}

	export interface Iterator<E = any> {
	}
	export module Iterator {
		export interface Static {
		}
	}

	export interface ServerSocket {
	}
	export module ServerSocket {
		export interface Static {
		}
	}

	export interface SSLServerSocket {
	}
	export module SSLServerSocket {
		export interface Static {
		}
	}

	export interface SocketFactory {
	}
	export module SocketFactory {
		export interface Static {
		}
	}

	export interface CharacterCodingException {
	}
	export module CharacterCodingException {
		export interface Static {
		}
	}

	export interface CharSequence {
	}
	export module CharSequence {
		export interface Static {
		}
	}

	export interface StringBuilder {
	}
	export module StringBuilder {
		export interface Static {
		}
	}

	export interface SocketAddress {
	}
	export module SocketAddress {
		export interface Static {
		}
	}

	export interface ClassLoader {
	}
	export module ClassLoader {
		export interface Static {
			NativeLibrary: ClassLoader$NativeLibrary.Static;
		}
	}
	export interface ClassLoader$NativeLibrary {
	}
	export module ClassLoader$NativeLibrary {
		export interface Static {
		}
	}

	export interface ThreadPoolExecutor {
	}
	export module ThreadPoolExecutor {
		export interface Static {
			CallerRunsPolicy: ThreadPoolExecutor$CallerRunsPolicy.Static;
			AbortPolicy: ThreadPoolExecutor$AbortPolicy.Static;
			DiscardPolicy: ThreadPoolExecutor$DiscardPolicy.Static;
			DiscardOldestPolicy: ThreadPoolExecutor$DiscardOldestPolicy.Static;
		}
	}
	export interface ThreadPoolExecutor$Worker {
	}
	export module ThreadPoolExecutor$Worker {
		export interface Static {
		}
	}
	export interface ThreadPoolExecutor$CallerRunsPolicy {
	}
	export module ThreadPoolExecutor$CallerRunsPolicy {
		export interface Static {
		}
	}
	export interface ThreadPoolExecutor$AbortPolicy {
	}
	export module ThreadPoolExecutor$AbortPolicy {
		export interface Static {
		}
	}
	export interface ThreadPoolExecutor$DiscardPolicy {
	}
	export module ThreadPoolExecutor$DiscardPolicy {
		export interface Static {
		}
	}
	export interface ThreadPoolExecutor$DiscardOldestPolicy {
	}
	export module ThreadPoolExecutor$DiscardOldestPolicy {
		export interface Static {
		}
	}

	export interface BlockingQueue<E = any> {
	}
	export module BlockingQueue {
		export interface Static {
		}
	}

	export interface LinkedList<E = any> {
	}
	export module LinkedList {
		export interface Static {
			LLSpliterator: LinkedList$LLSpliterator.Static;
		}
	}
	export interface LinkedList$LLSpliterator<E = any> {
	}
	export module LinkedList$LLSpliterator {
		export interface Static {
		}
	}

	export interface InvocationHandler {
	}
	export module InvocationHandler {
		export interface Static {
		}
	}

	export interface SecureRandom {
	}
	export module SecureRandom {
		export interface Static {
		}
	}

	export interface Provider {
	}
	export module Provider {
		export interface Static {
			Service: Provider$Service.Static;
		}
	}
	export interface Provider$Service {
	}
	export module Provider$Service {
		export interface Static {
		}
	}

	export interface X509TrustManager {
	}
	export module X509TrustManager {
		export interface Static {
		}
	}

	export interface X509ExtendedKeyManager {
	}
	export module X509ExtendedKeyManager {
		export interface Static {
		}
	}

	export interface PrivateKey {
	}
	export module PrivateKey {
		export interface Static {
		}
	}

	export interface SSLEngine {
	}
	export module SSLEngine {
		export interface Static {
		}
	}

	export interface ServerSocketFactory {
	}
	export module ServerSocketFactory {
		export interface Static {
		}
	}

	export interface BitSet {
	}
	export module BitSet {
		export interface Static {
		}
	}

	export interface KeyStore {
	}
	export module KeyStore {
		export interface Static {
			LoadStoreParameter: KeyStore$LoadStoreParameter.Static;
			ProtectionParameter: KeyStore$ProtectionParameter.Static;
			PasswordProtection: KeyStore$PasswordProtection.Static;
			CallbackHandlerProtection: KeyStore$CallbackHandlerProtection.Static;
			Entry: KeyStore$Entry.Static;
			PrivateKeyEntry: KeyStore$PrivateKeyEntry.Static;
			SecretKeyEntry: KeyStore$SecretKeyEntry.Static;
			TrustedCertificateEntry: KeyStore$TrustedCertificateEntry.Static;
			Builder: KeyStore$Builder.Static;
			SimpleLoadStoreParameter: KeyStore$SimpleLoadStoreParameter.Static;
		}
	}
	export interface KeyStore$LoadStoreParameter {
	}
	export module KeyStore$LoadStoreParameter {
		export interface Static {
		}
	}
	export interface KeyStore$ProtectionParameter {
	}
	export module KeyStore$ProtectionParameter {
		export interface Static {
		}
	}
	export interface KeyStore$PasswordProtection {
	}
	export module KeyStore$PasswordProtection {
		export interface Static {
		}
	}
	export interface KeyStore$CallbackHandlerProtection {
	}
	export module KeyStore$CallbackHandlerProtection {
		export interface Static {
		}
	}
	export interface KeyStore$Entry {
	}
	export module KeyStore$Entry {
		export interface Static {
			Attribute: KeyStore$Entry$Attribute.Static;
		}
	}
	export interface KeyStore$Entry$Attribute {
	}
	export module KeyStore$Entry$Attribute {
		export interface Static {
		}
	}
	export interface KeyStore$PrivateKeyEntry {
	}
	export module KeyStore$PrivateKeyEntry {
		export interface Static {
		}
	}
	export interface KeyStore$SecretKeyEntry {
	}
	export module KeyStore$SecretKeyEntry {
		export interface Static {
		}
	}
	export interface KeyStore$TrustedCertificateEntry {
	}
	export module KeyStore$TrustedCertificateEntry {
		export interface Static {
		}
	}
	export interface KeyStore$Builder {
	}
	export module KeyStore$Builder {
		export interface Static {
		}
	}
	export interface KeyStore$SimpleLoadStoreParameter {
	}
	export module KeyStore$SimpleLoadStoreParameter {
		export interface Static {
		}
	}

	export interface Array<T = any> {
	}
	export module Array {
		export interface Static {
		}
	}
}

module Http {
	/**
	 * Corresponding Java class: org.apache.http.auth.params.AuthParams
	 * An adaptor for manipulating HTTP authentication parameters
	 * in {@link HttpParams}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}
	 *   and constructor parameters of
	 *   {@link org.apache.http.auth.AuthSchemeProvider}s.
	 */
	export interface AuthParams extends Java.Object {
	}
	export module AuthParams {
		/**
		 * Corresponding Java class: org.apache.http.auth.params.AuthParams
		 * An adaptor for manipulating HTTP authentication parameters
		 * in {@link HttpParams}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}
		 *   and constructor parameters of
		 *   {@link org.apache.http.auth.AuthSchemeProvider}s.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AuthSchemeProvider
	 * Factory for {@link AuthScheme} implementations.
	 *
	 * @since 4.3
	 */
	export interface AuthSchemeProvider extends Java.Object {
		/**
		 * Creates an instance of {@link AuthScheme}.
		 *
		 * @return auth scheme.
		 */
		create(context: Http.HttpContext): Http.AuthScheme;
	}
	export module AuthSchemeProvider {
		/**
		 * Corresponding Java class: org.apache.http.auth.AuthSchemeProvider
		 * Factory for {@link AuthScheme} implementations.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AuthSchemeFactory
	 * Factory for {@link AuthScheme} implementations.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link AuthSchemeProvider}
	 */
	export interface AuthSchemeFactory extends Java.Object {
	}
	export module AuthSchemeFactory {
		/**
		 * Corresponding Java class: org.apache.http.auth.AuthSchemeFactory
		 * Factory for {@link AuthScheme} implementations.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link AuthSchemeProvider}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.UsernamePasswordCredentials
	 * Simple {@link Credentials} implementation based on a user name / password
	 * pair.
	 *
	 * @since 4.0
	 */
	export interface UsernamePasswordCredentials extends Java.Object, Http.Credentials, Java.Serializable {
		equals(o: obj): boolean;
		getPassword(): string;
		getUserName(): string;
		getUserPrincipal(): Java.Principal;
		hashCode(): int;
		toString(): string;
	}
	export module UsernamePasswordCredentials {
		/**
		 * Corresponding Java class: org.apache.http.auth.UsernamePasswordCredentials
		 * Simple {@link Credentials} implementation based on a user name / password
		 * pair.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.Credentials.Static, Java.Serializable.Static {
			/**
			 * The constructor with the username and password arguments.
			 *
			 * @param userName the user name
			 * @param password the password
			 */
			new(userName: string, password: string): Http.UsernamePasswordCredentials;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.KerberosCredentials
	 * {@link Credentials} implementation based on GSSCredential for Kerberos Authentication.
	 *
	 * @since 4.4
	 */
	export interface KerberosCredentials extends Java.Object, Http.Credentials, Java.Serializable {
		getGSSCredential(): JGSS.GSSCredential;
		getPassword(): string;
		getUserPrincipal(): Java.Principal;
	}
	export module KerberosCredentials {
		/**
		 * Corresponding Java class: org.apache.http.auth.KerberosCredentials
		 * {@link Credentials} implementation based on GSSCredential for Kerberos Authentication.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Http.Credentials.Static, Java.Serializable.Static {
			/**
			 * Constructor with GSSCredential argument
			 *
			 * @param gssCredential
			 */
			new(gssCredential: JGSS.GSSCredential): Http.KerberosCredentials;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookieSpecRegistry
	 * Cookie specification registry that can be used to obtain the corresponding
	 * cookie specification implementation for a given type of type or version of
	 * cookie.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.config.Registry}.
	 */
	export interface CookieSpecRegistry extends Java.Object, Http.Lookup<Http.CookieSpecProvider> {
	}
	export module CookieSpecRegistry {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookieSpecRegistry
		 * Cookie specification registry that can be used to obtain the corresponding
		 * cookie specification implementation for a given type of type or version of
		 * cookie.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.config.Registry}.
		 */
		export interface Static extends Java.Object.Static, Http.Lookup.Static {
			new(): Http.CookieSpecRegistry;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.AuthenticationStrategy
	 /**
	 * A handler for determining if an HTTP response represents an authentication challenge that was
	 * sent back to the client as a result of authentication failure.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared data must be
	 * synchronized as methods of this interface may be executed from multiple threads.
	 *
	 * @since 4.2
	 */
	export interface AuthenticationStrategy extends Java.Object {
		/**
		 * Callback invoked in case of unsuccessful authentication.
		 *
		 * @param authhost authentication host.
		 * @param authScheme authentication scheme used.
		 * @param context HTTP context.
		 */
		authFailed(authhost: Http.HttpHost, authScheme: Http.AuthScheme, context: Http.HttpContext): void;
		/**
		 * Callback invoked in case of successful authentication.
		 *
		 * @param authhost authentication host.
		 * @param authScheme authentication scheme used.
		 * @param context HTTP context.
		 */
		authSucceeded(authhost: Http.HttpHost, authScheme: Http.AuthScheme, context: Http.HttpContext): void;
		/**
		 * Extracts from the given HTTP response a collection of authentication
		 * challenges, each of which represents an authentication scheme supported
		 * by the authentication host.
		 *
		 * @param authhost authentication host.
		 * @param response HTTP response.
		 * @param context HTTP context.
		 * @return a collection of challenges keyed by names of corresponding
		 * authentication schemes.
		 * @throws MalformedChallengeException if one of the authentication
		 *  challenges is not valid or malformed.
		 */
		getChallenges(authhost: Http.HttpHost, response: Http.HttpResponse, context: Http.HttpContext): Java.Map<string, Http.Header>;
		/**
		 * Determines if the given HTTP response response represents
		 * an authentication challenge that was sent back as a result
		 * of authentication failure.
		 *
		 * @param authhost authentication host.
		 * @param response HTTP response.
		 * @param context HTTP context.
		 * @return {@code true} if user authentication is required,
		 *   {@code false} otherwise.
		 */
		isAuthenticationRequested(authhost: Http.HttpHost, response: Http.HttpResponse, context: Http.HttpContext): boolean;
		/**
		 * Selects one authentication challenge out of all available and
		 * creates and generates {@link AuthOption} instance capable of
		 * processing that challenge.
		 *
		 * @param challenges collection of challenges.
		 * @param authhost authentication host.
		 * @param response HTTP response.
		 * @param context HTTP context.
		 * @return authentication auth schemes that can be used for authentication. Can be empty.
		 * @throws MalformedChallengeException if one of the authentication
		 *  challenges is not valid or malformed.
		 */
		select(challenges: Java.Map<string, Http.Header>, authhost: Http.HttpHost, response: Http.HttpResponse, context: Http.HttpContext): Java.Queue<Http.AuthOption>;
	}
	export module AuthenticationStrategy {
		/**
		 * Corresponding Java class: org.apache.http.client.AuthenticationStrategy
		 /**
		 * A handler for determining if an HTTP response represents an authentication challenge that was
		 * sent back to the client as a result of authentication failure.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared data must be
		 * synchronized as methods of this interface may be executed from multiple threads.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpPatch
	 * HTTP PATCH method.
	 * 
	 * The HTTP PATCH method is defined in <a
	 * href="http://tools.ietf.org/html/rfc5789">RF5789:
	 * 
	 *  The PATCH
	 * method requests that a set of changes described in the request entity be
	 * applied to the resource identified by the Request- URI. Differs from the PUT
	 * method in the way the server processes the enclosed entity to modify the
	 * resource identified by the Request-URI. In a PUT request, the enclosed entity
	 * origin server, and the client is requesting that the stored version be
	 * replaced. With PATCH, however, the enclosed entity contains a set of
	 * instructions describing how a resource currently residing on the origin
	 * server should be modified to produce a new version.
	 * 
	 *
	 * @since 4.2
	 */
	export interface HttpPatch extends Http.HttpEntityEnclosingRequestBase {
		getMethod(): string;
	}
	export module HttpPatch {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpPatch
		 * HTTP PATCH method.
		 * 
		 * The HTTP PATCH method is defined in <a
		 * href="http://tools.ietf.org/html/rfc5789">RF5789:
		 * 
		 *  The PATCH
		 * method requests that a set of changes described in the request entity be
		 * applied to the resource identified by the Request- URI. Differs from the PUT
		 * method in the way the server processes the enclosed entity to modify the
		 * resource identified by the Request-URI. In a PUT request, the enclosed entity
		 * origin server, and the client is requesting that the stored version be
		 * replaced. With PATCH, however, the enclosed entity contains a set of
		 * instructions describing how a resource currently residing on the origin
		 * server should be modified to produce a new version.
		 * 
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.HttpEntityEnclosingRequestBase.Static {
			new(): Http.HttpPatch;
			new(uri: Java.URI): Http.HttpPatch;
			new(uri: string): Http.HttpPatch;
			METHOD_NAME?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpDelete
	 * HTTP DELETE method
	 * 
	 * The HTTP DELETE method is defined in section 9.7 of
	 * RFC2616:
	 * 
	 * The DELETE method requests that the origin server delete the resource
	 * identified by the Request-URI. [...] The client cannot
	 * be guaranteed that the operation has been carried out, even if the
	 * status code returned from the origin server indicates that the action
	 * has been completed successfully.
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpDelete extends Http.HttpRequestBase {
		getMethod(): string;
	}
	export module HttpDelete {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpDelete
		 * HTTP DELETE method
		 * 
		 * The HTTP DELETE method is defined in section 9.7 of
		 * RFC2616:
		 * 
		 * The DELETE method requests that the origin server delete the resource
		 * identified by the Request-URI. [...] The client cannot
		 * be guaranteed that the operation has been carried out, even if the
		 * status code returned from the origin server indicates that the action
		 * has been completed successfully.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpRequestBase.Static {
			new(): Http.HttpDelete;
			new(uri: Java.URI): Http.HttpDelete;
			/**
			 * @throws IllegalArgumentException if the uri is invalid.
			 */
			new(uri: string): Http.HttpDelete;
			METHOD_NAME?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpHead
	 * HTTP HEAD method.
	 * 
	 * The HTTP HEAD method is defined in section 9.4 of
	 * RFC2616:
	 * 
	 * 
	 * The HEAD method is identical to GET except that the server MUST NOT
	 * return a message-body in the response. The metainformation contained
	 * in the HTTP headers in response to a HEAD request SHOULD be identical
	 * to the information sent in response to a GET request. This method can
	 * be used for obtaining metainformation about the entity implied by the
	 * request without transferring the entity-body itself. This method is
	 * often used for testing hypertext links for validity, accessibility,
	 * and recent modification.
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpHead extends Http.HttpRequestBase {
		getMethod(): string;
	}
	export module HttpHead {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpHead
		 * HTTP HEAD method.
		 * 
		 * The HTTP HEAD method is defined in section 9.4 of
		 * RFC2616:
		 * 
		 * 
		 * The HEAD method is identical to GET except that the server MUST NOT
		 * return a message-body in the response. The metainformation contained
		 * in the HTTP headers in response to a HEAD request SHOULD be identical
		 * to the information sent in response to a GET request. This method can
		 * be used for obtaining metainformation about the entity implied by the
		 * request without transferring the entity-body itself. This method is
		 * often used for testing hypertext links for validity, accessibility,
		 * and recent modification.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpRequestBase.Static {
			new(): Http.HttpHead;
			new(uri: Java.URI): Http.HttpHead;
			/**
			 * @throws IllegalArgumentException if the uri is invalid.
			 */
			new(uri: string): Http.HttpHead;
			METHOD_NAME?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.Configurable
	 * Configuration interface for HTTP requests.
	 *
	 * @since 4.3
	 */
	export interface Configurable extends Java.Object {
		/**
		 * Returns actual request configuration.
		 */
		getConfig(): Http.RequestConfig;
	}
	export module Configurable {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.Configurable
		 * Configuration interface for HTTP requests.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.CredentialsProvider
	 * Abstract credentials provider that maintains a collection of user
	 * credentials.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 *
	 * @since 4.0
	 */
	export interface CredentialsProvider extends Java.Object {
		/**
		 * Clears all credentials.
		 */
		clear(): void;
		/**
		 * Get the {@link Credentials credentials} for the given authentication scope.
		 *
		 * @param authscope the {@link AuthScope authentication scope}
		 * @return the credentials
		 *
		 * @see #setCredentials(AuthScope, Credentials)
		 */
		getCredentials(authscope: Http.AuthScope): Http.Credentials;
		/**
		 * Sets the {@link Credentials credentials} for the given authentication
		 * scope. Any previous credentials for the given scope will be overwritten.
		 *
		 * @param authscope the {@link AuthScope authentication scope}
		 * @param credentials the authentication {@link Credentials credentials}
		 * for the given scope.
		 *
		 * @see #getCredentials(AuthScope)
		 */
		setCredentials(authscope: Http.AuthScope, credentials: Http.Credentials): void;
	}
	export module CredentialsProvider {
		/**
		 * Corresponding Java class: org.apache.http.client.CredentialsProvider
		 * Abstract credentials provider that maintains a collection of user
		 * credentials.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpRequestBase
	 * Base implementation of {@link HttpUriRequest}.
	 *
	 * @since 4.0
	 */
	export interface HttpRequestBase extends Http.AbstractExecutionAwareRequest, Http.HttpUriRequest, Http.Configurable {
		getConfig(): Http.RequestConfig;
		getMethod(): string;
		getProtocolVersion(): Http.ProtocolVersion;
		getRequestLine(): Http.RequestLine;
		/**
		 * Returns the original request URI.
		 * 
		 * Please note URI remains unchanged in the course of request execution and
		 * is not updated if the request is redirected to another location.
		 */
		getURI(): Java.URI;
		/**
		 * A convenience method to simplify migration from HttpClient 3.1 API. This method is
		 * equivalent to {@link #reset()}.
		 *
		 * @since 4.2
		 */
		releaseConnection(): void;
		setConfig(config: Http.RequestConfig): void;
		/**
		 * @since 4.3
		 */
		setProtocolVersion(version: Http.ProtocolVersion): void;
		setURI(uri: Java.URI): void;
		/**
		 * @since 4.2
		 */
		started(): void;
		toString(): string;
	}
	export module HttpRequestBase {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpRequestBase
		 * Base implementation of {@link HttpUriRequest}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractExecutionAwareRequest.Static, Http.HttpUriRequest.Static, Http.Configurable.Static {
			new(): Http.HttpRequestBase;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.UserTokenHandler
	 * A handler for determining if the given execution context is user specific
	 * or not. The token object returned by this handler is expected to uniquely
	 * identify the current user if the context is user specific or to be
	 * {@code null} if the context does not contain any resources or details
	 * specific to the current user.
	 * 
	 * The user token will be used to ensure that user specific resources will not
	 * be shared with or reused by other users.
	 * 
	 *
	 * @since 4.0
	 */
	export interface UserTokenHandler extends Java.Object {
		/**
		 * The token object returned by this method is expected to uniquely
		 * identify the current user if the context is user specific or to be
		 * {@code null} if it is not.
		 *
		 * @param context the execution context
		 *
		 * @return user token that uniquely identifies the user or
		 * {@code null} if the context is not user specific.
		 */
		getUserToken(context: Http.HttpContext): obj;
	}
	export module UserTokenHandler {
		/**
		 * Corresponding Java class: org.apache.http.client.UserTokenHandler
		 * A handler for determining if the given execution context is user specific
		 * or not. The token object returned by this handler is expected to uniquely
		 * identify the current user if the context is user specific or to be
		 * {@code null} if the context does not contain any resources or details
		 * specific to the current user.
		 * 
		 * The user token will be used to ensure that user specific resources will not
		 * be shared with or reused by other users.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.params.ClientParamBean
	 * This is a Java Bean class that can be used to wrap an instance of
	 * {@link HttpParams} and manipulate HTTP client parameters using
	 * Java Beans conventions.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
	 */
	export interface ClientParamBean extends Http.HttpAbstractParamBean {
	}
	export module ClientParamBean {
		/**
		 * Corresponding Java class: org.apache.http.client.params.ClientParamBean
		 * This is a Java Bean class that can be used to wrap an instance of
		 * {@link HttpParams} and manipulate HTTP client parameters using
		 * Java Beans conventions.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
		 */
		export interface Static extends Http.HttpAbstractParamBean.Static {
			new(): Http.ClientParamBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.Idn
	 * Abstraction of international domain name (IDN) conversion.
	 *
	 * @deprecated (4.4) use standard {@link java.net.IDN}.
	 *
	 * @since 4.0
	 */
	export interface Idn extends Java.Object {
	}
	export module Idn {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.Idn
		 * Abstraction of international domain name (IDN) conversion.
		 *
		 * @deprecated (4.4) use standard {@link java.net.IDN}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.params.AllClientPNames
	 * Collected parameter names for the HttpClient module.
	 * This interface combines the parameter definitions of the HttpClient
	 * module and all dependency modules or informational units.
	 * It does not define additional parameter names, but references
	 * other interfaces defining parameter names.
	 * 
	 * This interface is meant as a navigation aid for developers.
	 * When referring to parameter names, you should use the interfaces
	 * in which the respective constants are actually defined.
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use
	 *   {@link org.apache.http.client.config.RequestConfig},
	 *   {@link org.apache.http.config.ConnectionConfig},
	 *   {@link org.apache.http.config.SocketConfig}
	 */
	export interface AllClientPNames extends Http.CoreConnectionPNames, Http.CoreProtocolPNames, Http.ClientPNames, Http.AuthPNames, Http.CookieSpecPNames, Http.ConnConnectionPNames, Http.ConnManagerPNames, Http.ConnRoutePNames {
	}
	export module AllClientPNames {
		/**
		 * Corresponding Java class: org.apache.http.client.params.AllClientPNames
		 * Collected parameter names for the HttpClient module.
		 * This interface combines the parameter definitions of the HttpClient
		 * module and all dependency modules or informational units.
		 * It does not define additional parameter names, but references
		 * other interfaces defining parameter names.
		 * 
		 * This interface is meant as a navigation aid for developers.
		 * When referring to parameter names, you should use the interfaces
		 * in which the respective constants are actually defined.
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use
		 *   {@link org.apache.http.client.config.RequestConfig},
		 *   {@link org.apache.http.config.ConnectionConfig},
		 *   {@link org.apache.http.config.SocketConfig}
		 */
		export interface Static extends Http.CoreConnectionPNames.Static, Http.CoreProtocolPNames.Static, Http.ClientPNames.Static, Http.AuthPNames.Static, Http.CookieSpecPNames.Static, Http.ConnConnectionPNames.Static, Http.ConnManagerPNames.Static, Http.ConnRoutePNames.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.HttpClientUtils
	 * Convenience methods for closing response and client objects.
	 *
	 * @since 4.2
	 */
	export interface HttpClientUtils extends Java.Object {
	}
	export module HttpClientUtils {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.HttpClientUtils
		 * Convenience methods for closing response and client objects.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Unconditionally close a response.
			 * 
			 * Example Code:
			 *
			 * 
			 * HttpResponse httpResponse = null;
			 * try {
			 *     httpResponse = httpClient.execute(httpGet);
			 * } catch (Exception e) {
			 *     // error handling
			 * } finally {
			 *     HttpClientUtils.closeQuietly(httpResponse);
			 * }
			 * 
			 *
			 * @param response
			 *            the HttpResponse to release resources, may be null or already
			 *            closed.
			 *
			 * @since 4.2
			 */
			closeQuietly(response: Http.HttpResponse): void;
			/**
			 * Unconditionally close a response.
			 * 
			 * Example Code:
			 *
			 * 
			 * HttpResponse httpResponse = null;
			 * try {
			 *     httpResponse = httpClient.execute(httpGet);
			 * } catch (Exception e) {
			 *     // error handling
			 * } finally {
			 *     HttpClientUtils.closeQuietly(httpResponse);
			 * }
			 * 
			 *
			 * @param response
			 *            the HttpResponse to release resources, may be null or already
			 *            closed.
			 *
			 * @since 4.3
			 */
			closeQuietly(response: Http.CloseableHttpResponse): void;
			/**
			 * Unconditionally close a httpClient. Shuts down the underlying connection
			 * manager and releases the resources.
			 * 
			 * Example Code:
			 *
			 * 
			 * HttpClient httpClient = HttpClients.createDefault();
			 * try {
			 *   httpClient.execute(request);
			 * } catch (Exception e) {
			 *   // error handling
			 * } finally {
			 *   HttpClientUtils.closeQuietly(httpClient);
			 * }
			 * 
			 *
			 * @param httpClient
			 *            the HttpClient to close, may be null or already closed.
			 * @since 4.2
			 */
			closeQuietly(httpClient: Http.HttpClient): void;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.RequestClientConnControl
	 * This protocol interceptor is responsible for adding {@code Connection}
	 * or {@code Proxy-Connection} headers to the outgoing requests, which
	 * is essential for managing persistence of {@code HTTP/1.0} connections.
	 *
	 * @since 4.0
	 */
	export interface RequestClientConnControl extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestClientConnControl {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.RequestClientConnControl
		 * This protocol interceptor is responsible for adding {@code Connection}
		 * or {@code Proxy-Connection} headers to the outgoing requests, which
		 * is essential for managing persistence of {@code HTTP/1.0} connections.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			new(): Http.RequestClientConnControl;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.RequestAuthCache
	 * Request interceptor that can preemptively authenticate against known hosts,
	 * if there is a cached {@link AuthScheme} instance in the local
	 * {@link AuthCache} associated with the given target or proxy host.
	 *
	 * @since 4.1
	 */
	export interface RequestAuthCache extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestAuthCache {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.RequestAuthCache
		 * Request interceptor that can preemptively authenticate against known hosts,
		 * if there is a cached {@link AuthScheme} instance in the local
		 * {@link AuthCache} associated with the given target or proxy host.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			new(): Http.RequestAuthCache;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.ClientContextConfigurer
	 * Configuration facade for {@link HttpContext} instances.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link HttpClientContext}
	 */
	export interface ClientContextConfigurer extends Java.Object, Http.ClientContext {
	}
	export module ClientContextConfigurer {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.ClientContextConfigurer
		 * Configuration facade for {@link HttpContext} instances.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link HttpClientContext}
		 */
		export interface Static extends Java.Object.Static, Http.ClientContext.Static {
			new(): Http.ClientContextConfigurer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.RequestExpectContinue
	 * RequestExpectContinue is responsible for enabling the 'expect-continue'
	 * handshake by adding {@code Expect} header.
	 * 
	 * This interceptor takes into account {@link RequestConfig#isExpectContinueEnabled()}
	 * setting.
	 * 
	 *
	 * @since 4.3
	 */
	export interface ClientRequestExpectContinue extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module ClientRequestExpectContinue {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.RequestExpectContinue
		 * RequestExpectContinue is responsible for enabling the 'expect-continue'
		 * handshake by adding {@code Expect} header.
		 * 
		 * This interceptor takes into account {@link RequestConfig#isExpectContinueEnabled()}
		 * setting.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			new(): Http.ClientRequestExpectContinue;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.RequestAddCookies
	 * Request interceptor that matches cookies available in the current
	 * {@link CookieStore} to the request being executed and generates
	 * corresponding {@code Cookie} request headers.
	 *
	 * @since 4.0
	 */
	export interface RequestAddCookies extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestAddCookies {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.RequestAddCookies
		 * Request interceptor that matches cookies available in the current
		 * {@link CookieStore} to the request being executed and generates
		 * corresponding {@code Cookie} request headers.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			new(): Http.RequestAddCookies;
		}
	}

	/**
	 * @deprecated
	 * Corresponding Java class: org.apache.http.client.protocol.RequestAuthenticationBase
	 */
	export interface RequestAuthenticationBase extends Java.Object, Http.HttpRequestInterceptor {
	}
	export module RequestAuthenticationBase {
		/**
		 * @deprecated
		 * Corresponding Java class: org.apache.http.client.protocol.RequestAuthenticationBase
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			new(): Http.RequestAuthenticationBase;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.ResponseContentEncoding
	 * {@link HttpResponseInterceptor} responsible for processing Content-Encoding
	 * responses.
	 * 
	 * Instances of this class are stateless and immutable, therefore threadsafe.
	 *
	 * @since 4.1
	 *
	 */
	export interface ResponseContentEncoding extends Java.Object, Http.HttpResponseInterceptor {
		process(response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module ResponseContentEncoding {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.ResponseContentEncoding
		 * {@link HttpResponseInterceptor} responsible for processing Content-Encoding
		 * responses.
		 * 
		 * Instances of this class are stateless and immutable, therefore threadsafe.
		 *
		 * @since 4.1
		 *
		 */
		export interface Static extends Java.Object.Static, Http.HttpResponseInterceptor.Static {
			/**
			 * @since 4.5
			 */
			new(decoderRegistry: Http.Lookup<Http.InputStreamFactory>, ignoreUnknown: boolean): Http.ResponseContentEncoding;
			/**
			 * @since 4.5
			 */
			new(ignoreUnknown: boolean): Http.ResponseContentEncoding;
			/**
			 * @since 4.4
			 */
			new(decoderRegistry: Http.Lookup<Http.InputStreamFactory>): Http.ResponseContentEncoding;
			/**
			 * Handles {@code gzip} and {@code deflate} compressed entities by using the following
			 * decoders:
			 * 
			 * gzip - see {@link java.util.zip.GZIPInputStream}
			 * deflate - see {@link org.apache.http.client.entity.DeflateInputStream}
			 * 
			 */
			new(): Http.ResponseContentEncoding;
			UNCOMPRESSED?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.HttpClientContext
	 * Adaptor class that provides convenience type safe setters and getters
	 * for common {@link HttpContext} attributes used in the course
	 * of HTTP request execution.
	 *
	 * @since 4.3
	 */
	export interface HttpClientContext extends Http.HttpCoreContext {
		getAuthCache(): Http.AuthCache;
		getAuthSchemeRegistry(): Http.Lookup<Http.AuthSchemeProvider>;
		getCookieOrigin(): Http.CookieOrigin;
		getCookieSpec(): Http.CookieSpec;
		getCookieSpecRegistry(): Http.Lookup<Http.CookieSpecProvider>;
		getCookieStore(): Http.CookieStore;
		getCredentialsProvider(): Http.CredentialsProvider;
		getHttpRoute(): Http.RouteInfo;
		getProxyAuthState(): Http.AuthState;
		getRedirectLocations(): Java.List<Java.URI>;
		getRequestConfig(): Http.RequestConfig;
		getTargetAuthState(): Http.AuthState;
		getUserToken<T>(clazz: Java.Class<T>): T;
		getUserToken(): obj;
		setAuthCache(authCache: Http.AuthCache): void;
		setAuthSchemeRegistry(lookup: Http.Lookup<Http.AuthSchemeProvider>): void;
		setCookieSpecRegistry(lookup: Http.Lookup<Http.CookieSpecProvider>): void;
		setCookieStore(cookieStore: Http.CookieStore): void;
		setCredentialsProvider(credentialsProvider: Http.CredentialsProvider): void;
		setRequestConfig(config: Http.RequestConfig): void;
		setUserToken(obj: obj): void;
	}
	export module HttpClientContext {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.HttpClientContext
		 * Adaptor class that provides convenience type safe setters and getters
		 * for common {@link HttpContext} attributes used in the course
		 * of HTTP request execution.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.HttpCoreContext.Static {
			new(context: Http.HttpContext): Http.HttpClientContext;
			new(): Http.HttpClientContext;
			/**
			 * Attribute name of a {@link org.apache.http.conn.routing.RouteInfo}
			 * object that represents the actual connection route.
			 */
			HTTP_ROUTE?: string;
			/**
			 * Attribute name of a {@link List} object that represents a collection of all
			 * redirect locations received in the process of request execution.
			 */
			REDIRECT_LOCATIONS?: string;
			/**
			 * Attribute name of a {@link org.apache.http.config.Lookup} object that represents
			 * the actual {@link CookieSpecProvider} registry.
			 */
			COOKIESPEC_REGISTRY?: string;
			/**
			 * Attribute name of a {@link org.apache.http.cookie.CookieSpec}
			 * object that represents the actual cookie specification.
			 */
			COOKIE_SPEC?: string;
			/**
			 * Attribute name of a {@link org.apache.http.cookie.CookieOrigin}
			 * object that represents the actual details of the origin server.
			 */
			COOKIE_ORIGIN?: string;
			/**
			 * Attribute name of a {@link org.apache.http.client.CookieStore}
			 * object that represents the actual cookie store.
			 */
			COOKIE_STORE?: string;
			/**
			 * Attribute name of a {@link org.apache.http.client.CredentialsProvider}
			 * object that represents the actual credentials provider.
			 */
			CREDS_PROVIDER?: string;
			/**
			 * Attribute name of a {@link org.apache.http.client.AuthCache} object
			 * that represents the auth scheme cache.
			 */
			AUTH_CACHE?: string;
			/**
			 * Attribute name of a {@link org.apache.http.auth.AuthState}
			 * object that represents the actual target authentication state.
			 */
			TARGET_AUTH_STATE?: string;
			/**
			 * Attribute name of a {@link org.apache.http.auth.AuthState}
			 * object that represents the actual proxy authentication state.
			 */
			PROXY_AUTH_STATE?: string;
			/**
			 * Attribute name of a {@link java.lang.Object} object that represents
			 * the actual user identity such as user {@link java.security.Principal}.
			 */
			USER_TOKEN?: string;
			/**
			 * Attribute name of a {@link org.apache.http.config.Lookup} object that represents
			 * the actual {@link AuthSchemeProvider} registry.
			 */
			AUTHSCHEME_REGISTRY?: string;
			/**
			 * Attribute name of a {@link org.apache.http.client.config.RequestConfig} object that
			 * represents the actual request configuration.
			 */
			REQUEST_CONFIG?: string;
			adapt(context: Http.HttpContext): Http.HttpClientContext;
			create(): Http.HttpClientContext;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.config.RequestConfig
	 *  Immutable class encapsulating request configuration items.
	 *  The default setting for stale connection checking changed
	 *  to false, and the feature was deprecated starting with version 4.4.
	 */
	export interface RequestConfig extends Java.Object, Java.Cloneable {
		/**
		 * Determines the timeout in milliseconds until a connection is established.
		 * A timeout value of zero is interpreted as an infinite timeout.
		 * 
		 * A timeout value of zero is interpreted as an infinite timeout.
		 * A negative value is interpreted as undefined (system default).
		 * 
		 * 
		 * Default: {@code -1}
		 * 
		 */
		getConnectTimeout(): int;
		/**
		 * Returns the timeout in milliseconds used when requesting a connection
		 * from the connection manager. A timeout value of zero is interpreted
		 * as an infinite timeout.
		 * 
		 * A timeout value of zero is interpreted as an infinite timeout.
		 * A negative value is interpreted as undefined (system default).
		 * 
		 * 
		 * Default: {@code -1}
		 * 
		 */
		getConnectionRequestTimeout(): int;
		/**
		 * Determines the name of the cookie specification to be used for HTTP state
		 * management.
		 * 
		 * Default: {@code null}
		 * 
		 */
		getCookieSpec(): string;
		/**
		 * Returns local address to be used for request execution.
		 * 
		 * On machines with multiple network interfaces, this parameter
		 * can be used to select the network interface from which the
		 * connection originates.
		 * 
		 * 
		 * Default: {@code null}
		 * 
		 */
		getLocalAddress(): Java.InetAddress;
		/**
		 * Returns the maximum number of redirects to be followed. The limit on number
		 * of redirects is intended to prevent infinite loops.
		 * 
		 * Default: {@code 50}
		 * 
		 */
		getMaxRedirects(): int;
		/**
		 * Returns HTTP proxy to be used for request execution.
		 * 
		 * Default: {@code null}
		 * 
		 */
		getProxy(): Http.HttpHost;
		/**
		 * Determines the order of preference for supported authentication schemes
		 * when authenticating with the proxy host.
		 * 
		 * Default: {@code null}
		 * 
		 */
		getProxyPreferredAuthSchemes(): Java.Collection<string>;
		/**
		 * Defines the socket timeout ({@code SO_TIMEOUT}) in milliseconds,
		 * which is the timeout for waiting for data  or, put differently,
		 * a maximum period inactivity between two consecutive data packets).
		 * 
		 * A timeout value of zero is interpreted as an infinite timeout.
		 * A negative value is interpreted as undefined (system default).
		 * 
		 * 
		 * Default: {@code -1}
		 * 
		 */
		getSocketTimeout(): int;
		/**
		 * Determines the order of preference for supported authentication schemes
		 * when authenticating with the target host.
		 * 
		 * Default: {@code null}
		 * 
		 */
		getTargetPreferredAuthSchemes(): Java.Collection<string>;
		/**
		 * Determines whether authentication should be handled automatically.
		 * 
		 * Default: {@code true}
		 * 
		 */
		isAuthenticationEnabled(): boolean;
		/**
		 * Determines whether circular redirects (redirects to the same location) should
		 * be allowed. The HTTP spec is not sufficiently clear whether circular redirects
		 * are permitted, therefore optionally they can be enabled
		 * 
		 * Default: {@code false}
		 * 
		 */
		isCircularRedirectsAllowed(): boolean;
		/**
		 * Determines whether the target server is requested to compress content.
		 * 
		 * Default: {@code true}
		 * 
		 *
		 * @since 4.5
		 */
		isContentCompressionEnabled(): boolean;
		/**
		 * Determines whether the 'Expect: 100-Continue' handshake is enabled
		 * for entity enclosing methods. The purpose of the 'Expect: 100-Continue'
		 * handshake is to allow a client that is sending a request message with
		 * a request body to determine if the origin server is willing to
		 * accept the request (based on the request headers) before the client
		 * sends the request body.
		 * 
		 * The use of the 'Expect: 100-continue' handshake can result in
		 * a noticeable performance improvement for entity enclosing requests
		 * (such as POST and PUT) that require the target server's
		 * authentication.
		 * 
		 * 
		 * 'Expect: 100-continue' handshake should be used with caution, as it
		 * may cause problems with HTTP servers and proxies that do not support
		 * HTTP/1.1 protocol.
		 * 
		 * 
		 * Default: {@code false}
		 * 
		 */
		isExpectContinueEnabled(): boolean;
		/**
		 * Determines whether redirects should be handled automatically.
		 * 
		 * Default: {@code true}
		 * 
		 */
		isRedirectsEnabled(): boolean;
		/**
		 * Determines whether relative redirects should be rejected. HTTP specification
		 * requires the location value be an absolute URI.
		 * 
		 * Default: {@code true}
		 * 
		 */
		isRelativeRedirectsAllowed(): boolean;
		toString(): string;
	}
	export module RequestConfig {
		/**
		 * Corresponding Java class: org.apache.http.client.config.RequestConfig
		 *  Immutable class encapsulating request configuration items.
		 *  The default setting for stale connection checking changed
		 *  to false, and the feature was deprecated starting with version 4.4.
		 */
		export interface Static extends Java.Object.Static, Java.Cloneable.Static {
			Builder: RequestConfig$Builder.Static;
			new(): Http.RequestConfig;
			DEFAULT?: Http.RequestConfig;
			copy(config: Http.RequestConfig): Http.RequestConfig$Builder;
			custom(): Http.RequestConfig$Builder;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.client.config.RequestConfig.Builder
	 */
	export interface RequestConfig$Builder extends Java.Object {
		build(): Http.RequestConfig;
		setAuthenticationEnabled(authenticationEnabled: boolean): Http.RequestConfig$Builder;
		setCircularRedirectsAllowed(circularRedirectsAllowed: boolean): Http.RequestConfig$Builder;
		setConnectTimeout(connectTimeout: int): Http.RequestConfig$Builder;
		setConnectionRequestTimeout(connectionRequestTimeout: int): Http.RequestConfig$Builder;
		setContentCompressionEnabled(contentCompressionEnabled: boolean): Http.RequestConfig$Builder;
		setCookieSpec(cookieSpec: string): Http.RequestConfig$Builder;
		setExpectContinueEnabled(expectContinueEnabled: boolean): Http.RequestConfig$Builder;
		setLocalAddress(localAddress: Java.InetAddress): Http.RequestConfig$Builder;
		setMaxRedirects(maxRedirects: int): Http.RequestConfig$Builder;
		setProxy(proxy: Http.HttpHost): Http.RequestConfig$Builder;
		setProxyPreferredAuthSchemes(proxyPreferredAuthSchemes: Java.Collection<string>): Http.RequestConfig$Builder;
		setRedirectsEnabled(redirectsEnabled: boolean): Http.RequestConfig$Builder;
		setRelativeRedirectsAllowed(relativeRedirectsAllowed: boolean): Http.RequestConfig$Builder;
		setSocketTimeout(socketTimeout: int): Http.RequestConfig$Builder;
		setTargetPreferredAuthSchemes(targetPreferredAuthSchemes: Java.Collection<string>): Http.RequestConfig$Builder;
	}
	export module RequestConfig$Builder {
		/**
		 * Corresponding Java class: org.apache.http.client.config.RequestConfig.Builder
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.RequestConfig$Builder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.config.CookieSpecs
	 * Standard cookie specifications supported by HttpClient.
	 *
	 * @since 4.3
	 */
	export interface CookieSpecs extends Java.Object {
	}
	export module CookieSpecs {
		/**
		 * Corresponding Java class: org.apache.http.client.config.CookieSpecs
		 * Standard cookie specifications supported by HttpClient.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * The Netscape cookie draft compliant policy.
			 */
			NETSCAPE?: string;
			/**
			 * The RFC 6265 compliant policy (interoprability profile).
			 */
			STANDARD?: string;
			/**
			 * The RFC 6265 compliant policy (strict profile).
			 *
			 * @since 4.4
			 */
			STANDARD_STRICT?: string;
			/**
			 * The default policy. This policy provides a higher degree of compatibility
			 * with common cookie management of popular HTTP agents for non-standard
			 * (Netscape style) cookies.
			 */
			DEFAULT?: string;
			/**
			 * The policy that ignores cookies.
			 */
			IGNORE_COOKIES?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.config.AuthSchemes
	 * Standard authentication schemes supported by HttpClient.
	 *
	 * @since 4.3
	 */
	export interface AuthSchemes extends Java.Object {
	}
	export module AuthSchemes {
		/**
		 * Corresponding Java class: org.apache.http.client.config.AuthSchemes
		 * Standard authentication schemes supported by HttpClient.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Basic authentication scheme as defined in RFC 2617 (considered inherently
			 * insecure, but most widely supported).
			 */
			BASIC?: string;
			/**
			 * Digest authentication scheme as defined in RFC 2617.
			 */
			DIGEST?: string;
			/**
			 * The NTLM authentication scheme is a proprietary Microsoft Windows
			 * authentication protocol as defined in [MS-NLMP].
			 */
			NTLM?: string;
			/**
			 * SPNEGO authentication scheme as defined in RFC 4559 and RFC 4178
			 * (considered to be the most secure among currently supported
			 * authentication schemes if Kerberos is selected).
			 */
			SPNEGO?: string;
			/**
			 * Kerberos authentication scheme as defined in RFC 4120
			 * (considered to be the most secure among currently supported
			 * authentication schemes).
			 */
			KERBEROS?: string;
			/**
			 * CredSSP authentication scheme defined in [MS-CSSP].
			 */
			CREDSSP?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.RedirectException
	 * Signals violation of HTTP specification caused by an invalid redirect
	 *
	 *
	 * @since 4.0
	 */
	export interface RedirectException extends Http.ProtocolException {
	}
	export module RedirectException {
		/**
		 * Corresponding Java class: org.apache.http.client.RedirectException
		 * Signals violation of HTTP specification caused by an invalid redirect
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.ProtocolException.Static {
			/**
			 * Creates a new RedirectException with a {@code null} detail message.
			 */
			new(): Http.RedirectException;
			/**
			 * Creates a new RedirectException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.RedirectException;
			/**
			 * Creates a new RedirectException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.RedirectException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.BackoffManager
	 * Represents a controller that dynamically adjusts the size
	 * of an available connection pool based on feedback from
	 * using the connections.
	 *
	 * @since 4.2
	 *
	 */
	export interface BackoffManager extends Java.Object {
		/**
		 * Called when we have decided that the result of
		 * using a connection should be interpreted as a
		 * backoff signal.
		 */
		backOff(route: Http.HttpRoute): void;
		/**
		 * Called when we have determined that the result of
		 * using a connection has succeeded and that we may
		 * probe for more connections.
		 */
		probe(route: Http.HttpRoute): void;
	}
	export module BackoffManager {
		/**
		 * Corresponding Java class: org.apache.http.client.BackoffManager
		 * Represents a controller that dynamically adjusts the size
		 * of an available connection pool based on feedback from
		 * using the connections.
		 *
		 * @since 4.2
		 *
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.InputStreamFactory
	 * Factory for decorated {@link java.io.InputStream}s.
	 *
	 * @since 4.4
	 */
	export interface InputStreamFactory extends Java.Object {
		create(instream: Java.InputStream): Java.InputStream;
	}
	export module InputStreamFactory {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.InputStreamFactory
		 * Factory for decorated {@link java.io.InputStream}s.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.DeflateDecompressingEntity
	 * {@link org.apache.http.entity.HttpEntityWrapper} responsible for handling
	 * deflate Content Coded responses. In RFC2616 terms, {@code deflate}
	 * means a {@code zlib} stream as defined in RFC1950. Some server
	 * implementations have misinterpreted RFC2616 to mean that a
	 * {@code deflate} stream as defined in RFC1951 should be used
	 * (or maybe they did that since that's how IE behaves?). It's confusing
	 * that {@code deflate} in HTTP 1.1 means {@code zlib} streams
	 * rather than {@code deflate} streams. We handle both types in here,
	 * since that's what is seen on the internet. Moral - prefer
	 * {@code gzip}!
	 *
	 * @see GzipDecompressingEntity
	 *
	 * @since 4.1
	 */
	export interface DeflateDecompressingEntity extends Http.DecompressingEntity {
	}
	export module DeflateDecompressingEntity {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.DeflateDecompressingEntity
		 * {@link org.apache.http.entity.HttpEntityWrapper} responsible for handling
		 * deflate Content Coded responses. In RFC2616 terms, {@code deflate}
		 * means a {@code zlib} stream as defined in RFC1950. Some server
		 * implementations have misinterpreted RFC2616 to mean that a
		 * {@code deflate} stream as defined in RFC1951 should be used
		 * (or maybe they did that since that's how IE behaves?). It's confusing
		 * that {@code deflate} in HTTP 1.1 means {@code zlib} streams
		 * rather than {@code deflate} streams. We handle both types in here,
		 * since that's what is seen on the internet. Moral - prefer
		 * {@code gzip}!
		 *
		 * @see GzipDecompressingEntity
		 *
		 * @since 4.1
		 */
		export interface Static extends Http.DecompressingEntity.Static {
			/**
			 * Creates a new {@link DeflateDecompressingEntity} which will wrap the specified
			 * {@link HttpEntity}.
			 *
			 * @param entity
			 *            a non-null {@link HttpEntity} to be wrapped
			 */
			new(entity: Http.HttpEntity): Http.DeflateDecompressingEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.HttpRequestRetryHandler
	 * A handler for determining if an HttpRequest should be retried after a
	 * recoverable exception during execution.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 *
	 * @since 4.0
	 */
	export interface HttpRequestRetryHandler extends Java.Object {
		/**
		 * Determines if a method should be retried after an IOException
		 * occurs during execution.
		 *
		 * @param exception the exception that occurred
		 * @param executionCount the number of times this method has been
		 * unsuccessfully executed
		 * @param context the context for the request execution
		 *
		 * @return {@code true} if the method should be retried, {@code false}
		 * otherwise
		 */
		retryRequest(exception: Java.IOException, executionCount: int, context: Http.HttpContext): boolean;
	}
	export module HttpRequestRetryHandler {
		/**
		 * Corresponding Java class: org.apache.http.client.HttpRequestRetryHandler
		 * A handler for determining if an HttpRequest should be retried after a
		 * recoverable exception during execution.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.EntityBuilder
	 * Builder for {@link HttpEntity} instances.
	 * 
	 * Several setter methods of this builder are mutually exclusive. In case of multiple invocations
	 * of the following methods only the last one will have effect:
	 * 
	 * 
	 *   {@link #setText(String)}
	 *   {@link #setBinary(byte[])}
	 *   {@link #setStream(java.io.InputStream)}
	 *   {@link #setSerializable(java.io.Serializable)}
	 *   {@link #setParameters(java.util.List)}
	 *   {@link #setParameters(org.apache.http.NameValuePair...)}
	 *   {@link #setFile(java.io.File)}
	 * 
	 *
	 * @since 4.3
	 */
	export interface EntityBuilder extends Java.Object {
		/**
		 * Creates new instance of {@link HttpEntity} based on the current state.
		 */
		build(): Http.HttpEntity;
		/**
		 * Makes entity chunk coded.
		 */
		chunked(): Http.EntityBuilder;
		/**
		 * Returns entity content as a byte array if set using
		 * {@link #setBinary(byte[])} method.
		 */
		getBinary(): array<byte>;
		/**
		 * Returns content encoding of the entity, if set.
		 */
		getContentEncoding(): string;
		/**
		 * Returns {@link ContentType} of the entity, if set.
		 */
		getContentType(): Http.ContentType;
		/**
		 * Returns entity content as a {@link File} if set using
		 * {@link #setFile(java.io.File)} method.
		 */
		getFile(): Java.File;
		/**
		 * Returns entity content as a parameter list if set using
		 * {@link #setParameters(java.util.List)} or
		 * {@link #setParameters(org.apache.http.NameValuePair...)} methods.
		 */
		getParameters(): Java.List<Http.NameValuePair>;
		/**
		 * Returns entity content as a {@link Serializable} if set using
		 * {@link #setSerializable(java.io.Serializable)} method.
		 */
		getSerializable(): Java.Serializable;
		/**
		 * Returns entity content as a {@link InputStream} if set using
		 * {@link #setStream(java.io.InputStream)} method.
		 */
		getStream(): Java.InputStream;
		/**
		 * Returns entity content as a string if set using {@link #setText(String)} method.
		 */
		getText(): string;
		/**
		 * Makes entity GZIP compressed.
		 */
		gzipCompress(): Http.EntityBuilder;
		/**
		 * Returns {@code true} if entity is to be chunk coded, {@code false} otherwise.
		 */
		isChunked(): boolean;
		/**
		 * Returns {@code true} if entity is to be GZIP compressed, {@code false} otherwise.
		 */
		isGzipCompress(): boolean;
		/**
		 * Sets entity content as a byte array. This method is mutually exclusive
		 * with:
		 * 
		 * {@link #setText(String)}
		 * {@link #setStream(java.io.InputStream)}
		 * {@link #setSerializable(java.io.Serializable)}
		 * {@link #setParameters(java.util.List)}
		 * {@link #setParameters(org.apache.http.NameValuePair...)}
		 * {@link #setFile(java.io.File)}
		 * 
		 */
		setBinary(binary: array<byte>): Http.EntityBuilder;
		/**
		 * Sets content encoding of the entity.
		 */
		setContentEncoding(contentEncoding: string): Http.EntityBuilder;
		/**
		 * Sets {@link ContentType} of the entity.
		 */
		setContentType(contentType: Http.ContentType): Http.EntityBuilder;
		/**
		 * Sets entity content as a {@link File}. This method is mutually exclusive with:
		 * 
		 * {@link #setText(String)}
		 * {@link #setBinary(byte[])}
		 * {@link #setStream(java.io.InputStream)}
		 * {@link #setParameters(java.util.List)}
		 * {@link #setParameters(org.apache.http.NameValuePair...)}
		 * {@link #setSerializable(java.io.Serializable)}
		 * 
		 */
		setFile(file: Java.File): Http.EntityBuilder;
		/**
		 * Sets entity content as a parameter list. This method is mutually
		 * exclusive with:
		 * 
		 * {@link #setText(String)}
		 * {@link #setBinary(byte[])}
		 * {@link #setStream(java.io.InputStream)}
		 * {@link #setSerializable(java.io.Serializable)}
		 * {@link #setFile(java.io.File)}
		 * 
		 */
		setParameters(parameters: Java.List<Http.NameValuePair>): Http.EntityBuilder;
		/**
		 * Sets entity content as a parameter list. This method is mutually exclusive with:
		 * 
		 * {@link #setText(String)}
		 * {@link #setBinary(byte[])}
		 * {@link #setStream(java.io.InputStream)}
		 * {@link #setSerializable(java.io.Serializable)}
		 * {@link #setFile(java.io.File)}
		 * 
		 */
		setParameters(...parameters: Http.NameValuePair[]): Http.EntityBuilder;
		/**
		 * Sets entity content as a parameter list. This method is mutually exclusive with:
		 * 
		 * {@link #setText(String)}
		 * {@link #setBinary(byte[])}
		 * {@link #setStream(java.io.InputStream)}
		 * {@link #setSerializable(java.io.Serializable)}
		 * {@link #setFile(java.io.File)}
		 * 
		 */
		setParameters(parameters: array<Http.NameValuePair>): Http.EntityBuilder;
		/**
		 * Sets entity content as a {@link Serializable}. This method is mutually exclusive with:
		 * 
		 * {@link #setText(String)}
		 * {@link #setBinary(byte[])}
		 * {@link #setStream(java.io.InputStream)}
		 * {@link #setParameters(java.util.List)}
		 * {@link #setParameters(org.apache.http.NameValuePair...)}
		 * {@link #setFile(java.io.File)}
		 * 
		 */
		setSerializable(serializable: Java.Serializable): Http.EntityBuilder;
		/**
		 * Sets entity content as a {@link InputStream}. This method is mutually
		 * exclusive with:
		 * 
		 * {@link #setText(String)}
		 * {@link #setBinary(byte[])}
		 * {@link #setSerializable(java.io.Serializable)}
		 * {@link #setParameters(java.util.List)}
		 * {@link #setParameters(org.apache.http.NameValuePair...)}
		 * {@link #setFile(java.io.File)}
		 * 
		 */
		setStream(stream: Java.InputStream): Http.EntityBuilder;
		/**
		 * Sets entity content as a string. This method is mutually exclusive with:
		 * 
		 * {@link #setBinary(byte[])}
		 * {@link #setStream(java.io.InputStream)}
		 * {@link #setSerializable(java.io.Serializable)}
		 * {@link #setParameters(java.util.List)}
		 * {@link #setParameters(org.apache.http.NameValuePair...)}
		 * {@link #setFile(java.io.File)}
		 * 
		 */
		setText(text: string): Http.EntityBuilder;
	}
	export module EntityBuilder {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.EntityBuilder
		 * Builder for {@link HttpEntity} instances.
		 * 
		 * Several setter methods of this builder are mutually exclusive. In case of multiple invocations
		 * of the following methods only the last one will have effect:
		 * 
		 * 
		 *   {@link #setText(String)}
		 *   {@link #setBinary(byte[])}
		 *   {@link #setStream(java.io.InputStream)}
		 *   {@link #setSerializable(java.io.Serializable)}
		 *   {@link #setParameters(java.util.List)}
		 *   {@link #setParameters(org.apache.http.NameValuePair...)}
		 *   {@link #setFile(java.io.File)}
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.EntityBuilder;
			create(): Http.EntityBuilder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.OperatedClientConnection
	 * A client-side connection that relies on outside logic to connect sockets to the
	 * appropriate hosts. It can be operated directly by an application, or through an
	 * {@link ClientConnectionOperator operator}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
	 */
	export interface OperatedClientConnection extends Http.HttpClientConnection, Http.HttpInetConnection {
	}
	export module OperatedClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.conn.OperatedClientConnection
		 * A client-side connection that relies on outside logic to connect sockets to the
		 * appropriate hosts. It can be operated directly by an application, or through an
		 * {@link ClientConnectionOperator operator}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
		 */
		export interface Static extends Http.HttpClientConnection.Static, Http.HttpInetConnection.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.EofSensorInputStream
	 */
	export interface EofSensorInputStream extends Java.InputStream, Http.ConnectionReleaseTrigger {
		/**
		 * Aborts this stream.
		 * This is a special version of {@link #close close()} which prevents
		 * re-use of the underlying connection, if any. Calling this method
		 * indicates that there should be no attempt to read until the end of
		 * the stream.
		 */
		abortConnection(): void;
		available(): int;
		close(): void;
		read(): int;
		read(b: array<byte>, off: int, len: int): int;
		read(b: array<byte>): int;
		/**
		 * Same as {@link #close close()}.
		 */
		releaseConnection(): void;
	}
	export module EofSensorInputStream {
		/**
		 * Corresponding Java class: org.apache.http.conn.EofSensorInputStream
		 */
		export interface Static extends Java.InputStream.Static, Http.ConnectionReleaseTrigger.Static {
			/**
			 * Creates a new EOF sensor.
			 * If no watcher is passed, the underlying stream will simply be
			 * closed when EOF is detected or {@link #close close} is called.
			 * Otherwise, the watcher decides whether the underlying stream
			 * should be closed before detaching from it.
			 *
			 * @param in        the wrapped stream
			 * @param watcher   the watcher for events, or {@code null} for
			 *                  auto-close behavior without notification
			 */
			new(in_: Java.InputStream, watcher: Http.EofSensorWatcher): Http.EofSensorInputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.StrictHostnameVerifier
	 * The Strict HostnameVerifier works the same way as Sun Java 1.4, Sun
	 * Java 5, Sun Java 6.  It's also pretty close to IE6.  This implementation
	 * appears to be compliant with RFC 2818 for dealing with wildcards.
	 * 
	 * The hostname must match either the first CN, or any of the subject-alts.
	 * A wildcard can occur in the CN, and in any of the subject-alts.  The
	 * one divergence from IE6 is how we only check the first CN.  IE6 allows
	 * a match against any of the CNs present.  We decided to follow in
	 * Sun Java 1.4's footsteps and only check the first CN.  (If you need
	 * to check all the CN's, feel free to write your own implementation!).
	 * 
	 * 
	 * A wildcard such as "*.foo.com" matches only subdomains in the same
	 * level, for example "a.foo.com".  It does not match deeper subdomains
	 * such as "a.b.foo.com".
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.4) Use {@link org.apache.http.conn.ssl.DefaultHostnameVerifier}
	 */
	export interface StrictHostnameVerifier extends Http.AbstractVerifier {
	}
	export module StrictHostnameVerifier {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.StrictHostnameVerifier
		 * The Strict HostnameVerifier works the same way as Sun Java 1.4, Sun
		 * Java 5, Sun Java 6.  It's also pretty close to IE6.  This implementation
		 * appears to be compliant with RFC 2818 for dealing with wildcards.
		 * 
		 * The hostname must match either the first CN, or any of the subject-alts.
		 * A wildcard can occur in the CN, and in any of the subject-alts.  The
		 * one divergence from IE6 is how we only check the first CN.  IE6 allows
		 * a match against any of the CNs present.  We decided to follow in
		 * Sun Java 1.4's footsteps and only check the first CN.  (If you need
		 * to check all the CN's, feel free to write your own implementation!).
		 * 
		 * 
		 * A wildcard such as "*.foo.com" matches only subdomains in the same
		 * level, for example "a.foo.com".  It does not match deeper subdomains
		 * such as "a.b.foo.com".
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.4) Use {@link org.apache.http.conn.ssl.DefaultHostnameVerifier}
		 */
		export interface Static extends Http.AbstractVerifier.Static {
			new(): Http.StrictHostnameVerifier;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.SSLSocketFactory
	 * Layered socket factory for TLS/SSL connections.
	 * 
	 * SSLSocketFactory can be used to validate the identity of the HTTPS server against a list of
	 * trusted certificates and to authenticate to the HTTPS server using a private key.
	 * 
	 * 
	 * SSLSocketFactory will enable server authentication when supplied with
	 * a {@link KeyStore trust-store} file containing one or several trusted certificates. The client
	 * secure socket will reject the connection during the SSL session handshake if the target HTTPS
	 * server attempts to authenticate itself with a non-trusted certificate.
	 * 
	 * 
	 * Use JDK keytool utility to import a trusted certificate and generate a trust-store file:
	 * 
	 * keytool -import -alias "my server cert" -file server.crt -keystore my.truststore
	 * 
	 * 
	 * In special cases the standard trust verification process can be bypassed by using a custom
	 * {@link TrustStrategy}. This interface is primarily intended for allowing self-signed
	 * certificates to be accepted as trusted without having to add them to the trust-store file.
	 * 
	 * 
	 * SSLSocketFactory will enable client authentication when supplied with
	 * a {@link KeyStore key-store} file containing a private key/public certificate
	 * pair. The client secure socket will use the private key to authenticate
	 * itself to the target HTTPS server during the SSL session handshake if
	 * requested to do so by the server.
	 * The target HTTPS server will in its turn verify the certificate presented
	 * by the client in order to establish client's authenticity.
	 * 
	 * 
	 * Use the following sequence of actions to generate a key-store file
	 * 
	 *   
	 *     
	 *      
	 *      Use JDK keytool utility to generate a new key
	 *      
	 *      keytool -genkey -v -alias "my client key" -validity 365 -keystore my.keystore
	 *      
	 *      For simplicity use the same password for the key as that of the key-store
	 *      
	 *     
	 *     
	 *      
	 *      Issue a certificate signing request (CSR)
	 *     
	 *     keytool -certreq -alias "my client key" -file mycertreq.csr -keystore my.keystore
	 *     
	 *     
	 *      
	 *      Send the certificate request to the trusted Certificate Authority for signature.
	 *      One may choose to act as her own CA and sign the certificate request using a PKI
	 *      tool, such as OpenSSL.
	 *      
	 *     
	 *     
	 *      
	 *       Import the trusted CA root certificate
	 *      
	 *      keytool -import -alias "my trusted ca" -file caroot.crt -keystore my.keystore
	 *     
	 *     
	 *      
	 *       Import the PKCS#7 file containg the complete certificate chain
	 *      
	 *      keytool -import -alias "my client key" -file mycert.p7 -keystore my.keystore
	 *     
	 *     
	 *      
	 *       Verify the content the resultant keystore file
	 *      
	 *      keytool -list -v -keystore my.keystore
	 *     
	 *   
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link SSLConnectionSocketFactory}.
	 */
	export interface SSLSocketFactory extends Java.Object, Http.LayeredConnectionSocketFactory, Http.SchemeLayeredSocketFactory, Http.LayeredSchemeSocketFactory, Http.LayeredSocketFactory {
	}
	export module SSLSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.SSLSocketFactory
		 * Layered socket factory for TLS/SSL connections.
		 * 
		 * SSLSocketFactory can be used to validate the identity of the HTTPS server against a list of
		 * trusted certificates and to authenticate to the HTTPS server using a private key.
		 * 
		 * 
		 * SSLSocketFactory will enable server authentication when supplied with
		 * a {@link KeyStore trust-store} file containing one or several trusted certificates. The client
		 * secure socket will reject the connection during the SSL session handshake if the target HTTPS
		 * server attempts to authenticate itself with a non-trusted certificate.
		 * 
		 * 
		 * Use JDK keytool utility to import a trusted certificate and generate a trust-store file:
		 * 
		 * keytool -import -alias "my server cert" -file server.crt -keystore my.truststore
		 * 
		 * 
		 * In special cases the standard trust verification process can be bypassed by using a custom
		 * {@link TrustStrategy}. This interface is primarily intended for allowing self-signed
		 * certificates to be accepted as trusted without having to add them to the trust-store file.
		 * 
		 * 
		 * SSLSocketFactory will enable client authentication when supplied with
		 * a {@link KeyStore key-store} file containing a private key/public certificate
		 * pair. The client secure socket will use the private key to authenticate
		 * itself to the target HTTPS server during the SSL session handshake if
		 * requested to do so by the server.
		 * The target HTTPS server will in its turn verify the certificate presented
		 * by the client in order to establish client's authenticity.
		 * 
		 * 
		 * Use the following sequence of actions to generate a key-store file
		 * 
		 *   
		 *     
		 *      
		 *      Use JDK keytool utility to generate a new key
		 *      
		 *      keytool -genkey -v -alias "my client key" -validity 365 -keystore my.keystore
		 *      
		 *      For simplicity use the same password for the key as that of the key-store
		 *      
		 *     
		 *     
		 *      
		 *      Issue a certificate signing request (CSR)
		 *     
		 *     keytool -certreq -alias "my client key" -file mycertreq.csr -keystore my.keystore
		 *     
		 *     
		 *      
		 *      Send the certificate request to the trusted Certificate Authority for signature.
		 *      One may choose to act as her own CA and sign the certificate request using a PKI
		 *      tool, such as OpenSSL.
		 *      
		 *     
		 *     
		 *      
		 *       Import the trusted CA root certificate
		 *      
		 *      keytool -import -alias "my trusted ca" -file caroot.crt -keystore my.keystore
		 *     
		 *     
		 *      
		 *       Import the PKCS#7 file containg the complete certificate chain
		 *      
		 *      keytool -import -alias "my client key" -file mycert.p7 -keystore my.keystore
		 *     
		 *     
		 *      
		 *       Verify the content the resultant keystore file
		 *      
		 *      keytool -list -v -keystore my.keystore
		 *     
		 *   
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link SSLConnectionSocketFactory}.
		 */
		export interface Static extends Java.Object.Static, Http.LayeredConnectionSocketFactory.Static, Http.SchemeLayeredSocketFactory.Static, Http.LayeredSchemeSocketFactory.Static, Http.LayeredSocketFactory.Static {
			new(): Http.SSLSocketFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.NoopHostnameVerifier
	 * The NO_OP HostnameVerifier essentially turns hostname verification
	 * off. This implementation is a no-op, and never throws the SSLException.
	 *
	 * @since 4.4
	 */
	export interface NoopHostnameVerifier extends Java.Object, Java.HostnameVerifier {
		toString(): string;
		verify(s: string, sslSession: Java.SSLSession): boolean;
	}
	export module NoopHostnameVerifier {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.NoopHostnameVerifier
		 * The NO_OP HostnameVerifier essentially turns hostname verification
		 * off. This implementation is a no-op, and never throws the SSLException.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Java.HostnameVerifier.Static {
			new(): Http.NoopHostnameVerifier;
			INSTANCE?: Http.NoopHostnameVerifier;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.PlainSocketFactory
	 * The default class for creating plain (unencrypted) sockets.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.conn.socket.PlainConnectionSocketFactory}
	 */
	export interface PlainSocketFactory extends Java.Object, Http.SocketFactory, Http.SchemeSocketFactory {
	}
	export module PlainSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.PlainSocketFactory
		 * The default class for creating plain (unencrypted) sockets.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.conn.socket.PlainConnectionSocketFactory}
		 */
		export interface Static extends Java.Object.Static, Http.SocketFactory.Static, Http.SchemeSocketFactory.Static {
			new(): Http.PlainSocketFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.SchemeRegistry
	 * A set of supported protocol {@link Scheme}s.
	 * Schemes are identified by lowercase names.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.config.Registry}
	 */
	export interface SchemeRegistry extends Java.Object {
	}
	export module SchemeRegistry {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.SchemeRegistry
		 * A set of supported protocol {@link Scheme}s.
		 * Schemes are identified by lowercase names.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.config.Registry}
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.SchemeRegistry;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.SSLInitializationException
	 */
	export interface ConnectionSSLInitializationException extends Java.IllegalStateException {
	}
	export module ConnectionSSLInitializationException {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.SSLInitializationException
		 */
		export interface Static extends Java.IllegalStateException.Static {
			new(message: string, cause: Java.Throwable): Http.ConnectionSSLInitializationException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.SchemeSocketFactory
	 * A factory for creating, initializing and connecting sockets. The factory encapsulates the logic
	 * for establishing a socket connection.
	 *
	 * @since 4.1
	 *
	 * @deprecated (4.3) use {@link org.apache.http.conn.socket.ConnectionSocketFactory}
	 */
	export interface SchemeSocketFactory extends Java.Object {
	}
	export module SchemeSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.SchemeSocketFactory
		 * A factory for creating, initializing and connecting sockets. The factory encapsulates the logic
		 * for establishing a socket connection.
		 *
		 * @since 4.1
		 *
		 * @deprecated (4.3) use {@link org.apache.http.conn.socket.ConnectionSocketFactory}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.UnsupportedSchemeException
	 * Signals failure to establish connection using an unknown protocol scheme.
	 *
	 * @since 4.3
	 */
	export interface UnsupportedSchemeException extends Java.IOException {
	}
	export module UnsupportedSchemeException {
		/**
		 * Corresponding Java class: org.apache.http.conn.UnsupportedSchemeException
		 * Signals failure to establish connection using an unknown protocol scheme.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.IOException.Static {
			/**
			 * Creates a UnsupportedSchemeException with the specified detail message.
			 */
			new(message: string): Http.UnsupportedSchemeException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.SchemeLayeredSocketFactoryAdaptor
	 * @deprecated (4.2) do not use
	 */
	export interface SchemeLayeredSocketFactoryAdaptor extends Http.SchemeSocketFactoryAdaptor, Http.SchemeLayeredSocketFactory {
	}
	export module SchemeLayeredSocketFactoryAdaptor {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.SchemeLayeredSocketFactoryAdaptor
		 * @deprecated (4.2) do not use
		 */
		export interface Static extends Http.SchemeSocketFactoryAdaptor.Static, Http.SchemeLayeredSocketFactory.Static {
			new(): Http.SchemeLayeredSocketFactoryAdaptor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.KerberosScheme
	 * KERBEROS authentication scheme.
	 *
	 * @since 4.2
	 */
	export interface KerberosScheme extends Http.GGSSchemeBase {
		/**
		 * Produces KERBEROS authorization Header based on token created by
		 * processChallenge.
		 *
		 * @param credentials not used by the KERBEROS scheme.
		 * @param request The request being authenticated
		 *
		 * @throws AuthenticationException if authentication string cannot
		 *   be generated due to an authentication failure
		 *
		 * @return KERBEROS authentication Header
		 */
		authenticate(credentials: Http.Credentials, request: Http.HttpRequest, context: Http.HttpContext): Http.Header;
		/**
		 * There are no valid parameters for KERBEROS authentication so this
		 * method always returns {@code null}.
		 *
		 * @return {@code null}
		 */
		getParameter(name: string): string;
		/**
		 * The concept of an authentication realm is not supported by the Negotiate
		 * authentication scheme. Always returns {@code null}.
		 *
		 * @return {@code null}
		 */
		getRealm(): string;
		getSchemeName(): string;
		/**
		 * Returns {@code true}. KERBEROS authentication scheme is connection based.
		 *
		 * @return {@code true}.
		 */
		isConnectionBased(): boolean;
	}
	export module KerberosScheme {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.KerberosScheme
		 * KERBEROS authentication scheme.
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.GGSSchemeBase.Static {
			/**
			 * @since 4.4
			 */
			new(stripPort: boolean, useCanonicalHostname: boolean): Http.KerberosScheme;
			new(stripPort: boolean): Http.KerberosScheme;
			new(): Http.KerberosScheme;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.SPNegoScheme
	 * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
	 * scheme.
	 *
	 * @since 4.2
	 */
	export interface SPNegoScheme extends Http.GGSSchemeBase {
		/**
		 * Produces SPNEGO authorization Header based on token created by
		 * processChallenge.
		 *
		 * @param credentials not used by the SPNEGO scheme.
		 * @param request The request being authenticated
		 *
		 * @throws AuthenticationException if authentication string cannot
		 *   be generated due to an authentication failure
		 *
		 * @return SPNEGO authentication Header
		 */
		authenticate(credentials: Http.Credentials, request: Http.HttpRequest, context: Http.HttpContext): Http.Header;
		/**
		 * There are no valid parameters for SPNEGO authentication so this
		 * method always returns {@code null}.
		 *
		 * @return {@code null}
		 */
		getParameter(name: string): string;
		/**
		 * The concept of an authentication realm is not supported by the Negotiate
		 * authentication scheme. Always returns {@code null}.
		 *
		 * @return {@code null}
		 */
		getRealm(): string;
		getSchemeName(): string;
		/**
		 * Returns {@code true}. SPNEGO authentication scheme is connection based.
		 *
		 * @return {@code true}.
		 */
		isConnectionBased(): boolean;
	}
	export module SPNegoScheme {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.SPNegoScheme
		 * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
		 * scheme.
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.GGSSchemeBase.Static {
			/**
			 * @since 4.4
			 */
			new(stripPort: boolean, useCanonicalHostname: boolean): Http.SPNegoScheme;
			new(stripPort: boolean): Http.SPNegoScheme;
			new(): Http.SPNegoScheme;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NegotiateScheme
	 * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
	 * scheme.
	 *
	 * @since 4.1
	 *
	 * @deprecated (4.2)  use {@link SPNegoScheme} or {@link KerberosScheme}.
	 */
	export interface NegotiateScheme extends Http.GGSSchemeBase {
	}
	export module NegotiateScheme {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NegotiateScheme
		 * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
		 * scheme.
		 *
		 * @since 4.1
		 *
		 * @deprecated (4.2)  use {@link SPNegoScheme} or {@link KerberosScheme}.
		 */
		export interface Static extends Http.GGSSchemeBase.Static {
			new(): Http.NegotiateScheme;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.GGSSchemeBase
	 * @since 4.2
	 */
	export interface GGSSchemeBase extends Http.AuthSchemeBase {
		authenticate(credentials: Http.Credentials, request: Http.HttpRequest, context: Http.HttpContext): Http.Header;
		isComplete(): boolean;
	}
	export module GGSSchemeBase {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.GGSSchemeBase
		 * @since 4.2
		 */
		export interface Static extends Http.AuthSchemeBase.Static {
			new(): Http.GGSSchemeBase;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.GGSSchemeBase.State
	 */
	export interface GGSSchemeBase$State extends Java.Enum<GGSSchemeBase$State> {
	}
	export module GGSSchemeBase$State {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.GGSSchemeBase.State
		 */
		export interface Static extends Java.Enum.Static {
			UNINITIATED?: Http.GGSSchemeBase$State;
			CHALLENGE_RECEIVED?: Http.GGSSchemeBase$State;
			TOKEN_GENERATED?: Http.GGSSchemeBase$State;
			FAILED?: Http.GGSSchemeBase$State;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl
	 * Provides an implementation for NTLMv1, NTLMv2, and NTLM2 Session forms of the NTLM
	 * authentication protocol.
	 *
	 * @since 4.1
	 */
	export interface NTLMEngineImpl extends Java.Object, Http.NTLMEngine {
		generateType1Msg(domain: string, workstation: string): string;
		generateType3Msg(username: string, password: string, domain: string, workstation: string, challenge: string): string;
	}
	export module NTLMEngineImpl {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl
		 * Provides an implementation for NTLMv1, NTLMv2, and NTLM2 Session forms of the NTLM
		 * authentication protocol.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static, Http.NTLMEngine.Static {
			CipherGen: NTLMEngineImpl$CipherGen.Static;
			Handle: NTLMEngineImpl$Handle.Static;
			NTLMMessage: NTLMEngineImpl$NTLMMessage.Static;
			Type1Message: NTLMEngineImpl$Type1Message.Static;
			Type2Message: NTLMEngineImpl$Type2Message.Static;
			Type3Message: NTLMEngineImpl$Type3Message.Static;
			MD4: NTLMEngineImpl$MD4.Static;
			HMACMD5: NTLMEngineImpl$HMACMD5.Static;
			new(): Http.NTLMEngineImpl;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.CipherGen
	 */
	export interface NTLMEngineImpl$CipherGen extends Java.Object {
		/**
		 Calculate and return client challenge
		 */
		getClientChallenge(): array<byte>;
		/**
		 Calculate and return second client challenge
		 */
		getClientChallenge2(): array<byte>;
		/**
		 Calculate and return LM2 session response
		 */
		getLM2SessionResponse(): array<byte>;
		/**
		 Calculate and return the LMHash
		 */
		getLMHash(): array<byte>;
		/**
		 Calculate and return the LMResponse
		 */
		getLMResponse(): array<byte>;
		/**
		 Get LMUserSessionKey
		 */
		getLMUserSessionKey(): array<byte>;
		/**
		 Calculate the LMv2 hash
		 */
		getLMv2Hash(): array<byte>;
		/**
		 Calculate the LMv2Response
		 */
		getLMv2Response(): array<byte>;
		/**
		 Get LAN Manager session key
		 */
		getLanManagerSessionKey(): array<byte>;
		/**
		 Get NTLM2SessionResponse
		 */
		getNTLM2SessionResponse(): array<byte>;
		/**
		 Get NTLM2SessionResponseUserSessionKey
		 */
		getNTLM2SessionResponseUserSessionKey(): array<byte>;
		/**
		 Calculate and return the NTLMHash
		 */
		getNTLMHash(): array<byte>;
		/**
		 Calculate and return the NTLMResponse
		 */
		getNTLMResponse(): array<byte>;
		/**
		 Get NTLMUserSessionKey
		 */
		getNTLMUserSessionKey(): array<byte>;
		/**
		 Calculate the NTLMv2Blob
		 */
		getNTLMv2Blob(): array<byte>;
		/**
		 Calculate the NTLMv2 hash
		 */
		getNTLMv2Hash(): array<byte>;
		/**
		 Calculate the NTLMv2Response
		 */
		getNTLMv2Response(): array<byte>;
		/**
		 GetNTLMv2UserSessionKey
		 */
		getNTLMv2UserSessionKey(): array<byte>;
		/**
		 Calculate and return random secondary key
		 */
		getSecondaryKey(): array<byte>;
		/**
		 Calculate a timestamp
		 */
		getTimestamp(): array<byte>;
	}
	export module NTLMEngineImpl$CipherGen {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.CipherGen
		 */
		export interface Static extends Java.Object.Static {
			new(random: Java.Random, currentTime: long, domain: string, user: string, password: string, challenge: array<byte>, target: string, targetInformation: array<byte>, clientChallenge: array<byte>, clientChallenge2: array<byte>, secondaryKey: array<byte>, timestamp: array<byte>): Http.NTLMEngineImpl$CipherGen;
			new(random: Java.Random, currentTime: long, domain: string, user: string, password: string, challenge: array<byte>, target: string, targetInformation: array<byte>): Http.NTLMEngineImpl$CipherGen;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Handle
	 */
	export interface NTLMEngineImpl$Handle extends Java.Object {
		decryptAndVerifySignedMessage(inMessage: array<byte>): array<byte>;
		getSealingKey(): array<byte>;
		getSigningKey(): array<byte>;
		signAndEncryptMessage(cleartextMessage: array<byte>): array<byte>;
	}
	export module NTLMEngineImpl$Handle {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Handle
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.NTLMEngineImpl$Handle;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.NTLMMessage
	 NTLM message generation, base class
	 */
	export interface NTLMEngineImpl$NTLMMessage extends Java.Object {
		getBytes(): array<byte>;
		/**
		 * Returns the response that has been generated after shrinking the
		 * array if required and base64 encodes the response.
		 *
		 * @return The response as above.
		 */
		getResponse(): string;
	}
	export module NTLMEngineImpl$NTLMMessage {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.NTLMMessage
		 NTLM message generation, base class
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.NTLMEngineImpl$NTLMMessage;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Type1Message
	 Type 1 message assembly class
	 */
	export interface NTLMEngineImpl$Type1Message extends Http.NTLMEngineImpl$NTLMMessage {
	}
	export module NTLMEngineImpl$Type1Message {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Type1Message
		 Type 1 message assembly class
		 */
		export interface Static extends Http.NTLMEngineImpl$NTLMMessage.Static {
			new(): Http.NTLMEngineImpl$Type1Message;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Type2Message
	 Type 2 message class
	 */
	export interface NTLMEngineImpl$Type2Message extends Http.NTLMEngineImpl$NTLMMessage {
	}
	export module NTLMEngineImpl$Type2Message {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Type2Message
		 Type 2 message class
		 */
		export interface Static extends Http.NTLMEngineImpl$NTLMMessage.Static {
			new(): Http.NTLMEngineImpl$Type2Message;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Type3Message
	 Type 3 message assembly class
	 */
	export interface NTLMEngineImpl$Type3Message extends Http.NTLMEngineImpl$NTLMMessage {
		getEncryptedRandomSessionKey(): array<byte>;
		getExportedSessionKey(): array<byte>;
	}
	export module NTLMEngineImpl$Type3Message {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Type3Message
		 Type 3 message assembly class
		 */
		export interface Static extends Http.NTLMEngineImpl$NTLMMessage.Static {
			new(): Http.NTLMEngineImpl$Type3Message;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.MD4
	 * Cryptography support - MD4. The following class was based loosely on the
	 * RFC and on code found at http://www.cs.umd.edu/~harry/jotp/src/md.java.
	 * Code correctness was verified by looking at MD4.java from the jcifs
	 * library (http://jcifs.samba.org). It was massaged extensively to the
	 * final form found here by Karl Wright (kwright@metacarta.com).
	 */
	export interface NTLMEngineImpl$MD4 extends Java.Object {
	}
	export module NTLMEngineImpl$MD4 {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.MD4
		 * Cryptography support - MD4. The following class was based loosely on the
		 * RFC and on code found at http://www.cs.umd.edu/~harry/jotp/src/md.java.
		 * Code correctness was verified by looking at MD4.java from the jcifs
		 * library (http://jcifs.samba.org). It was massaged extensively to the
		 * final form found here by Karl Wright (kwright@metacarta.com).
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.NTLMEngineImpl$MD4;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.HMACMD5
	 * Cryptography support - HMACMD5 - algorithmically based on various web
	 * resources by Karl Wright
	 */
	export interface NTLMEngineImpl$HMACMD5 extends Java.Object {
	}
	export module NTLMEngineImpl$HMACMD5 {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.HMACMD5
		 * Cryptography support - HMACMD5 - algorithmically based on various web
		 * resources by Karl Wright
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.NTLMEngineImpl$HMACMD5;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Mode
	 */
	export interface NTLMEngineImpl$Mode extends Java.Enum<NTLMEngineImpl$Mode> {
	}
	export module NTLMEngineImpl$Mode {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineImpl.Mode
		 */
		export interface Static extends Java.Enum.Static {
			CLIENT?: Http.NTLMEngineImpl$Mode;
			SERVER?: Http.NTLMEngineImpl$Mode;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NegotiateSchemeFactory
	 * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
	 * scheme factory.
	 *
	 * @since 4.1
	 *
	 * @deprecated (4.2)  use {@link SPNegoSchemeFactory} or {@link KerberosSchemeFactory}.
	 */
	export interface NegotiateSchemeFactory extends Java.Object, Http.AuthSchemeFactory {
	}
	export module NegotiateSchemeFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NegotiateSchemeFactory
		 * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
		 * scheme factory.
		 *
		 * @since 4.1
		 *
		 * @deprecated (4.2)  use {@link SPNegoSchemeFactory} or {@link KerberosSchemeFactory}.
		 */
		export interface Static extends Java.Object.Static, Http.AuthSchemeFactory.Static {
			new(): Http.NegotiateSchemeFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.SpnegoTokenGenerator
	 * Abstract SPNEGO token generator. Implementations should take an Kerberos ticket and transform
	 * into a SPNEGO token.
	 * 
	 * Implementations of this interface are expected to be thread-safe.
	 *
	 * @since 4.1
	 *
	 * @deprecated (4.2)  subclass {@link KerberosScheme} and override
	 *   {@link KerberosScheme#generateGSSToken(byte[], org.ietf.jgss.Oid, String, org.apache.http.auth.Credentials)}
	 */
	export interface SpnegoTokenGenerator extends Java.Object {
	}
	export module SpnegoTokenGenerator {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.SpnegoTokenGenerator
		 * Abstract SPNEGO token generator. Implementations should take an Kerberos ticket and transform
		 * into a SPNEGO token.
		 * 
		 * Implementations of this interface are expected to be thread-safe.
		 *
		 * @since 4.1
		 *
		 * @deprecated (4.2)  subclass {@link KerberosScheme} and override
		 *   {@link KerberosScheme#generateGSSToken(byte[], org.ietf.jgss.Oid, String, org.apache.http.auth.Credentials)}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.HttpAuthenticator
	 * @since 4.3
	 */
	export interface HttpAuthenticator extends Java.Object {
		generateAuthResponse(request: Http.HttpRequest, authState: Http.AuthState, context: Http.HttpContext): void;
		handleAuthChallenge(host: Http.HttpHost, response: Http.HttpResponse, authStrategy: Http.AuthenticationStrategy, authState: Http.AuthState, context: Http.HttpContext): boolean;
		isAuthenticationRequested(host: Http.HttpHost, response: Http.HttpResponse, authStrategy: Http.AuthenticationStrategy, authState: Http.AuthState, context: Http.HttpContext): boolean;
	}
	export module HttpAuthenticator {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.HttpAuthenticator
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			new(log: Commons.Logging.Log): Http.HttpAuthenticator;
			new(): Http.HttpAuthenticator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.SPNegoSchemeFactory
	 * {@link AuthSchemeProvider} implementation that creates and initializes
	 * {@link SPNegoScheme} instances.
	 *
	 * @since 4.2
	 */
	export interface SPNegoSchemeFactory extends Java.Object, Http.AuthSchemeFactory, Http.AuthSchemeProvider {
		create(context: Http.HttpContext): Http.AuthScheme;
		isStripPort(): boolean;
		isUseCanonicalHostname(): boolean;
		newInstance(params: Http.HttpParams): Http.AuthScheme;
	}
	export module SPNegoSchemeFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.SPNegoSchemeFactory
		 * {@link AuthSchemeProvider} implementation that creates and initializes
		 * {@link SPNegoScheme} instances.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.AuthSchemeFactory.Static, Http.AuthSchemeProvider.Static {
			/**
			 * @since 4.4
			 */
			new(stripPort: boolean, useCanonicalHostname: boolean): Http.SPNegoSchemeFactory;
			new(stripPort: boolean): Http.SPNegoSchemeFactory;
			new(): Http.SPNegoSchemeFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.RFC2617Scheme
	 * Abstract authentication scheme class that lays foundation for all
	 * RFC 2617 compliant authentication schemes and provides capabilities common
	 * to all authentication schemes defined in RFC 2617.
	 *
	 * @since 4.0
	 */
	export interface RFC2617Scheme extends Http.AuthSchemeBase, Java.Serializable {
		/**
		 * @since 4.3
		 */
		getCredentialsCharset(): Java.Charset;
		/**
		 * Returns authentication parameter with the given name, if available.
		 *
		 * @param name The name of the parameter to be returned
		 *
		 * @return the parameter with the given name
		 */
		getParameter(name: string): string;
		/**
		 * Returns authentication realm. The realm may not be null.
		 *
		 * @return the authentication realm
		 */
		getRealm(): string;
	}
	export module RFC2617Scheme {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.RFC2617Scheme
		 * Abstract authentication scheme class that lays foundation for all
		 * RFC 2617 compliant authentication schemes and provides capabilities common
		 * to all authentication schemes defined in RFC 2617.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AuthSchemeBase.Static, Java.Serializable.Static {
			/**
			 * @since 4.3
			 */
			new(credentialsCharset: Java.Charset): Http.RFC2617Scheme;
			new(): Http.RFC2617Scheme;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.AutoRetryHttpClient
	 * {@link HttpClient} implementation that can automatically retry the request in case of
	 * a non-2xx response using the {@link ServiceUnavailableRetryStrategy} interface.
	 *
	 * @since 4.2
	 *
	 * @deprecated (4.3) use {@link HttpClientBuilder}.
	 */
	export interface AutoRetryHttpClient extends Java.Object, Http.HttpClient {
	}
	export module AutoRetryHttpClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.AutoRetryHttpClient
		 * {@link HttpClient} implementation that can automatically retry the request in case of
		 * a non-2xx response using the {@link ServiceUnavailableRetryStrategy} interface.
		 *
		 * @since 4.2
		 *
		 * @deprecated (4.3) use {@link HttpClientBuilder}.
		 */
		export interface Static extends Java.Object.Static, Http.HttpClient.Static {
			new(): Http.AutoRetryHttpClient;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.ContentEncodingHttpClient
	 * {@link DefaultHttpClient} sub-class which includes a {@link RequestAcceptEncoding}
	 * for the request and response.
	 *
	 * Deprecation note: due to the way this class modifies a response body
	 * without changing the response headers to reflect the entity changes, it cannot
	 * be used as the &quot;backend&quot; for a caching {@link
	 * org.apache.http.client.HttpClient} and still have uncompressed responses be cached.
	 * Users are encouraged to use the {@link DecompressingHttpClient} instead
	 * of this class, which can be wired in either before or after caching, depending on
	 * whether you want to cache responses in compressed or uncompressed form.
	 *
	 * @since 4.1
	 *
	 * @deprecated (4.2) use {@link HttpClientBuilder}
	 */
	export interface ContentEncodingHttpClient extends Http.DefaultHttpClient {
	}
	export module ContentEncodingHttpClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.ContentEncodingHttpClient
		 * {@link DefaultHttpClient} sub-class which includes a {@link RequestAcceptEncoding}
		 * for the request and response.
		 *
		 * Deprecation note: due to the way this class modifies a response body
		 * without changing the response headers to reflect the entity changes, it cannot
		 * be used as the &quot;backend&quot; for a caching {@link
		 * org.apache.http.client.HttpClient} and still have uncompressed responses be cached.
		 * Users are encouraged to use the {@link DecompressingHttpClient} instead
		 * of this class, which can be wired in either before or after caching, depending on
		 * whether you want to cache responses in compressed or uncompressed form.
		 *
		 * @since 4.1
		 *
		 * @deprecated (4.2) use {@link HttpClientBuilder}
		 */
		export interface Static extends Http.DefaultHttpClient.Static {
			new(): Http.ContentEncodingHttpClient;
		}
	}

    /**
	 * Corresponding Java class: org.apache.http.impl.client.RedirectLocations
	 * This class represents a collection of {@link java.net.URI}s used
	 * as redirect locations.
	 *
	 * @since 4.0
	 */
    export interface RedirectLocations extends Java.AbstractList<obj> {
        /**
         * Adds a new URI to the collection.
         */
        add(uri: Java.URI): void;
        /**
         * Inserts the specified element at the specified position in this list
         * (must be a URI). Shifts the URI currently at that position (if any) and
         * any subsequent URIs to the right (adds one to their indices).
         *
         * @param index
         *            index at which the specified element is to be inserted
         * @param element
         *            URI to be inserted
         * @throws UnsupportedOperationException
         *             if the {@code add} operation is not supported by this list
         * @throws ClassCastException
         *             if the element is not a {@link URI}
         * @throws NullPointerException
         *             if the specified element is null and this list does not
         *             permit null elements
         * @throws IndexOutOfBoundsException
         *             if the index is out of range (
         *             {@code index &lt; 0 || index &gt; size()})
         * @since 4.3
         */
        add(index: int, element: obj): void;
        /**
         * Appends the specified element to the end of this list (optional
         * operation).
         *
         * Lists that support this operation may place limitations on what
         * elements may be added to this list.  In particular, some
         * lists will refuse to add null elements, and others will impose
         * restrictions on the type of elements that may be added.  List
         * classes should clearly specify in their documentation any restrictions
         * on what elements may be added.
         *
         * This implementation calls {@code add(size(), e)}.
         *
         * Note that this implementation throws an
         * {@code UnsupportedOperationException} unless
         * {@link #add(int, Object) add(int, E)} is overridden.
         *
         * @param e element to be appended to this list
         * @return {@code true} (as specified by {@link Collection#add})
         * @throws UnsupportedOperationException if the {@code add} operation
         *         is not supported by this list
         * @throws ClassCastException if the class of the specified element
         *         prevents it from being added to this list
         * @throws NullPointerException if the specified element is null and this
         *         list does not permit null elements
         * @throws IllegalArgumentException if some property of this element
         *         prevents it from being added to this list
         */
        add(e: obj): boolean;
        /**
         * {@inheritDoc}
         *
         * This implementation always throws an
         * {@code UnsupportedOperationException}.
         *
         * @throws UnsupportedOperationException {@inheritDoc}
         * @throws ClassCastException            {@inheritDoc}
         * @throws NullPointerException          {@inheritDoc}
         * @throws IllegalArgumentException      {@inheritDoc}
         * @throws IndexOutOfBoundsException     {@inheritDoc}
         */
        add(index: int, element: obj): void;
        /**
         * Test if the URI is present in the collection.
         */
        contains(uri: Java.URI): boolean;
        /**
         * Returns {@code true} if this collection contains the specified element.
         * More formally, returns {@code true} if and only if this collection
         * contains at least one element {@code e} such that
         * {@code (o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))}.
         *
         * @param o element whose presence in this collection is to be tested
         * @return {@code true} if this collection contains the specified
         *         element
         */
        contains(o: obj): boolean;
        /**
         * Returns the URI at the specified position in this list.
         *
         * @param index
         *            index of the location to return
         * @return the URI at the specified position in this list
         * @throws IndexOutOfBoundsException
         *             if the index is out of range (
         *             {@code index &lt; 0 || index &gt;= size()})
         * @since 4.3
         */
        get(index: int): Java.URI;
        /**
         * Returns all redirect {@link URI}s in the order they were added to the collection.
         *
         * @return list of all URIs
         *
         * @since 4.1
         */
        getAll(): Java.List<Java.URI>;
        /**
         * Removes a URI from the collection.
         */
        remove(uri: Java.URI): boolean;
        /**
         * Removes the URI at the specified position in this list. Shifts any
         * subsequent URIs to the left (subtracts one from their indices). Returns
         * the URI that was removed from the list.
         *
         * @param index
         *            the index of the URI to be removed
         * @return the URI previously at the specified position
         * @throws IndexOutOfBoundsException
         *             if the index is out of range (
         *             {@code index &lt; 0 || index &gt;= size()})
         * @since 4.3
         */
        remove(index: int): Java.URI;
        /**
         * Replaces the URI at the specified position in this list with the
         * specified element (must be a URI).
         *
         * @param index
         *            index of the element to replace
         * @param element
         *            URI to be stored at the specified position
         * @return the URI previously at the specified position
         * @throws UnsupportedOperationException
         *             if the {@code set} operation is not supported by this list
         * @throws ClassCastException
         *             if the element is not a {@link URI}
         * @throws NullPointerException
         *             if the specified element is null and this list does not
         *             permit null elements
         * @throws IndexOutOfBoundsException
         *             if the index is out of range (
         *             {@code index &lt; 0 || index &gt;= size()})
         * @since 4.3
         */
        set(index: int, element: obj): obj;
        /**
         * Returns the number of elements in this list. If this list contains more
         * than {@code Integer.MAX_VALUE} elements, returns
         * {@code Integer.MAX_VALUE}.
         *
         * @return the number of elements in this list
         * @since 4.3
         */
        size(): int;
    }
    export module RedirectLocations {
        /**
         * Corresponding Java class: org.apache.http.impl.client.RedirectLocations
         * This class represents a collection of {@link java.net.URI}s used
         * as redirect locations.
         *
         * @since 4.0
         */
        export interface Static extends Java.AbstractList.Static {
            new(): Http.RedirectLocations;
        }
    }

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultHttpRequestRetryHandler
	 * The default {@link HttpRequestRetryHandler} used by request executors.
	 *
	 * @since 4.0
	 */
	export interface DefaultHttpRequestRetryHandler extends Java.Object, Http.HttpRequestRetryHandler {
		/**
		 * @return the maximum number of times a method will be retried
		 */
		getRetryCount(): int;
		/**
		 * @return {@code true} if this handler will retry methods that have
		 * successfully sent their request, {@code false} otherwise
		 */
		isRequestSentRetryEnabled(): boolean;
		/**
		 * Used {@code retryCount} and {@code requestSentRetryEnabled} to determine
		 * if the given method should be retried.
		 */
		retryRequest(exception: Java.IOException, executionCount: int, context: Http.HttpContext): boolean;
	}
	export module DefaultHttpRequestRetryHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultHttpRequestRetryHandler
		 * The default {@link HttpRequestRetryHandler} used by request executors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestRetryHandler.Static {
			/**
			 * Create the request retry handler using the following list of
			 * non-retriable IOException classes: 
			 * 
			 * InterruptedIOException
			 * UnknownHostException
			 * ConnectException
			 * SSLException
			 * 
			 * @param retryCount how many times to retry; 0 means no retries
			 * @param requestSentRetryEnabled true if it's OK to retry non-idempotent requests that have been sent
			 */
			new(retryCount: int, requestSentRetryEnabled: boolean): Http.DefaultHttpRequestRetryHandler;
			/**
			 * Create the request retry handler with a retry count of 3, requestSentRetryEnabled false
			 * and using the following list of non-retriable IOException classes: 
			 * 
			 * InterruptedIOException
			 * UnknownHostException
			 * ConnectException
			 * SSLException
			 * 
			 */
			new(): Http.DefaultHttpRequestRetryHandler;
			INSTANCE?: Http.DefaultHttpRequestRetryHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.StandardHttpRequestRetryHandler
	 * {@link org.apache.http.client.HttpRequestRetryHandler} which assumes
	 * that all requested HTTP methods which should be idempotent according
	 * to RFC-2616 are in fact idempotent and can be retried.
	 * 
	 * According to RFC-2616 section 9.1.2 the idempotent HTTP methods are:
	 * GET, HEAD, PUT, DELETE, OPTIONS, and TRACE
	 * 
	 *
	 * @since 4.2
	 */
	export interface StandardHttpRequestRetryHandler extends Http.DefaultHttpRequestRetryHandler {
	}
	export module StandardHttpRequestRetryHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.StandardHttpRequestRetryHandler
		 * {@link org.apache.http.client.HttpRequestRetryHandler} which assumes
		 * that all requested HTTP methods which should be idempotent according
		 * to RFC-2616 are in fact idempotent and can be retried.
		 * 
		 * According to RFC-2616 section 9.1.2 the idempotent HTTP methods are:
		 * GET, HEAD, PUT, DELETE, OPTIONS, and TRACE
		 * 
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.DefaultHttpRequestRetryHandler.Static {
			/**
			 * Default constructor
			 */
			new(retryCount: int, requestSentRetryEnabled: boolean): Http.StandardHttpRequestRetryHandler;
			/**
			 * Default constructor
			 */
			new(): Http.StandardHttpRequestRetryHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.AbstractAuthenticationHandler
	 * Base class for {@link AuthenticationHandler} implementations.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link org.apache.http.client.AuthenticationStrategy}
	 */
	export interface AbstractAuthenticationHandler extends Java.Object, Http.AuthenticationHandler {
	}
	export module AbstractAuthenticationHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.AbstractAuthenticationHandler
		 * Base class for {@link AuthenticationHandler} implementations.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link org.apache.http.client.AuthenticationStrategy}
		 */
		export interface Static extends Java.Object.Static, Http.AuthenticationHandler.Static {
			new(): Http.AbstractAuthenticationHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.SystemClock
	 * The actual system clock.
	 *
	 * @since 4.2
	 */
	export interface SystemClock extends Java.Object, Http.Clock {
		getCurrentTime(): long;
	}
	export module SystemClock {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.SystemClock
		 * The actual system clock.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.Clock.Static {
			new(): Http.SystemClock;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.Clock
	 * Interface used to enable easier testing of time-related behavior.
	 *
	 * @since 4.2
	 *
	 */
	export interface Clock extends Java.Object {
		/**
		 * Returns the current time, expressed as the number of
		 * milliseconds since the epoch.
		 * @return current time
		 */
		getCurrentTime(): long;
	}
	export module Clock {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.Clock
		 * Interface used to enable easier testing of time-related behavior.
		 *
		 * @since 4.2
		 *
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultConnectionKeepAliveStrategy
	 * Default implementation of a strategy deciding duration
	 * that a connection can remain idle.
	 *
	 * The default implementation looks solely at the 'Keep-Alive'
	 * header's timeout token.
	 *
	 * @since 4.0
	 */
	export interface DefaultConnectionKeepAliveStrategy extends Java.Object, Http.ConnectionKeepAliveStrategy {
		getKeepAliveDuration(response: Http.HttpResponse, context: Http.HttpContext): long;
	}
	export module DefaultConnectionKeepAliveStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultConnectionKeepAliveStrategy
		 * Default implementation of a strategy deciding duration
		 * that a connection can remain idle.
		 *
		 * The default implementation looks solely at the 'Keep-Alive'
		 * header's timeout token.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionKeepAliveStrategy.Static {
			new(): Http.DefaultConnectionKeepAliveStrategy;
			INSTANCE?: Http.DefaultConnectionKeepAliveStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.AuthenticationStrategyAdaptor
	 * @deprecated (4.2) do not use
	 */
	export interface AuthenticationStrategyAdaptor extends Java.Object, Http.AuthenticationStrategy {
	}
	export module AuthenticationStrategyAdaptor {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.AuthenticationStrategyAdaptor
		 * @deprecated (4.2) do not use
		 */
		export interface Static extends Java.Object.Static, Http.AuthenticationStrategy.Static {
			new(): Http.AuthenticationStrategyAdaptor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.IdleConnectionEvictor
	 * This class maintains a background thread to enforce an eviction policy for expired / idle
	 * persistent connections kept alive in the connection pool.
	 *
	 * @since 4.4
	 */
	export interface IdleConnectionEvictor extends Java.Object {
		awaitTermination(time: long, tunit: Java.TimeUnit): void;
		isRunning(): boolean;
		shutdown(): void;
		start(): void;
	}
	export module IdleConnectionEvictor {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.IdleConnectionEvictor
		 * This class maintains a background thread to enforce an eviction policy for expired / idle
		 * persistent connections kept alive in the connection pool.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			DefaultThreadFactory: IdleConnectionEvictor$DefaultThreadFactory.Static;
			new(connectionManager: Http.HttpClientConnectionManager, threadFactory: Java.ThreadFactory, sleepTime: long, sleepTimeUnit: Java.TimeUnit, maxIdleTime: long, maxIdleTimeUnit: Java.TimeUnit): Http.IdleConnectionEvictor;
			new(connectionManager: Http.HttpClientConnectionManager, sleepTime: long, sleepTimeUnit: Java.TimeUnit, maxIdleTime: long, maxIdleTimeUnit: Java.TimeUnit): Http.IdleConnectionEvictor;
			new(connectionManager: Http.HttpClientConnectionManager, maxIdleTime: long, maxIdleTimeUnit: Java.TimeUnit): Http.IdleConnectionEvictor;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.client.IdleConnectionEvictor.DefaultThreadFactory
	 */
	export interface IdleConnectionEvictor$DefaultThreadFactory extends Java.Object, Java.ThreadFactory {
		newThread(r: Java.Runnable): Java.Thread;
	}
	export module IdleConnectionEvictor$DefaultThreadFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.IdleConnectionEvictor.DefaultThreadFactory
		 */
		export interface Static extends Java.Object.Static, Java.ThreadFactory.Static {
			new(): Http.IdleConnectionEvictor$DefaultThreadFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.SystemDefaultCredentialsProvider
	 * Implementation of {@link CredentialsProvider} backed by standard
	 * JRE {@link Authenticator}.
	 *
	 * @since 4.3
	 */
	export interface SystemDefaultCredentialsProvider extends Java.Object, Http.CredentialsProvider {
		clear(): void;
		getCredentials(authscope: Http.AuthScope): Http.Credentials;
		setCredentials(authscope: Http.AuthScope, credentials: Http.Credentials): void;
	}
	export module SystemDefaultCredentialsProvider {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.SystemDefaultCredentialsProvider
		 * Implementation of {@link CredentialsProvider} backed by standard
		 * JRE {@link Authenticator}.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.CredentialsProvider.Static {
			/**
			 * Default constructor.
			 */
			new(): Http.SystemDefaultCredentialsProvider;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.FutureRequestExecutionMetrics
	 * Collection of different counters used to gather metrics for {@link FutureRequestExecutionService}.
	 */
	export interface FutureRequestExecutionMetrics extends Java.Object {
		getActiveConnectionCount(): long;
		getFailedConnectionAverageDuration(): long;
		getFailedConnectionCount(): long;
		getRequestAverageDuration(): long;
		getRequestCount(): long;
		getScheduledConnectionCount(): long;
		getSuccessfulConnectionAverageDuration(): long;
		getSuccessfulConnectionCount(): long;
		getTaskAverageDuration(): long;
		getTaskCount(): long;
		toString(): string;
	}
	export module FutureRequestExecutionMetrics {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.FutureRequestExecutionMetrics
		 * Collection of different counters used to gather metrics for {@link FutureRequestExecutionService}.
		 */
		export interface Static extends Java.Object.Static {
			DurationCounter: FutureRequestExecutionMetrics$DurationCounter.Static;
			new(): Http.FutureRequestExecutionMetrics;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.client.FutureRequestExecutionMetrics.DurationCounter
	 * A counter that can measure duration and number of events.
	 */
	export interface FutureRequestExecutionMetrics$DurationCounter extends Java.Object {
		averageDuration(): long;
		count(): long;
		increment(startTime: long): void;
		toString(): string;
	}
	export module FutureRequestExecutionMetrics$DurationCounter {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.FutureRequestExecutionMetrics.DurationCounter
		 * A counter that can measure duration and number of events.
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.FutureRequestExecutionMetrics$DurationCounter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.NullBackoffStrategy
	 * This is a {@link ConnectionBackoffStrategy} that never backs off,
	 * for compatibility with existing behavior.
	 *
	 * @since 4.2
	 */
	export interface NullBackoffStrategy extends Java.Object, Http.ConnectionBackoffStrategy {
		shouldBackoff(t: Java.Throwable): boolean;
		shouldBackoff(resp: Http.HttpResponse): boolean;
	}
	export module NullBackoffStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.NullBackoffStrategy
		 * This is a {@link ConnectionBackoffStrategy} that never backs off,
		 * for compatibility with existing behavior.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionBackoffStrategy.Static {
			new(): Http.NullBackoffStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultBackoffStrategy
	 * This {@link ConnectionBackoffStrategy} backs off either for a raw
	 * network socket or connection timeout or if the server explicitly
	 * sends a 503 (Service Unavailable) response.
	 *
	 * @since 4.2
	 */
	export interface DefaultBackoffStrategy extends Java.Object, Http.ConnectionBackoffStrategy {
		shouldBackoff(t: Java.Throwable): boolean;
		shouldBackoff(resp: Http.HttpResponse): boolean;
	}
	export module DefaultBackoffStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultBackoffStrategy
		 * This {@link ConnectionBackoffStrategy} backs off either for a raw
		 * network socket or connection timeout or if the server explicitly
		 * sends a 503 (Service Unavailable) response.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionBackoffStrategy.Static {
			new(): Http.DefaultBackoffStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.BasicCookieStore
	 * Default implementation of {@link CookieStore}
	 *
	 *
	 * @since 4.0
	 */
	export interface BasicCookieStore extends Java.Object, Http.CookieStore, Java.Serializable {
		/**
		 * Adds an {@link Cookie HTTP cookie}, replacing any existing equivalent cookies.
		 * If the given cookie has already expired it will not be added, but existing
		 * values will still be removed.
		 *
		 * @param cookie the {@link Cookie cookie} to be added
		 *
		 * @see #addCookies(Cookie[])
		 *
		 */
		addCookie(cookie: Http.Cookie): void;
		/**
		 * Adds an array of {@link Cookie HTTP cookies}. Cookies are added individually and
		 * in the given array order. If any of the given cookies has already expired it will
		 * not be added, but existing values will still be removed.
		 *
		 * @param cookies the {@link Cookie cookies} to be added
		 *
		 * @see #addCookie(Cookie)
		 *
		 */
		addCookies(cookies: array<Http.Cookie>): void;
		/**
		 * Clears all cookies.
		 */
		clear(): void;
		/**
		 * Removes all of {@link Cookie cookies} in this HTTP state
		 * that have expired by the specified {@link java.util.Date date}.
		 *
		 * @return true if any cookies were purged.
		 *
		 * @see Cookie#isExpired(Date)
		 */
		clearExpired(date: Java.Date): boolean;
		/**
		 * Returns an immutable array of {@link Cookie cookies} that this HTTP
		 * state currently contains.
		 *
		 * @return an array of {@link Cookie cookies}.
		 */
		getCookies(): Java.List<Http.Cookie>;
		toString(): string;
	}
	export module BasicCookieStore {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.BasicCookieStore
		 * Default implementation of {@link CookieStore}
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CookieStore.Static, Java.Serializable.Static {
			new(): Http.BasicCookieStore;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultClientConnectionReuseStrategy
	 */
	export interface DefaultClientConnectionReuseStrategy extends Http.DefaultConnectionReuseStrategy {
		keepAlive(response: Http.HttpResponse, context: Http.HttpContext): boolean;
	}
	export module DefaultClientConnectionReuseStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultClientConnectionReuseStrategy
		 */
		export interface Static extends Http.DefaultConnectionReuseStrategy.Static {
			new(): Http.DefaultClientConnectionReuseStrategy;
			INSTANCE?: Http.DefaultClientConnectionReuseStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultRedirectHandler
	 * Default implementation of {@link RedirectHandler}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1)  use {@link DefaultRedirectStrategy}.
	 */
	export interface DefaultRedirectHandler extends Java.Object, Http.RedirectHandler {
	}
	export module DefaultRedirectHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultRedirectHandler
		 * Default implementation of {@link RedirectHandler}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1)  use {@link DefaultRedirectStrategy}.
		 */
		export interface Static extends Java.Object.Static, Http.RedirectHandler.Static {
			new(): Http.DefaultRedirectHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.TunnelRefusedException
	 * Signals that the tunnel request was rejected by the proxy host.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) reserved for internal use.
	 */
	export interface ClientTunnelRefusedException extends Http.HttpException {
	}
	export module ClientTunnelRefusedException {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.TunnelRefusedException
		 * Signals that the tunnel request was rejected by the proxy host.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) reserved for internal use.
		 */
		export interface Static extends Http.HttpException.Static {
			new(): Http.ClientTunnelRefusedException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.MinimalHttpClient
	 * Internal class.
	 *
	 * @since 4.3
	 */
	export interface MinimalHttpClient extends Http.CloseableHttpClient {
		close(): void;
		getConnectionManager(): Http.ClientConnectionManager;
		getParams(): Http.HttpParams;
	}
	export module MinimalHttpClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.MinimalHttpClient
		 * Internal class.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.CloseableHttpClient.Static {
			new(connManager: Http.HttpClientConnectionManager): Http.MinimalHttpClient;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.BasicResponseHandler
	 * A {@link org.apache.http.client.ResponseHandler} that returns the response body as a String
	 * for successful (2xx) responses. If the response code was &gt;= 300, the response
	 * body is consumed and an {@link org.apache.http.client.HttpResponseException} is thrown.
	 * 
	 * If this is used with
	 * {@link org.apache.http.client.HttpClient#execute(
	 *  org.apache.http.client.methods.HttpUriRequest, org.apache.http.client.ResponseHandler)},
	 * HttpClient may handle redirects (3xx responses) internally.
	 * 
	 *
	 * @since 4.0
	 */
	export interface BasicResponseHandler extends Http.AbstractResponseHandler<string> {
		/**
		 * Returns the entity as a body as a String.
		 */
		handleEntity(entity: Http.HttpEntity): string;
		handleResponse(response: Http.HttpResponse): string;
	}
	export module BasicResponseHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.BasicResponseHandler
		 * A {@link org.apache.http.client.ResponseHandler} that returns the response body as a String
		 * for successful (2xx) responses. If the response code was &gt;= 300, the response
		 * body is consumed and an {@link org.apache.http.client.HttpResponseException} is thrown.
		 * 
		 * If this is used with
		 * {@link org.apache.http.client.HttpClient#execute(
		 *  org.apache.http.client.methods.HttpUriRequest, org.apache.http.client.ResponseHandler)},
		 * HttpClient may handle redirects (3xx responses) internally.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractResponseHandler.Static {
			new(): Http.BasicResponseHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.ClientParamsStack
	 * Represents a stack of parameter collections.
	 * When retrieving a parameter, the stack is searched in a fixed order
	 * and the first match returned. Setting parameters via the stack is
	 * not supported. To minimize overhead, the stack has a fixed size and
	 * does not maintain an internal array.
	 * The supported stack entries, sorted by increasing priority, are:
	 * 
	 * Application parameters:
	 *     expected to be the same for all clients used by an application.
	 *     These provide "global", that is application-wide, defaults.
	 *     
	 * Client parameters:
	 *     specific to an instance of
	 *     {@link org.apache.http.client.HttpClient HttpClient}.
	 *     These provide client specific defaults.
	 *     
	 * Request parameters:
	 *     specific to a single request execution.
	 *     For overriding client and global defaults.
	 *     
	 * Override parameters:
	 *     specific to an instance of
	 *     {@link org.apache.http.client.HttpClient HttpClient}.
	 *     These can be used to set parameters that cannot be overridden
	 *     on a per-request basis.
	 *     
	 * 
	 * Each stack entry may be {@code null}. That is preferable over
	 * an empty params collection, since it avoids searching the empty collection
	 * when looking up parameters.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface ClientParamsStack extends Http.AbstractHttpParams {
	}
	export module ClientParamsStack {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.ClientParamsStack
		 * Represents a stack of parameter collections.
		 * When retrieving a parameter, the stack is searched in a fixed order
		 * and the first match returned. Setting parameters via the stack is
		 * not supported. To minimize overhead, the stack has a fixed size and
		 * does not maintain an internal array.
		 * The supported stack entries, sorted by increasing priority, are:
		 * 
		 * Application parameters:
		 *     expected to be the same for all clients used by an application.
		 *     These provide "global", that is application-wide, defaults.
		 *     
		 * Client parameters:
		 *     specific to an instance of
		 *     {@link org.apache.http.client.HttpClient HttpClient}.
		 *     These provide client specific defaults.
		 *     
		 * Request parameters:
		 *     specific to a single request execution.
		 *     For overriding client and global defaults.
		 *     
		 * Override parameters:
		 *     specific to an instance of
		 *     {@link org.apache.http.client.HttpClient HttpClient}.
		 *     These can be used to set parameters that cannot be overridden
		 *     on a per-request basis.
		 *     
		 * 
		 * Each stack entry may be {@code null}. That is preferable over
		 * an empty params collection, since it avoids searching the empty collection
		 * when looking up parameters.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Http.AbstractHttpParams.Static {
			new(): Http.ClientParamsStack;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultTargetAuthenticationHandler
	 * Default {@link org.apache.http.client.AuthenticationHandler} implementation
	 * for target host authentication.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link TargetAuthenticationStrategy}
	 */
	export interface DefaultTargetAuthenticationHandler extends Http.AbstractAuthenticationHandler {
	}
	export module DefaultTargetAuthenticationHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultTargetAuthenticationHandler
		 * Default {@link org.apache.http.client.AuthenticationHandler} implementation
		 * for target host authentication.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link TargetAuthenticationStrategy}
		 */
		export interface Static extends Http.AbstractAuthenticationHandler.Static {
			new(): Http.DefaultTargetAuthenticationHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultHttpClient
	 * Default implementation of {@link org.apache.http.client.HttpClient} pre-configured
	 * for most common use scenarios.
	 * 
	 * Please see the Javadoc for {@link #createHttpProcessor()} for the details of the interceptors
	 * that are set up by default.
	 * 
	 * Additional interceptors can be added as follows, but
	 * take care not to add the same interceptor more than once.
	 * 
	 * DefaultHttpClient httpclient = new DefaultHttpClient();
	 * httpclient.addRequestInterceptor(new RequestAcceptEncoding());
	 * httpclient.addResponseInterceptor(new ResponseContentEncoding());
	 * 
	 * 
	 * This class sets up the following parameters if not explicitly set:
	 * 
	 * Version: HttpVersion.HTTP_1_1
	 * ContentCharset: HTTP.DEFAULT_CONTENT_CHARSET
	 * NoTcpDelay: true
	 * SocketBufferSize: 8192
	 * UserAgent: Apache-HttpClient/release (java 1.5)
	 * 
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.params.CoreProtocolPNames#PROTOCOL_VERSION}
	 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
	 *  {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET}
	 *  {@link org.apache.http.params.CoreProtocolPNames#USE_EXPECT_CONTINUE}
	 *  {@link org.apache.http.params.CoreProtocolPNames#WAIT_FOR_CONTINUE}
	 *  {@link org.apache.http.params.CoreProtocolPNames#USER_AGENT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#TCP_NODELAY}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_TIMEOUT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_LINGER}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_REUSEADDR}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SOCKET_BUFFER_SIZE}
	 *  {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#STALE_CONNECTION_CHECK}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY}
	 *  {@link org.apache.http.cookie.params.CookieSpecPNames#DATE_PATTERNS}
	 *  {@link org.apache.http.cookie.params.CookieSpecPNames#SINGLE_COOKIE_HEADER}
	 *  {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET}
	 *  {@link org.apache.http.client.params.ClientPNames#COOKIE_POLICY}
	 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_AUTHENTICATION}
	 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_REDIRECTS}
	 *  {@link org.apache.http.client.params.ClientPNames#MAX_REDIRECTS}
	 *  {@link org.apache.http.client.params.ClientPNames#ALLOW_CIRCULAR_REDIRECTS}
	 *  {@link org.apache.http.client.params.ClientPNames#VIRTUAL_HOST}
	 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HOST}
	 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HEADERS}
	 *  {@link org.apache.http.client.params.ClientPNames#CONN_MANAGER_TIMEOUT}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link HttpClientBuilder} see also {@link CloseableHttpClient}.
	 */
	export interface DefaultHttpClient extends Http.AbstractHttpClient {
	}
	export module DefaultHttpClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultHttpClient
		 * Default implementation of {@link org.apache.http.client.HttpClient} pre-configured
		 * for most common use scenarios.
		 * 
		 * Please see the Javadoc for {@link #createHttpProcessor()} for the details of the interceptors
		 * that are set up by default.
		 * 
		 * Additional interceptors can be added as follows, but
		 * take care not to add the same interceptor more than once.
		 * 
		 * DefaultHttpClient httpclient = new DefaultHttpClient();
		 * httpclient.addRequestInterceptor(new RequestAcceptEncoding());
		 * httpclient.addResponseInterceptor(new ResponseContentEncoding());
		 * 
		 * 
		 * This class sets up the following parameters if not explicitly set:
		 * 
		 * Version: HttpVersion.HTTP_1_1
		 * ContentCharset: HTTP.DEFAULT_CONTENT_CHARSET
		 * NoTcpDelay: true
		 * SocketBufferSize: 8192
		 * UserAgent: Apache-HttpClient/release (java 1.5)
		 * 
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.params.CoreProtocolPNames#PROTOCOL_VERSION}
		 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
		 *  {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET}
		 *  {@link org.apache.http.params.CoreProtocolPNames#USE_EXPECT_CONTINUE}
		 *  {@link org.apache.http.params.CoreProtocolPNames#WAIT_FOR_CONTINUE}
		 *  {@link org.apache.http.params.CoreProtocolPNames#USER_AGENT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#TCP_NODELAY}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_TIMEOUT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_LINGER}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_REUSEADDR}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SOCKET_BUFFER_SIZE}
		 *  {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#STALE_CONNECTION_CHECK}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY}
		 *  {@link org.apache.http.cookie.params.CookieSpecPNames#DATE_PATTERNS}
		 *  {@link org.apache.http.cookie.params.CookieSpecPNames#SINGLE_COOKIE_HEADER}
		 *  {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET}
		 *  {@link org.apache.http.client.params.ClientPNames#COOKIE_POLICY}
		 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_AUTHENTICATION}
		 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_REDIRECTS}
		 *  {@link org.apache.http.client.params.ClientPNames#MAX_REDIRECTS}
		 *  {@link org.apache.http.client.params.ClientPNames#ALLOW_CIRCULAR_REDIRECTS}
		 *  {@link org.apache.http.client.params.ClientPNames#VIRTUAL_HOST}
		 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HOST}
		 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HEADERS}
		 *  {@link org.apache.http.client.params.ClientPNames#CONN_MANAGER_TIMEOUT}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link HttpClientBuilder} see also {@link CloseableHttpClient}.
		 */
		export interface Static extends Http.AbstractHttpClient.Static {
			new(): Http.DefaultHttpClient;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.RequestWrapper
	 * A wrapper class for {@link HttpRequest}s that can be used to change
	 * properties of the current request without modifying the original
	 * object.
	 * 
	 * This class is also capable of resetting the request headers to
	 * the state of the original request.
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) do not use.
	 */
	export interface RequestWrapper extends Http.AbstractHttpMessage, Http.HttpUriRequest {
	}
	export module RequestWrapper {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.RequestWrapper
		 * A wrapper class for {@link HttpRequest}s that can be used to change
		 * properties of the current request without modifying the original
		 * object.
		 * 
		 * This class is also capable of resetting the request headers to
		 * the state of the original request.
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) do not use.
		 */
		export interface Static extends Http.AbstractHttpMessage.Static, Http.HttpUriRequest.Static {
			new(): Http.RequestWrapper;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.RequestEntityProxy
	 * A Proxy class for {@link org.apache.http.HttpEntity} enclosed in a request message.
	 *
	 * @since 4.3
	 */
	export interface RequestEntityProxy extends Java.Object, Http.HttpEntity {
		getContent(): Java.InputStream;
		getContentEncoding(): Http.Header;
		getContentLength(): long;
		getContentType(): Http.Header;
		getOriginal(): Http.HttpEntity;
		isChunked(): boolean;
		isConsumed(): boolean;
		isRepeatable(): boolean;
		isStreaming(): boolean;
		toString(): string;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module RequestEntityProxy {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.RequestEntityProxy
		 * A Proxy class for {@link org.apache.http.HttpEntity} enclosed in a request message.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpEntity.Static {
			new(): Http.RequestEntityProxy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.ResponseEntityProxy
	 * A wrapper class for {@link HttpEntity} enclosed in a response message.
	 *
	 * @since 4.3
	 */
	export interface ResponseEntityProxy extends Http.HttpEntityWrapper, Http.EofSensorWatcher {
		eofDetected(wrapped: Java.InputStream): boolean;
		getContent(): Java.InputStream;
		isRepeatable(): boolean;
		releaseConnection(): void;
		streamAbort(wrapped: Java.InputStream): boolean;
		streamClosed(wrapped: Java.InputStream): boolean;
		toString(): string;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module ResponseEntityProxy {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.ResponseEntityProxy
		 * A wrapper class for {@link HttpEntity} enclosed in a response message.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.HttpEntityWrapper.Static, Http.EofSensorWatcher.Static {
			new(): Http.ResponseEntityProxy;
			enchance(response: Http.HttpResponse, connHolder: Http.ConnectionHolder): void;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.MainClientExec
	 * The last request executor in the HTTP request execution chain
	 * that is responsible for execution of request / response
	 * exchanges with the opposite endpoint.
	 * This executor will automatically retry the request in case
	 * of an authentication challenge by an intermediate proxy or
	 * by the target server.
	 *
	 * @since 4.3
	 */
	export interface MainClientExec extends Java.Object, Http.ClientExecChain {
		execute(route: Http.HttpRoute, request: Http.HttpRequestWrapper, context: Http.HttpClientContext, execAware: Http.HttpExecutionAware): Http.CloseableHttpResponse;
	}
	export module MainClientExec {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.MainClientExec
		 * The last request executor in the HTTP request execution chain
		 * that is responsible for execution of request / response
		 * exchanges with the opposite endpoint.
		 * This executor will automatically retry the request in case
		 * of an authentication challenge by an intermediate proxy or
		 * by the target server.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ClientExecChain.Static {
			/**
			 * @since 4.4
			 */
			new(requestExecutor: Http.HttpRequestExecutor, connManager: Http.HttpClientConnectionManager, reuseStrategy: Http.ConnectionReuseStrategy, keepAliveStrategy: Http.ConnectionKeepAliveStrategy, proxyHttpProcessor: Http.HttpProcessor, targetAuthStrategy: Http.AuthenticationStrategy, proxyAuthStrategy: Http.AuthenticationStrategy, userTokenHandler: Http.UserTokenHandler): Http.MainClientExec;
			new(requestExecutor: Http.HttpRequestExecutor, connManager: Http.HttpClientConnectionManager, reuseStrategy: Http.ConnectionReuseStrategy, keepAliveStrategy: Http.ConnectionKeepAliveStrategy, targetAuthStrategy: Http.AuthenticationStrategy, proxyAuthStrategy: Http.AuthenticationStrategy, userTokenHandler: Http.UserTokenHandler): Http.MainClientExec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultClientConnection
	 * Default implementation of an operated client connection.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link ManagedHttpClientConnectionFactory}.
	 */
	export interface DefaultClientConnection extends Http.SocketHttpClientConnection, Http.OperatedClientConnection, Http.ManagedHttpClientConnection, Http.HttpContext {
	}
	export module DefaultClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultClientConnection
		 * Default implementation of an operated client connection.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link ManagedHttpClientConnectionFactory}.
		 */
		export interface Static extends Http.SocketHttpClientConnection.Static, Http.OperatedClientConnection.Static, Http.ManagedHttpClientConnection.Static, Http.HttpContext.Static {
			new(): Http.DefaultClientConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultHttpRoutePlanner
	 * Default implementation of an {@link HttpRoutePlanner}. This implementation
	 * is based on {@link org.apache.http.conn.params.ConnRoutePNames parameters}.
	 * It will not make use of any Java system properties, nor of system or
	 * browser proxy settings.
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link DefaultRoutePlanner}
	 */
	export interface DefaultHttpRoutePlanner extends Java.Object, Http.HttpRoutePlanner {
	}
	export module DefaultHttpRoutePlanner {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultHttpRoutePlanner
		 * Default implementation of an {@link HttpRoutePlanner}. This implementation
		 * is based on {@link org.apache.http.conn.params.ConnRoutePNames parameters}.
		 * It will not make use of any Java system properties, nor of system or
		 * browser proxy settings.
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link DefaultRoutePlanner}
		 */
		export interface Static extends Java.Object.Static, Http.HttpRoutePlanner.Static {
			new(): Http.DefaultHttpRoutePlanner;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultHttpClientConnectionOperator
	 * Default implementation of {@link HttpClientConnectionOperator} used as default in Http client,
	 * when no instance provided by user to {@link BasicHttpClientConnectionManager} or {@link
	 * PoolingHttpClientConnectionManager} constructor.
	 *
	 * @since 4.4
	 */
	export interface DefaultHttpClientConnectionOperator extends Java.Object, Http.HttpClientConnectionOperator {
		connect(conn: Http.ManagedHttpClientConnection, host: Http.HttpHost, localAddress: Java.InetSocketAddress, connectTimeout: int, socketConfig: Http.SocketConfig, context: Http.HttpContext): void;
		upgrade(conn: Http.ManagedHttpClientConnection, host: Http.HttpHost, context: Http.HttpContext): void;
	}
	export module DefaultHttpClientConnectionOperator {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultHttpClientConnectionOperator
		 * Default implementation of {@link HttpClientConnectionOperator} used as default in Http client,
		 * when no instance provided by user to {@link BasicHttpClientConnectionManager} or {@link
		 * PoolingHttpClientConnectionManager} constructor.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Http.HttpClientConnectionOperator.Static {
			new(socketFactoryRegistry: Http.Lookup<Http.ConnectionSocketFactory>, schemePortResolver: Http.SchemePortResolver, dnsResolver: Http.DnsResolver): Http.DefaultHttpClientConnectionOperator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.ConnectionShutdownException
	 * Signals that the connection has been shut down or released back to the
	 * the connection pool
	 *
	 * @since 4.1
	 */
	export interface ConnectionShutdownException extends Java.IllegalStateException {
	}
	export module ConnectionShutdownException {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.ConnectionShutdownException
		 * Signals that the connection has been shut down or released back to the
		 * the connection pool
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.IllegalStateException.Static {
			/**
			 * Creates a new ConnectionShutdownException with a {@code null} detail message.
			 */
			new(): Http.ConnectionShutdownException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.ManagedClientConnectionImpl
	 * @since 4.2
	 *
	 * @deprecated (4.3) use {@link ManagedHttpClientConnectionFactory}.
	 */
	export interface ManagedClientConnectionImpl extends Java.Object, Http.ManagedClientConnection {
	}
	export module ManagedClientConnectionImpl {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.ManagedClientConnectionImpl
		 * @since 4.2
		 *
		 * @deprecated (4.3) use {@link ManagedHttpClientConnectionFactory}.
		 */
		export interface Static extends Java.Object.Static, Http.ManagedClientConnection.Static {
			new(): Http.ManagedClientConnectionImpl;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultManagedHttpClientConnection
	 * Default {@link ManagedHttpClientConnection} implementation.
	 * @since 4.3
	 */
	export interface DefaultManagedHttpClientConnection extends Http.DefaultBHttpClientConnection, Http.ManagedHttpClientConnection, Http.HttpContext {
		bind(socket: Java.Socket): void;
		getAttribute(id: string): obj;
		getId(): string;
		getSSLSession(): Java.SSLSession;
		getSocket(): Java.Socket;
		removeAttribute(id: string): obj;
		setAttribute(id: string, obj: obj): void;
		shutdown(): void;
	}
	export module DefaultManagedHttpClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultManagedHttpClientConnection
		 * Default {@link ManagedHttpClientConnection} implementation.
		 * @since 4.3
		 */
		export interface Static extends Http.DefaultBHttpClientConnection.Static, Http.ManagedHttpClientConnection.Static, Http.HttpContext.Static {
			new(id: string, buffersize: int, fragmentSizeHint: int, chardecoder: Java.CharsetDecoder, charencoder: Java.CharsetEncoder, constraints: Http.MessageConstraints, incomingContentStrategy: Http.ContentLengthStrategy, outgoingContentStrategy: Http.ContentLengthStrategy, requestWriterFactory: Http.HttpMessageWriterFactory<Http.HttpRequest>, responseParserFactory: Http.HttpMessageParserFactory<Http.HttpResponse>): Http.DefaultManagedHttpClientConnection;
			new(id: string, buffersize: int): Http.DefaultManagedHttpClientConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.WaitingThread
	 * Represents a thread waiting for a connection.
	 * 
	 * This class implements throw away objects. It is instantiated whenever
	 * a thread needs to wait. Instances are not re-used, except if the
	 * waiting thread experiences a spurious wake up and continues to wait.
	 * 
	 * 
	 * All methods assume external synchronization on the condition
	 * passed to the constructor.
	 * Instances of this class do not synchronize access!
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2) do not use
	 */
	export interface WaitingThread extends Java.Object {
	}
	export module WaitingThread {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.WaitingThread
		 * Represents a thread waiting for a connection.
		 * 
		 * This class implements throw away objects. It is instantiated whenever
		 * a thread needs to wait. Instances are not re-used, except if the
		 * waiting thread experiences a spurious wake up and continues to wait.
		 * 
		 * 
		 * All methods assume external synchronization on the condition
		 * passed to the constructor.
		 * Instances of this class do not synchronize access!
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2) do not use
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.WaitingThread;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.ConnPoolByRoute
	 * A connection pool that maintains connections by route.
	 * This class is derived from {@code MultiThreadedHttpConnectionManager}
	 * in HttpClient 3.x, see there for original authors. It implements the same
	 * algorithm for connection re-use and connection-per-host enforcement:
	 * 
	 * connections are re-used only for the exact same route
	 * connection limits are enforced per route rather than per host
	 * 
	 * Note that access to the pool data structures is synchronized via the
	 * {@link AbstractConnPool#poolLock poolLock} in the base class,
	 * not via {@code synchronized} methods.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link org.apache.http.pool.AbstractConnPool}
	 */
	export interface ConnPoolByRoute extends Http.ConnectionAbstractConnPool {
	}
	export module ConnPoolByRoute {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.ConnPoolByRoute
		 * A connection pool that maintains connections by route.
		 * This class is derived from {@code MultiThreadedHttpConnectionManager}
		 * in HttpClient 3.x, see there for original authors. It implements the same
		 * algorithm for connection re-use and connection-per-host enforcement:
		 * 
		 * connections are re-used only for the exact same route
		 * connection limits are enforced per route rather than per host
		 * 
		 * Note that access to the pool data structures is synchronized via the
		 * {@link AbstractConnPool#poolLock poolLock} in the base class,
		 * not via {@code synchronized} methods.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link org.apache.http.pool.AbstractConnPool}
		 */
		export interface Static extends Http.ConnectionAbstractConnPool.Static {
			new(): Http.ConnPoolByRoute;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.BasicPooledConnAdapter
	 * A connection wrapper and callback handler.
	 * All connections given out by the manager are wrappers which
	 * can be {@link #detach detach}ed to prevent further use on release.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  do not use
	 */
	export interface BasicPooledConnAdapter extends Http.AbstractPooledConnAdapter {
	}
	export module BasicPooledConnAdapter {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.BasicPooledConnAdapter
		 * A connection wrapper and callback handler.
		 * All connections given out by the manager are wrappers which
		 * can be {@link #detach detach}ed to prevent further use on release.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  do not use
		 */
		export interface Static extends Http.AbstractPooledConnAdapter.Static {
			new(): Http.BasicPooledConnAdapter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.AbstractPooledConnAdapter
	 * Abstract adapter from pool {@link AbstractPoolEntry entries} to
	 * {@link org.apache.http.conn.ManagedClientConnection managed}
	 * client connections.
	 * The connection in the pool entry is used to initialize the base class.
	 * In addition, methods to establish a route are delegated to the
	 * pool entry. {@link #shutdown shutdown} and {@link #close close}
	 * will clear the tracked route in the pool entry and call the
	 * respective method of the wrapped connection.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  do not use
	 */
	export interface AbstractPooledConnAdapter extends Http.AbstractClientConnAdapter {
	}
	export module AbstractPooledConnAdapter {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.AbstractPooledConnAdapter
		 * Abstract adapter from pool {@link AbstractPoolEntry entries} to
		 * {@link org.apache.http.conn.ManagedClientConnection managed}
		 * client connections.
		 * The connection in the pool entry is used to initialize the base class.
		 * In addition, methods to establish a route are delegated to the
		 * pool entry. {@link #shutdown shutdown} and {@link #close close}
		 * will clear the tracked route in the pool entry and call the
		 * respective method of the wrapped connection.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  do not use
		 */
		export interface Static extends Http.AbstractClientConnAdapter.Static {
			new(): Http.AbstractPooledConnAdapter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultClientConnectionOperator
	 * Default implementation of a {@link ClientConnectionOperator}. It uses a {@link SchemeRegistry}
	 * to look up {@link SchemeSocketFactory} objects.
	 * 
	 * This connection operator is multihome network aware and will attempt to retry failed connects
	 * against all known IP addresses sequentially until the connect is successful or all known
	 * addresses fail to respond. Please note the same
	 * {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT} value will be used
	 * for each connection attempt, so in the worst case the total elapsed time before timeout
	 * can be {@code CONNECTION_TIMEOUT * n} where {@code n} is the number of IP addresses
	 * of the given host. One can disable multihome support by overriding
	 * the {@link #resolveHostname(String)} method and returning only one IP address for the given
	 * host name.
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_TIMEOUT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_LINGER}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_REUSEADDR}
	 *  {@link org.apache.http.params.CoreConnectionPNames#TCP_NODELAY}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SOCKET_BUFFER_SIZE}
	 *  {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link PoolingHttpClientConnectionManager}.
	 */
	export interface DefaultClientConnectionOperator extends Java.Object, Http.ClientConnectionOperator {
	}
	export module DefaultClientConnectionOperator {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultClientConnectionOperator
		 * Default implementation of a {@link ClientConnectionOperator}. It uses a {@link SchemeRegistry}
		 * to look up {@link SchemeSocketFactory} objects.
		 * 
		 * This connection operator is multihome network aware and will attempt to retry failed connects
		 * against all known IP addresses sequentially until the connect is successful or all known
		 * addresses fail to respond. Please note the same
		 * {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT} value will be used
		 * for each connection attempt, so in the worst case the total elapsed time before timeout
		 * can be {@code CONNECTION_TIMEOUT * n} where {@code n} is the number of IP addresses
		 * of the given host. One can disable multihome support by overriding
		 * the {@link #resolveHostname(String)} method and returning only one IP address for the given
		 * host name.
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_TIMEOUT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_LINGER}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_REUSEADDR}
		 *  {@link org.apache.http.params.CoreConnectionPNames#TCP_NODELAY}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SOCKET_BUFFER_SIZE}
		 *  {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link PoolingHttpClientConnectionManager}.
		 */
		export interface Static extends Java.Object.Static, Http.ClientConnectionOperator.Static {
			new(): Http.DefaultClientConnectionOperator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.CPoolEntry
	 * @since 4.3
	 */
	export interface CPoolEntry extends Http.PoolEntry<Http.HttpRoute, Http.ManagedHttpClientConnection> {
		close(): void;
		closeConnection(): void;
		isClosed(): boolean;
		isExpired(now: long): boolean;
		isRouteComplete(): boolean;
		markRouteComplete(): void;
		shutdownConnection(): void;
	}
	export module CPoolEntry {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.CPoolEntry
		 * @since 4.3
		 */
		export interface Static extends Http.PoolEntry.Static {
			new(log: Commons.Logging.Log, id: string, route: Http.HttpRoute, conn: Http.ManagedHttpClientConnection, timeToLive: long, tunit: Java.TimeUnit): Http.CPoolEntry;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultRoutePlanner
	 * Default implementation of an {@link HttpRoutePlanner}. It will not make use of
	 * any Java system properties, nor of system or browser proxy settings.
	 *
	 * @since 4.3
	 */
	export interface DefaultRoutePlanner extends Java.Object, Http.HttpRoutePlanner {
		determineRoute(host: Http.HttpHost, request: Http.HttpRequest, context: Http.HttpContext): Http.HttpRoute;
	}
	export module DefaultRoutePlanner {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultRoutePlanner
		 * Default implementation of an {@link HttpRoutePlanner}. It will not make use of
		 * any Java system properties, nor of system or browser proxy settings.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpRoutePlanner.Static {
			new(schemePortResolver: Http.SchemePortResolver): Http.DefaultRoutePlanner;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultHttpResponseParserFactory
	 * Default factory for response message parsers.
	 *
	 * @since 4.3
	 */
	export interface ConnectionDefaultHttpResponseParserFactory extends Java.Object, Http.HttpMessageParserFactory<Http.HttpResponse> {
		create(buffer: Http.SessionInputBuffer, constraints: Http.MessageConstraints): Http.HttpMessageParser<Http.HttpResponse>;
	}
	export module ConnectionDefaultHttpResponseParserFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultHttpResponseParserFactory
		 * Default factory for response message parsers.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpMessageParserFactory.Static {
			new(lineParser: Http.LineParser, responseFactory: Http.HttpResponseFactory): Http.ConnectionDefaultHttpResponseParserFactory;
			new(responseFactory: Http.HttpResponseFactory): Http.ConnectionDefaultHttpResponseParserFactory;
			new(): Http.ConnectionDefaultHttpResponseParserFactory;
			INSTANCE?: Http.ConnectionDefaultHttpResponseParserFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.ProxySelectorRoutePlanner
	 * Default implementation of an {@link HttpRoutePlanner}.
	 * This implementation is based on {@link java.net.ProxySelector}.
	 * By default, it will pick up the proxy settings of the JVM, either
	 * from system properties or from the browser running the application.
	 * Additionally, it interprets some
	 * {@link org.apache.http.conn.params.ConnRoutePNames parameters},
	 * though not the {@link
	 * org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY DEFAULT_PROXY}.
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link SystemDefaultRoutePlanner}
	 */
	export interface ProxySelectorRoutePlanner extends Java.Object, Http.HttpRoutePlanner {
	}
	export module ProxySelectorRoutePlanner {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.ProxySelectorRoutePlanner
		 * Default implementation of an {@link HttpRoutePlanner}.
		 * This implementation is based on {@link java.net.ProxySelector}.
		 * By default, it will pick up the proxy settings of the JVM, either
		 * from system properties or from the browser running the application.
		 * Additionally, it interprets some
		 * {@link org.apache.http.conn.params.ConnRoutePNames parameters},
		 * though not the {@link
		 * org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY DEFAULT_PROXY}.
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link SystemDefaultRoutePlanner}
		 */
		export interface Static extends Java.Object.Static, Http.HttpRoutePlanner.Static {
			new(): Http.ProxySelectorRoutePlanner;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AuthSchemeRegistry
	 * Authentication scheme registry that can be used to obtain the corresponding
	 * authentication scheme implementation for a given type of authorization challenge.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.config.Registry}
	 */
	export interface AuthSchemeRegistry extends Java.Object, Http.Lookup<Http.AuthSchemeProvider> {
	}
	export module AuthSchemeRegistry {
		/**
		 * Corresponding Java class: org.apache.http.auth.AuthSchemeRegistry
		 * Authentication scheme registry that can be used to obtain the corresponding
		 * authentication scheme implementation for a given type of authorization challenge.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.config.Registry}
		 */
		export interface Static extends Java.Object.Static, Http.Lookup.Static {
			new(): Http.AuthSchemeRegistry;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.NTCredentials
	 * {@link Credentials} implementation for Microsoft Windows platforms that includes
	 * Windows specific attributes such as name of the domain the user belongs to.
	 *
	 * @since 4.0
	 */
	export interface NTCredentials extends Java.Object, Http.Credentials, Java.Serializable {
		equals(o: obj): boolean;
		/**
		 * Retrieves the name to authenticate with.
		 *
		 * @return String the domain these credentials are intended to authenticate with.
		 */
		getDomain(): string;
		getPassword(): string;
		getUserName(): string;
		getUserPrincipal(): Java.Principal;
		/**
		 * Retrieves the workstation name of the computer originating the request.
		 *
		 * @return String the workstation the user is logged into.
		 */
		getWorkstation(): string;
		hashCode(): int;
		toString(): string;
	}
	export module NTCredentials {
		/**
		 * Corresponding Java class: org.apache.http.auth.NTCredentials
		 * {@link Credentials} implementation for Microsoft Windows platforms that includes
		 * Windows specific attributes such as name of the domain the user belongs to.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.Credentials.Static, Java.Serializable.Static {
			/**
			 * Constructor.
			 * @param userName The user name.  This should not include the domain to authenticate with.
			 * For example: "user" is correct whereas "DOMAIN&#x5c;user" is not.
			 * @param password The password.
			 * @param workstation The workstation the authentication request is originating from.
			 * Essentially, the computer name for this machine.
			 * @param domain The domain to authenticate within.
			 */
			new(userName: string, password: string, workstation: string, domain: string): Http.NTCredentials;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.params.AuthPNames
	 * Parameter names for HTTP authentication classes.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}
	 *   and constructor parameters of
	 *   {@link org.apache.http.auth.AuthSchemeProvider}s.
	 */
	export interface AuthPNames extends Java.Object {
	}
	export module AuthPNames {
		/**
		 * Corresponding Java class: org.apache.http.auth.params.AuthPNames
		 * Parameter names for HTTP authentication classes.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}
		 *   and constructor parameters of
		 *   {@link org.apache.http.auth.AuthSchemeProvider}s.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.BasicUserPrincipal
	 * Basic user principal used for HTTP authentication
	 *
	 * @since 4.0
	 */
	export interface BasicUserPrincipal extends Java.Object, Java.Principal, Java.Serializable {
		equals(o: obj): boolean;
		getName(): string;
		hashCode(): int;
		toString(): string;
	}
	export module BasicUserPrincipal {
		/**
		 * Corresponding Java class: org.apache.http.auth.BasicUserPrincipal
		 * Basic user principal used for HTTP authentication
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Java.Principal.Static, Java.Serializable.Static {
			new(username: string): Http.BasicUserPrincipal;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AuthScope
	 * {@code AuthScope} represents an authentication scope consisting of a host name,
	 * a port number, a realm name and an authentication scheme name.
	 * 
	 * This class can also optionally contain a host of origin, if created in response
	 * to authentication challenge from a specific host.
	 * 
	 * @since 4.0
	 */
	export interface AuthScope extends Java.Object {
		/**
		 * @see java.lang.Object#equals(Object)
		 */
		equals(o: obj): boolean;
		/**
		 * @return the host
		 */
		getHost(): string;
		/**
		 * @return host of origin. If unknown returns @null,
		 *
		 * @since 4.4
		 */
		getOrigin(): Http.HttpHost;
		/**
		 * @return the port
		 */
		getPort(): int;
		/**
		 * @return the realm name
		 */
		getRealm(): string;
		/**
		 * @return the scheme type
		 */
		getScheme(): string;
		/**
		 * @see java.lang.Object#hashCode()
		 */
		hashCode(): int;
		/**
		 * Tests if the authentication scopes match.
		 *
		 * @return the match factor. Negative value signifies no match.
		 *    Non-negative signifies a match. The greater the returned value
		 *    the closer the match.
		 */
		match(that: Http.AuthScope): int;
		/**
		 * @see java.lang.Object#toString()
		 */
		toString(): string;
	}
	export module AuthScope {
		/**
		 * Corresponding Java class: org.apache.http.auth.AuthScope
		 * {@code AuthScope} represents an authentication scope consisting of a host name,
		 * a port number, a realm name and an authentication scheme name.
		 * 
		 * This class can also optionally contain a host of origin, if created in response
		 * to authentication challenge from a specific host.
		 * 
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Defines auth scope with the given {@code host}, {@code port}, {@code realm}, and
			 * {@code schemeName}.
			 *
			 * @param host authentication host. May be {@link #ANY_HOST} if applies
			 *   to any host.
			 * @param port authentication port. May be {@link #ANY_PORT} if applies
			 *   to any port of the host.
			 * @param realm authentication realm. May be {@link #ANY_REALM} if applies
			 *   to any realm on the host.
			 * @param schemeName authentication scheme. May be {@link #ANY_SCHEME} if applies
			 *   to any scheme supported by the host.
			 */
			new(host: string, port: int, realm: string, schemeName: string): Http.AuthScope;
			/**
			 * Defines auth scope for a specific host of origin.
			 *
			 * @param origin host of origin
			 * @param realm authentication realm. May be {@link #ANY_REALM} if applies
			 *   to any realm on the host.
			 * @param schemeName authentication scheme. May be {@link #ANY_SCHEME} if applies
			 *   to any scheme supported by the host.
			 *
			 * @since 4.2
			 */
			new(origin: Http.HttpHost, realm: string, schemeName: string): Http.AuthScope;
			/**
			 * Defines auth scope for a specific host of origin.
			 *
			 * @param origin host of origin
			 *
			 * @since 4.2
			 */
			new(origin: Http.HttpHost): Http.AuthScope;
			/**
			 * Defines auth scope with the given {@code host}, {@code port} and {@code realm}.
			 *
			 * @param host authentication host. May be {@link #ANY_HOST} if applies
			 *   to any host.
			 * @param port authentication port. May be {@link #ANY_PORT} if applies
			 *   to any port of the host.
			 * @param realm authentication realm. May be {@link #ANY_REALM} if applies
			 *   to any realm on the host.
			 */
			new(host: string, port: int, realm: string): Http.AuthScope;
			/**
			 * Defines auth scope with the given {@code host} and {@code port}.
			 *
			 * @param host authentication host. May be {@link #ANY_HOST} if applies
			 *   to any host.
			 * @param port authentication port. May be {@link #ANY_PORT} if applies
			 *   to any port of the host.
			 */
			new(host: string, port: int): Http.AuthScope;
			/**
			 * Creates a copy of the given credentials scope.
			 */
			new(authscope: Http.AuthScope): Http.AuthScope;
			/**
			 * The {@code null} value represents any host. In the future versions of
			 * HttpClient the use of this parameter will be discontinued.
			 */
			ANY_HOST?: string;
			/**
			 * The {@code -1} value represents any port.
			 */
			ANY_PORT?: int;
			/**
			 * The {@code null} value represents any realm.
			 */
			ANY_REALM?: string;
			/**
			 * The {@code null} value represents any authentication scheme.
			 */
			ANY_SCHEME?: string;
			/**
			 * Default scope matching any host, port, realm and authentication scheme.
			 * In the future versions of HttpClient the use of this parameter will be
			 * discontinued.
			 */
			ANY?: Http.AuthScope;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AuthOption
	 * @since 4.2
	 */
	export interface AuthOption extends Java.Object {
		getAuthScheme(): Http.AuthScheme;
		getCredentials(): Http.Credentials;
		toString(): string;
	}
	export module AuthOption {
		/**
		 * Corresponding Java class: org.apache.http.auth.AuthOption
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
			new(authScheme: Http.AuthScheme, creds: Http.Credentials): Http.AuthOption;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultHttpResponseParser
	 * Lenient HTTP response parser implementation that can skip malformed data until
	 * a valid HTTP response message head is encountered.
	 *
	 * @since 4.2
	 */
	export interface ConnectionDefaultHttpResponseParser extends Http.AbstractMessageParser<Http.HttpResponse> {
	}
	export module ConnectionDefaultHttpResponseParser {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultHttpResponseParser
		 * Lenient HTTP response parser implementation that can skip malformed data until
		 * a valid HTTP response message head is encountered.
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.AbstractMessageParser.Static {
			/**
			 * Creates new instance of DefaultHttpResponseParser.
			 *
			 * @param buffer the session input buffer.
			 * @param lineParser the line parser. If {@code null}
			 *   {@link org.apache.http.message.BasicLineParser#INSTANCE} will be used.
			 * @param responseFactory HTTP response factory. If {@code null}
			 *   {@link DefaultHttpResponseFactory#INSTANCE} will be used.
			 * @param constraints the message constraints. If {@code null}
			 *   {@link MessageConstraints#DEFAULT} will be used.
			 *
			 * @since 4.3
			 */
			new(buffer: Http.SessionInputBuffer, lineParser: Http.LineParser, responseFactory: Http.HttpResponseFactory, constraints: Http.MessageConstraints): Http.ConnectionDefaultHttpResponseParser;
			/**
			 * Creates new instance of DefaultHttpResponseParser.
			 *
			 * @param buffer the session input buffer.
			 * @param constraints the message constraints. If {@code null}
			 *   {@link MessageConstraints#DEFAULT} will be used.
			 *
			 * @since 4.3
			 */
			new(buffer: Http.SessionInputBuffer, constraints: Http.MessageConstraints): Http.ConnectionDefaultHttpResponseParser;
			/**
			 * Creates new instance of DefaultHttpResponseParser.
			 *
			 * @param buffer the session input buffer.
			 *
			 * @since 4.3
			 */
			new(buffer: Http.SessionInputBuffer): Http.ConnectionDefaultHttpResponseParser;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookieRestrictionViolationException
	 * Signals that a cookie violates a restriction imposed by the cookie
	 * specification.
	 *
	 * @since 4.1
	 */
	export interface CookieRestrictionViolationException extends Http.MalformedCookieException {
	}
	export module CookieRestrictionViolationException {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookieRestrictionViolationException
		 * Signals that a cookie violates a restriction imposed by the cookie
		 * specification.
		 *
		 * @since 4.1
		 */
		export interface Static extends Http.MalformedCookieException.Static {
			/**
			 * Creates a new CookeFormatViolationException with a {@code null} detail
			 * message.
			 */
			new(): Http.CookieRestrictionViolationException;
			/**
			 * Creates a new CookeRestrictionViolationException with a specified
			 * message string.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.CookieRestrictionViolationException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookieIdentityComparator
	 * This cookie comparator can be used to compare identity of cookies.
	 * 
	 *  Cookies are considered identical if their names are equal and
	 *  their domain attributes match ignoring case.
	 *
	 * @since 4.0
	 */
	export interface CookieIdentityComparator extends Java.Object, Java.Serializable, Java.Comparator<Http.Cookie> {
		compare(c1: Http.Cookie, c2: Http.Cookie): int;
		/**
		 * Indicates whether some other object is "equal to" this one.
		 * 
		 * The {@code equals} method implements an equivalence relation
		 * on non-null object references:
		 * 
		 * It is reflexive: for any non-null reference value
		 *     {@code x}, {@code x.equals(x)} should return
		 *     {@code true}.
		 * It is symmetric: for any non-null reference values
		 *     {@code x} and {@code y}, {@code x.equals(y)}
		 *     should return {@code true} if and only if
		 *     {@code y.equals(x)} returns {@code true}.
		 * It is transitive: for any non-null reference values
		 *     {@code x}, {@code y}, and {@code z}, if
		 *     {@code x.equals(y)} returns {@code true} and
		 *     {@code y.equals(z)} returns {@code true}, then
		 *     {@code x.equals(z)} should return {@code true}.
		 * It is consistent: for any non-null reference values
		 *     {@code x} and {@code y}, multiple invocations of
		 *     {@code x.equals(y)} consistently return {@code true}
		 *     or consistently return {@code false}, provided no
		 *     information used in {@code equals} comparisons on the
		 *     objects is modified.
		 * For any non-null reference value {@code x},
		 *     {@code x.equals(null)} should return {@code false}.
		 * 
		 * 
		 * The {@code equals} method for class {@code Object} implements
		 * the most discriminating possible equivalence relation on objects;
		 * that is, for any non-null reference values {@code x} and
		 * {@code y}, this method returns {@code true} if and only
		 * if {@code x} and {@code y} refer to the same object
		 * ({@code x == y} has the value {@code true}).
		 * 
		 * Note that it is generally necessary to override the {@code hashCode}
		 * method whenever this method is overridden, so as to maintain the
		 * general contract for the {@code hashCode} method, which states
		 * that equal objects must have equal hash codes.
		 *
		 * @param   obj   the reference object with which to compare.
		 * @return  {@code true} if this object is the same as the obj
		 *          argument; {@code false} otherwise.
		 * @see     #hashCode()
		 * @see     java.util.HashMap
		 */
		equals(obj: obj): boolean;
	}
	export module CookieIdentityComparator {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookieIdentityComparator
		 * This cookie comparator can be used to compare identity of cookies.
		 * 
		 *  Cookies are considered identical if their names are equal and
		 *  their domain attributes match ignoring case.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Java.Serializable.Static, Java.Comparator.Static {
			new(): Http.CookieIdentityComparator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.SM
	 * Constants and static helpers related to the HTTP state management.
	 *
	 *
	 * @since 4.0
	 */
	export interface SM extends Java.Object {
	}
	export module SM {
		/**
		 * Corresponding Java class: org.apache.http.cookie.SM
		 * Constants and static helpers related to the HTTP state management.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			COOKIE?: string;
			COOKIE2?: string;
			SET_COOKIE?: string;
			SET_COOKIE2?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookieOrigin
	 * CookieOrigin class encapsulates details of an origin server that
	 * are relevant when parsing, validating or matching HTTP cookies.
	 *
	 * @since 4.0
	 */
	export interface CookieOrigin extends Java.Object {
		getHost(): string;
		getPath(): string;
		getPort(): int;
		isSecure(): boolean;
		toString(): string;
	}
	export module CookieOrigin {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookieOrigin
		 * CookieOrigin class encapsulates details of an origin server that
		 * are relevant when parsing, validating or matching HTTP cookies.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new(host: string, port: int, path: string, secure: boolean): Http.CookieOrigin;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookieAttributeHandler
	 * This interface represents a cookie attribute handler responsible
	 * for parsing, validating, and matching a specific cookie attribute,
	 * such as path, domain, port, etc.
	 *
	 * Different cookie specifications can provide a specific
	 * implementation for this class based on their cookie handling
	 * rules.
	 *
	 *
	 * @since 4.0
	 */
	export interface CookieAttributeHandler extends Java.Object {
		/**
		 * Matches the given value (property of the destination host where request is being
		 * submitted) with the corresponding cookie attribute.
		 *
		 * @param cookie {@link org.apache.http.cookie.Cookie} to match
		 * @param origin the cookie source to match against
		 * @return {@code true} if the match is successful; {@code false} otherwise
		 */
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		/**
		 * Parse the given cookie attribute value and update the corresponding
		 * {@link org.apache.http.cookie.Cookie} property.
		 *
		 * @param cookie {@link org.apache.http.cookie.Cookie} to be updated
		 * @param value cookie attribute value from the cookie response header
		 */
		parse(cookie: Http.SetCookie, value: string): void;
		/**
		 * Peforms cookie validation for the given attribute value.
		 *
		 * @param cookie {@link org.apache.http.cookie.Cookie} to validate
		 * @param origin the cookie source to validate against
		 * @throws MalformedCookieException if cookie validation fails for this attribute
		 */
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module CookieAttributeHandler {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookieAttributeHandler
		 * This interface represents a cookie attribute handler responsible
		 * for parsing, validating, and matching a specific cookie attribute,
		 * such as path, domain, port, etc.
		 *
		 * Different cookie specifications can provide a specific
		 * implementation for this class based on their cookie handling
		 * rules.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.SetCookie2
	 * This interface represents a {@code Set-Cookie2} response header sent by the
	 * origin server to the HTTP agent in order to maintain a conversational state.
	 * 
	 * Please do not use methods marked as @Obsolete. They have been rendered
	 * obsolete by RFC 6265
	 *
	 * @since 4.0
	 */
	export interface SetCookie2 extends Http.SetCookie {
		/**
		 * If a user agent (web browser) presents this cookie to a user, the
		 * cookie's purpose will be described by the information at this URL.
		 */
		setCommentURL(commentURL: string): void;
		/**
		 * Set the Discard attribute.
		 *
		 * Note: {@code Discard} attribute overrides {@code Max-age}.
		 *
		 * @see #isPersistent()
		 */
		setDiscard(discard: boolean): void;
		/**
		 * Sets the Port attribute. It restricts the ports to which a cookie
		 * may be returned in a Cookie request header.
		 */
		setPorts(ports: array<int>): void;
	}
	export module SetCookie2 {
		/**
		 * Corresponding Java class: org.apache.http.cookie.SetCookie2
		 * This interface represents a {@code Set-Cookie2} response header sent by the
		 * origin server to the HTTP agent in order to maintain a conversational state.
		 * 
		 * Please do not use methods marked as @Obsolete. They have been rendered
		 * obsolete by RFC 6265
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.SetCookie.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookieSpec
	 * Defines the cookie management specification.
	 * Cookie management specification must define
	 * 
	 *    rules of parsing "Set-Cookie" header
	 *    rules of validation of parsed cookies
	 *     formatting of "Cookie" header
	 * 
	 * for a given host, port and path of origin
	 * 
	 * Please do not use methods marked as @Obsolete. They have been rendered
	 * obsolete by RFC 6265.
	 *
	 * @since 4.0
	 */
	export interface CookieSpec extends Java.Object {
		/**
		 * Create {@code "Cookie"} headers for an array of Cookies.
		 *
		 * @param cookies the Cookies format into a Cookie header
		 * @return a Header for the given Cookies.
		 * @throws IllegalArgumentException if an input parameter is illegal
		 */
		formatCookies(cookies: Java.List<Http.Cookie>): Java.List<Http.Header>;
		/**
		 * Returns version of the state management this cookie specification
		 * conforms to.
		 *
		 * @return version of the state management specification
		 */
		getVersion(): int;
		/**
		 * Returns a request header identifying what version of the state management
		 * specification is understood. May be {@code null} if the cookie
		 * specification does not support {@code Cookie2} header.
		 */
		getVersionHeader(): Http.Header;
		/**
		 * Determines if a Cookie matches the target location.
		 *
		 * @param cookie the Cookie to be matched
		 * @param origin the target to test against
		 *
		 * @return {@code true} if the cookie should be submitted with a request
		 *  with given attributes, {@code false} otherwise.
		 */
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		/**
		 * Parse the {@code "Set-Cookie"} Header into an array of Cookies.
		 *
		 * This method will not perform the validation of the resultant
		 * {@link Cookie}s
		 *
		 * @see #validate
		 *
		 * @param header the {@code Set-Cookie} received from the server
		 * @param origin details of the cookie origin
		 * @return an array of {@code Cookie}s parsed from the header
		 * @throws MalformedCookieException if an exception occurs during parsing
		 */
		parse(header: Http.Header, origin: Http.CookieOrigin): Java.List<Http.Cookie>;
		/**
		 * Validate the cookie according to validation rules defined by the
		 *  cookie specification.
		 *
		 * @param cookie the Cookie to validate
		 * @param origin details of the cookie origin
		 * @throws MalformedCookieException if the cookie is invalid
		 */
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module CookieSpec {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookieSpec
		 * Defines the cookie management specification.
		 * Cookie management specification must define
		 * 
		 *    rules of parsing "Set-Cookie" header
		 *    rules of validation of parsed cookies
		 *     formatting of "Cookie" header
		 * 
		 * for a given host, port and path of origin
		 * 
		 * Please do not use methods marked as @Obsolete. They have been rendered
		 * obsolete by RFC 6265.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.params.CookieSpecPNames
	 * Parameter names for HTTP cookie management classes.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use constructor parameters of {@link
	 *   org.apache.http.cookie.CookieSpecProvider}s.
	 */
	export interface CookieSpecPNames extends Java.Object {
	}
	export module CookieSpecPNames {
		/**
		 * Corresponding Java class: org.apache.http.cookie.params.CookieSpecPNames
		 * Parameter names for HTTP cookie management classes.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use constructor parameters of {@link
		 *   org.apache.http.cookie.CookieSpecProvider}s.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.MalformedCookieException
	 * Signals that a cookie is in some way invalid or illegal in a given
	 * context
	 *
	 *
	 * @since 4.0
	 */
	export interface MalformedCookieException extends Http.ProtocolException {
	}
	export module MalformedCookieException {
		/**
		 * Corresponding Java class: org.apache.http.cookie.MalformedCookieException
		 * Signals that a cookie is in some way invalid or illegal in a given
		 * context
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.ProtocolException.Static {
			/**
			 * Creates a new MalformedCookieException with a {@code null} detail message.
			 */
			new(): Http.MalformedCookieException;
			/**
			 * Creates a new MalformedCookieException with a specified message string.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.MalformedCookieException;
			/**
			 * Creates a new MalformedCookieException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.MalformedCookieException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.ClientCookie
	 * ClientCookie extends the standard {@link Cookie} interface with
	 * additional client specific functionality such ability to retrieve
	 * original cookie attributes exactly as they were specified by the
	 * origin server. This is important for generating the {@code Cookie}
	 * header because some cookie specifications require that the
	 * {@code Cookie} header should include certain attributes only if
	 * they were specified in the {@code Set-Cookie} header.
	 * 
	 * Please do not use attributes marked as @Obsolete. They have been rendered
	 * obsolete by RFC 6265.
	 *
	 * @since 4.0
	 */
	export interface ClientCookie extends Http.Cookie {
		containsAttribute(name: string): boolean;
		getAttribute(name: string): string;
	}
	export module ClientCookie {
		/**
		 * Corresponding Java class: org.apache.http.cookie.ClientCookie
		 * ClientCookie extends the standard {@link Cookie} interface with
		 * additional client specific functionality such ability to retrieve
		 * original cookie attributes exactly as they were specified by the
		 * origin server. This is important for generating the {@code Cookie}
		 * header because some cookie specifications require that the
		 * {@code Cookie} header should include certain attributes only if
		 * they were specified in the {@code Set-Cookie} header.
		 * 
		 * Please do not use attributes marked as @Obsolete. They have been rendered
		 * obsolete by RFC 6265.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.Cookie.Static {
			VERSION_ATTR?: string;
			PATH_ATTR?: string;
			DOMAIN_ATTR?: string;
			MAX_AGE_ATTR?: string;
			SECURE_ATTR?: string;
			COMMENT_ATTR?: string;
			EXPIRES_ATTR?: string;
			PORT_ATTR?: string;
			COMMENTURL_ATTR?: string;
			DISCARD_ATTR?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CommonCookieAttributeHandler
	 * Extension of {@link org.apache.http.cookie.CookieAttributeHandler} intended
	 * to handle one specific common attribute whose name is returned with
	 * {@link #getAttributeName()} method.
	 *
	 * @since 4.4
	 */
	export interface CommonCookieAttributeHandler extends Http.CookieAttributeHandler {
		getAttributeName(): string;
	}
	export module CommonCookieAttributeHandler {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CommonCookieAttributeHandler
		 * Extension of {@link org.apache.http.cookie.CookieAttributeHandler} intended
		 * to handle one specific common attribute whose name is returned with
		 * {@link #getAttributeName()} method.
		 *
		 * @since 4.4
		 */
		export interface Static extends Http.CookieAttributeHandler.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookiePathComparator
	 * This cookie comparator ensures that multiple cookies satisfying
	 * a common criteria are ordered in the {@code Cookie} header such
	 * that those with more specific Path attributes precede those with
	 * less specific.
	 *
	 * 
	 * This comparator assumes that Path attributes of two cookies
	 * path-match a commmon request-URI. Otherwise, the result of the
	 * comparison is undefined.
	 * 
	 *
	 *
	 * @since 4.0
	 */
	export interface CookiePathComparator extends Java.Object, Java.Serializable, Java.Comparator<Http.Cookie> {
		compare(c1: Http.Cookie, c2: Http.Cookie): int;
		/**
		 * Indicates whether some other object is "equal to" this one.
		 * 
		 * The {@code equals} method implements an equivalence relation
		 * on non-null object references:
		 * 
		 * It is reflexive: for any non-null reference value
		 *     {@code x}, {@code x.equals(x)} should return
		 *     {@code true}.
		 * It is symmetric: for any non-null reference values
		 *     {@code x} and {@code y}, {@code x.equals(y)}
		 *     should return {@code true} if and only if
		 *     {@code y.equals(x)} returns {@code true}.
		 * It is transitive: for any non-null reference values
		 *     {@code x}, {@code y}, and {@code z}, if
		 *     {@code x.equals(y)} returns {@code true} and
		 *     {@code y.equals(z)} returns {@code true}, then
		 *     {@code x.equals(z)} should return {@code true}.
		 * It is consistent: for any non-null reference values
		 *     {@code x} and {@code y}, multiple invocations of
		 *     {@code x.equals(y)} consistently return {@code true}
		 *     or consistently return {@code false}, provided no
		 *     information used in {@code equals} comparisons on the
		 *     objects is modified.
		 * For any non-null reference value {@code x},
		 *     {@code x.equals(null)} should return {@code false}.
		 * 
		 * 
		 * The {@code equals} method for class {@code Object} implements
		 * the most discriminating possible equivalence relation on objects;
		 * that is, for any non-null reference values {@code x} and
		 * {@code y}, this method returns {@code true} if and only
		 * if {@code x} and {@code y} refer to the same object
		 * ({@code x == y} has the value {@code true}).
		 * 
		 * Note that it is generally necessary to override the {@code hashCode}
		 * method whenever this method is overridden, so as to maintain the
		 * general contract for the {@code hashCode} method, which states
		 * that equal objects must have equal hash codes.
		 *
		 * @param   obj   the reference object with which to compare.
		 * @return  {@code true} if this object is the same as the obj
		 *          argument; {@code false} otherwise.
		 * @see     #hashCode()
		 * @see     java.util.HashMap
		 */
		equals(obj: obj): boolean;
	}
	export module CookiePathComparator {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookiePathComparator
		 * This cookie comparator ensures that multiple cookies satisfying
		 * a common criteria are ordered in the {@code Cookie} header such
		 * that those with more specific Path attributes precede those with
		 * less specific.
		 *
		 * 
		 * This comparator assumes that Path attributes of two cookies
		 * path-match a commmon request-URI. Otherwise, the result of the
		 * comparison is undefined.
		 * 
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Java.Serializable.Static, Java.Comparator.Static {
			new(): Http.CookiePathComparator;
			INSTANCE?: Http.CookiePathComparator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.SetCookie
	 * This interface represents a {@code Set-Cookie} response header sent by the
	 * origin server to the HTTP agent in order to maintain a conversational state.
	 * 
	 * Please do not use methods marked as @Obsolete. They have been rendered
	 * obsolete by RFC 6265
	 *
	 * @since 4.0
	 */
	export interface SetCookie extends Http.Cookie {
		/**
		 * If a user agent (web browser) presents this cookie to a user, the
		 * cookie's purpose will be described using this comment.
		 *
		 * @param comment
		 *
		 * @see #getComment()
		 */
		setComment(comment: string): void;
		/**
		 * Sets the domain attribute.
		 *
		 * @param domain The value of the domain attribute
		 *
		 * @see Cookie#getDomain
		 */
		setDomain(domain: string): void;
		/**
		 * Sets expiration date.
		 * Note: the object returned by this method is considered
		 * immutable. Changing it (e.g. using setTime()) could result in undefined
		 * behaviour. Do so at your peril.
		 *
		 * @param expiryDate the {@link Date} after which this cookie is no longer valid.
		 *
		 * @see Cookie#getExpiryDate
		 *
		 */
		setExpiryDate(expiryDate: Java.Date): void;
		/**
		 * Sets the path attribute.
		 *
		 * @param path The value of the path attribute
		 *
		 * @see Cookie#getPath
		 *
		 */
		setPath(path: string): void;
		/**
		 * Sets the secure attribute of the cookie.
		 * 
		 * When {@code true} the cookie should only be sent
		 * using a secure protocol (https).  This should only be set when
		 * the cookie's originating server used a secure protocol to set the
		 * cookie's value.
		 *
		 * @param secure The value of the secure attribute
		 *
		 * @see #isSecure()
		 */
		setSecure(secure: boolean): void;
		setValue(value: string): void;
		/**
		 * Sets the version of the cookie specification to which this
		 * cookie conforms.
		 *
		 * @param version the version of the cookie.
		 *
		 * @see Cookie#getVersion
		 */
		setVersion(version: int): void;
	}
	export module SetCookie {
		/**
		 * Corresponding Java class: org.apache.http.cookie.SetCookie
		 * This interface represents a {@code Set-Cookie} response header sent by the
		 * origin server to the HTTP agent in order to maintain a conversational state.
		 * 
		 * Please do not use methods marked as @Obsolete. They have been rendered
		 * obsolete by RFC 6265
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.Cookie.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.Cookie
	 * Cookie interface represents a token or short packet of state information
	 * (also referred to as "magic-cookie") that the HTTP agent and the target
	 * server can exchange to maintain a session. In its simples form an HTTP
	 * cookie is merely a name / value pair.
	 * 
	 * Please do not use attributes marked as @Obsolete. They have been rendered
	 * obsolete by RFC 6265.
	 *
	 * @since 4.0
	 */
	export interface Cookie extends Java.Object {
		/**
		 * Returns the comment describing the purpose of this cookie, or
		 * {@code null} if no such comment has been defined.
		 *
		 * @return comment
		 */
		getComment(): string;
		/**
		 * If a user agent (web browser) presents this cookie to a user, the
		 * cookie's purpose will be described by the information at this URL.
		 */
		getCommentURL(): string;
		/**
		 * Returns domain attribute of the cookie. The value of the Domain
		 * attribute specifies the domain for which the cookie is valid.
		 *
		 * @return the value of the domain attribute.
		 */
		getDomain(): string;
		/**
		 * Returns the expiration {@link Date} of the cookie, or {@code null}
		 * if none exists.
		 * Note: the object returned by this method is
		 * considered immutable. Changing it (e.g. using setTime()) could result
		 * in undefined behaviour. Do so at your peril. 
		 * @return Expiration {@link Date}, or {@code null}.
		 */
		getExpiryDate(): Java.Date;
		/**
		 * Returns the name.
		 *
		 * @return String name The name
		 */
		getName(): string;
		/**
		 * Returns the path attribute of the cookie. The value of the Path
		 * attribute specifies the subset of URLs on the origin server to which
		 * this cookie applies.
		 *
		 * @return The value of the path attribute.
		 */
		getPath(): string;
		/**
		 * Get the Port attribute. It restricts the ports to which a cookie
		 * may be returned in a Cookie request header.
		 */
		getPorts(): array<int>;
		/**
		 * Returns the value.
		 *
		 * @return String value The current value.
		 */
		getValue(): string;
		/**
		 * Returns the version of the cookie specification to which this
		 * cookie conforms.
		 *
		 * @return the version of the cookie.
		 */
		getVersion(): int;
		/**
		 * Returns true if this cookie has expired.
		 * @param date Current time
		 *
		 * @return {@code true} if the cookie has expired.
		 */
		isExpired(date: Java.Date): boolean;
		/**
		 * Returns {@code false} if the cookie should be discarded at the end
		 * of the "session"; {@code true} otherwise.
		 *
		 * @return {@code false} if the cookie should be discarded at the end
		 *         of the "session"; {@code true} otherwise
		 */
		isPersistent(): boolean;
		/**
		 * Indicates whether this cookie requires a secure connection.
		 *
		 * @return  {@code true} if this cookie should only be sent
		 *          over secure connections, {@code false} otherwise.
		 */
		isSecure(): boolean;
	}
	export module Cookie {
		/**
		 * Corresponding Java class: org.apache.http.cookie.Cookie
		 * Cookie interface represents a token or short packet of state information
		 * (also referred to as "magic-cookie") that the HTTP agent and the target
		 * server can exchange to maintain a session. In its simples form an HTTP
		 * cookie is merely a name / value pair.
		 * 
		 * Please do not use attributes marked as @Obsolete. They have been rendered
		 * obsolete by RFC 6265.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookieSpecProvider
	 * Factory for {@link CookieSpec} implementations.
	 *
	 * @since 4.3
	 */
	export interface CookieSpecProvider extends Java.Object {
		/**
		 * Creates an instance of {@link CookieSpec}.
		 *
		 * @return auth scheme.
		 */
		create(context: Http.HttpContext): Http.CookieSpec;
	}
	export module CookieSpecProvider {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookieSpecProvider
		 * Factory for {@link CookieSpec} implementations.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookiePriorityComparator
	 * This cookie comparator ensures that cookies with longer paths take precedence over
	 * cookies with shorter path. Among cookies with equal path length cookies with ealier
	 * creation time take precedence over cookies with later creation time
	 *
	 * @since 4.4
	 */
	export interface CookiePriorityComparator extends Java.Object, Java.Comparator<Http.Cookie> {
		compare(c1: Http.Cookie, c2: Http.Cookie): int;
		/**
		 * Indicates whether some other object is "equal to" this one.
		 * 
		 * The {@code equals} method implements an equivalence relation
		 * on non-null object references:
		 * 
		 * It is reflexive: for any non-null reference value
		 *     {@code x}, {@code x.equals(x)} should return
		 *     {@code true}.
		 * It is symmetric: for any non-null reference values
		 *     {@code x} and {@code y}, {@code x.equals(y)}
		 *     should return {@code true} if and only if
		 *     {@code y.equals(x)} returns {@code true}.
		 * It is transitive: for any non-null reference values
		 *     {@code x}, {@code y}, and {@code z}, if
		 *     {@code x.equals(y)} returns {@code true} and
		 *     {@code y.equals(z)} returns {@code true}, then
		 *     {@code x.equals(z)} should return {@code true}.
		 * It is consistent: for any non-null reference values
		 *     {@code x} and {@code y}, multiple invocations of
		 *     {@code x.equals(y)} consistently return {@code true}
		 *     or consistently return {@code false}, provided no
		 *     information used in {@code equals} comparisons on the
		 *     objects is modified.
		 * For any non-null reference value {@code x},
		 *     {@code x.equals(null)} should return {@code false}.
		 * 
		 * 
		 * The {@code equals} method for class {@code Object} implements
		 * the most discriminating possible equivalence relation on objects;
		 * that is, for any non-null reference values {@code x} and
		 * {@code y}, this method returns {@code true} if and only
		 * if {@code x} and {@code y} refer to the same object
		 * ({@code x == y} has the value {@code true}).
		 * 
		 * Note that it is generally necessary to override the {@code hashCode}
		 * method whenever this method is overridden, so as to maintain the
		 * general contract for the {@code hashCode} method, which states
		 * that equal objects must have equal hash codes.
		 *
		 * @param   obj   the reference object with which to compare.
		 * @return  {@code true} if this object is the same as the obj
		 *          argument; {@code false} otherwise.
		 * @see     #hashCode()
		 * @see     java.util.HashMap
		 */
		equals(obj: obj): boolean;
	}
	export module CookiePriorityComparator {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookiePriorityComparator
		 * This cookie comparator ensures that cookies with longer paths take precedence over
		 * cookies with shorter path. Among cookies with equal path length cookies with ealier
		 * creation time take precedence over cookies with later creation time
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Java.Comparator.Static {
			new(): Http.CookiePriorityComparator;
			INSTANCE?: Http.CookiePriorityComparator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.ConnectionBackoffStrategy
	 * When managing a dynamic number of connections for a given route, this
	 * strategy assesses whether a given request execution outcome should
	 * result in a backoff signal or not, based on either examining the
	 * {@code Throwable} that resulted or by examining the resulting
	 * response (e.g. for its status code).
	 *
	 * @since 4.2
	 *
	 */
	export interface ConnectionBackoffStrategy extends Java.Object {
		/**
		 * Determines whether seeing the given {@code Throwable} as
		 * a result of request execution should result in a backoff
		 * signal.
		 * @param t the {@code Throwable} that happened
		 * @return {@code true} if a backoff signal should be
		 *   given
		 */
		shouldBackoff(t: Java.Throwable): boolean;
		/**
		 * Determines whether receiving the given {@link HttpResponse} as
		 * a result of request execution should result in a backoff
		 * signal. Implementations MUST restrict themselves to examining
		 * the response header and MUST NOT consume any of the response
		 * body, if any.
		 * @param resp the {@code HttpResponse} that was received
		 * @return {@code true} if a backoff signal should be
		 *   given
		 */
		shouldBackoff(resp: Http.HttpResponse): boolean;
	}
	export module ConnectionBackoffStrategy {
		/**
		 * Corresponding Java class: org.apache.http.client.ConnectionBackoffStrategy
		 * When managing a dynamic number of connections for a given route, this
		 * strategy assesses whether a given request execution outcome should
		 * result in a backoff signal or not, based on either examining the
		 * {@code Throwable} that resulted or by examining the resulting
		 * response (e.g. for its status code).
		 *
		 * @since 4.2
		 *
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpOptions
	 * HTTP OPTIONS method.
	 * 
	 * The HTTP OPTIONS method is defined in section 9.2 of
	 * RFC2616:
	 * 
	 * 
	 *  The OPTIONS method represents a request for information about the
	 *  communication options available on the request/response chain
	 *  identified by the Request-URI. This method allows the client to
	 *  determine the options and/or requirements associated with a resource,
	 *  or the capabilities of a server, without implying a resource action
	 *  or initiating a resource retrieval.
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpOptions extends Http.HttpRequestBase {
		getAllowedMethods(response: Http.HttpResponse): Java.Set<string>;
		getMethod(): string;
	}
	export module HttpOptions {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpOptions
		 * HTTP OPTIONS method.
		 * 
		 * The HTTP OPTIONS method is defined in section 9.2 of
		 * RFC2616:
		 * 
		 * 
		 *  The OPTIONS method represents a request for information about the
		 *  communication options available on the request/response chain
		 *  identified by the Request-URI. This method allows the client to
		 *  determine the options and/or requirements associated with a resource,
		 *  or the capabilities of a server, without implying a resource action
		 *  or initiating a resource retrieval.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpRequestBase.Static {
			new(): Http.HttpOptions;
			new(uri: Java.URI): Http.HttpOptions;
			/**
			 * @throws IllegalArgumentException if the uri is invalid.
			 */
			new(uri: string): Http.HttpOptions;
			METHOD_NAME?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.params.CookieSpecParamBean
	 * This is a Java Bean class that can be used to wrap an instance of
	 * {@link HttpParams} and manipulate HTTP cookie parameters using Java Beans
	 * conventions.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use constructor parameters of {@link
	 *   org.apache.http.cookie.CookieSpecProvider}s.
	 */
	export interface CookieSpecParamBean extends Http.HttpAbstractParamBean {
	}
	export module CookieSpecParamBean {
		/**
		 * Corresponding Java class: org.apache.http.cookie.params.CookieSpecParamBean
		 * This is a Java Bean class that can be used to wrap an instance of
		 * {@link HttpParams} and manipulate HTTP cookie parameters using Java Beans
		 * conventions.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use constructor parameters of {@link
		 *   org.apache.http.cookie.CookieSpecProvider}s.
		 */
		export interface Static extends Http.HttpAbstractParamBean.Static {
			new(): Http.CookieSpecParamBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.RequestBuilder
	 * Builder for {@link HttpUriRequest} instances.
	 * 
	 * Please note that this class treats parameters differently depending on composition
	 * of the request: if the request has a content entity explicitly set with
	 * {@link #setEntity(org.apache.http.HttpEntity)} or it is not an entity enclosing method
	 * (such as POST or PUT), parameters will be added to the query component of the request URI.
	 * Otherwise, parameters will be added as a URL encoded {@link UrlEncodedFormEntity entity}.
	 * 
	 *
	 * @since 4.3
	 */
	export interface RequestBuilder extends Java.Object {
		addHeader(header: Http.Header): Http.RequestBuilder;
		addHeader(name: string, value: string): Http.RequestBuilder;
		addParameter(nvp: Http.NameValuePair): Http.RequestBuilder;
		addParameter(name: string, value: string): Http.RequestBuilder;
		addParameters(...nvps: Http.NameValuePair[]): Http.RequestBuilder;
		addParameters(nvps: array<Http.NameValuePair>): Http.RequestBuilder;
		build(): Http.HttpUriRequest;
		/**
		 * @since 4.4
		 */
		getCharset(): Java.Charset;
		getConfig(): Http.RequestConfig;
		getEntity(): Http.HttpEntity;
		getFirstHeader(name: string): Http.Header;
		getHeaders(name: string): array<Http.Header>;
		getLastHeader(name: string): Http.Header;
		getMethod(): string;
		getParameters(): Java.List<Http.NameValuePair>;
		getUri(): Java.URI;
		getVersion(): Http.ProtocolVersion;
		removeHeader(header: Http.Header): Http.RequestBuilder;
		removeHeaders(name: string): Http.RequestBuilder;
		/**
		 * @since 4.4
		 */
		setCharset(charset: Java.Charset): Http.RequestBuilder;
		setConfig(config: Http.RequestConfig): Http.RequestBuilder;
		setEntity(entity: Http.HttpEntity): Http.RequestBuilder;
		setHeader(header: Http.Header): Http.RequestBuilder;
		setHeader(name: string, value: string): Http.RequestBuilder;
		setUri(uri: Java.URI): Http.RequestBuilder;
		setUri(uri: string): Http.RequestBuilder;
		setVersion(version: Http.ProtocolVersion): Http.RequestBuilder;
	}
	export module RequestBuilder {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.RequestBuilder
		 * Builder for {@link HttpUriRequest} instances.
		 * 
		 * Please note that this class treats parameters differently depending on composition
		 * of the request: if the request has a content entity explicitly set with
		 * {@link #setEntity(org.apache.http.HttpEntity)} or it is not an entity enclosing method
		 * (such as POST or PUT), parameters will be added to the query component of the request URI.
		 * Otherwise, parameters will be added as a URL encoded {@link UrlEncodedFormEntity entity}.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			InternalRequest: RequestBuilder$InternalRequest.Static;
			InternalEntityEclosingRequest: RequestBuilder$InternalEntityEclosingRequest.Static;
			new(): Http.RequestBuilder;
			copy(request: Http.HttpRequest): Http.RequestBuilder;
			create(method: string): Http.RequestBuilder;
			delete(): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			delete(uri: Java.URI): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			delete(uri: string): Http.RequestBuilder;
			get(): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			get(uri: Java.URI): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			get(uri: string): Http.RequestBuilder;
			head(): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			head(uri: Java.URI): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			head(uri: string): Http.RequestBuilder;
			options(): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			options(uri: Java.URI): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			options(uri: string): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			patch(): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			patch(uri: Java.URI): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			patch(uri: string): Http.RequestBuilder;
			post(): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			post(uri: Java.URI): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			post(uri: string): Http.RequestBuilder;
			put(): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			put(uri: Java.URI): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			put(uri: string): Http.RequestBuilder;
			trace(): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			trace(uri: Java.URI): Http.RequestBuilder;
			/**
			 * @since 4.4
			 */
			trace(uri: string): Http.RequestBuilder;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.client.methods.RequestBuilder.InternalRequest
	 */
	export interface RequestBuilder$InternalRequest extends Http.HttpRequestBase {
		getMethod(): string;
	}
	export module RequestBuilder$InternalRequest {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.RequestBuilder.InternalRequest
		 */
		export interface Static extends Http.HttpRequestBase.Static {
			new(): Http.RequestBuilder$InternalRequest;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.client.methods.RequestBuilder.InternalEntityEclosingRequest
	 */
	export interface RequestBuilder$InternalEntityEclosingRequest extends Http.HttpEntityEnclosingRequestBase {
		getMethod(): string;
	}
	export module RequestBuilder$InternalEntityEclosingRequest {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.RequestBuilder.InternalEntityEclosingRequest
		 */
		export interface Static extends Http.HttpEntityEnclosingRequestBase.Static {
			new(): Http.RequestBuilder$InternalEntityEclosingRequest;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpExecutionAware
	 * Interface to be implemented by any object that wishes to be notified of
	 * blocking I/O operations that could be cancelled.
	 *
	 * @since 4.3
	 */
	export interface HttpExecutionAware extends Java.Object {
		isAborted(): boolean;
		/**
		 * Sets {@link Cancellable} for the ongoing operation.
		 */
		setCancellable(cancellable: Http.Cancellable): void;
	}
	export module HttpExecutionAware {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpExecutionAware
		 * Interface to be implemented by any object that wishes to be notified of
		 * blocking I/O operations that could be cancelled.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpEntityEnclosingRequestBase
	 * Basic implementation of an entity enclosing HTTP request
	 * that can be modified
	 *
	 * @since 4.0
	 */
	export interface HttpEntityEnclosingRequestBase extends Http.HttpRequestBase, Http.HttpEntityEnclosingRequest {
		clone(): obj;
		expectContinue(): boolean;
		getEntity(): Http.HttpEntity;
		setEntity(entity: Http.HttpEntity): void;
	}
	export module HttpEntityEnclosingRequestBase {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpEntityEnclosingRequestBase
		 * Basic implementation of an entity enclosing HTTP request
		 * that can be modified
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpRequestBase.Static, Http.HttpEntityEnclosingRequest.Static {
			new(): Http.HttpEntityEnclosingRequestBase;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.params.ClientPNames
	 * Parameter names for HTTP client parameters.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
	 */
	export interface ClientPNames extends Java.Object {
	}
	export module ClientPNames {
		/**
		 * Corresponding Java class: org.apache.http.client.params.ClientPNames
		 * Parameter names for HTTP client parameters.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.Punycode
	 * Facade that provides conversion between Unicode and Punycode domain names.
	 * It will use an appropriate implementation.
	 *
	 * @deprecated (4.4) use standard {@link java.net.IDN}.
	 *
	 * @since 4.0
	 */
	export interface Punycode extends Java.Object {
	}
	export module Punycode {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.Punycode
		 * Facade that provides conversion between Unicode and Punycode domain names.
		 * It will use an appropriate implementation.
		 *
		 * @deprecated (4.4) use standard {@link java.net.IDN}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.Punycode;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.URIUtils
	 * A collection of utilities for {@link URI URIs}, to workaround
	 * bugs within the class or for ease-of-use features.
	 *
	 * @since 4.0
	 */
	export interface URIUtils extends Java.Object {
	}
	export module URIUtils {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.URIUtils
		 * A collection of utilities for {@link URI URIs}, to workaround
		 * bugs within the class or for ease-of-use features.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Extracts target host from the given {@link URI}.
			 *
			 * @param uri
			 * @return the target host if the URI is absolute or {@code null} if the URI is
			 * relative or does not contain a valid host name.
			 *
			 * @since 4.1
			 */
			extractHost(uri: Java.URI): Http.HttpHost;
			/**
			 * Resolves a URI reference against a base URI. Work-around for bug in
			 * java.net.URI (http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4708535)
			 *
			 * @param baseURI the base URI
			 * @param reference the URI reference
			 * @return the resulting URI
			 */
			resolve(baseURI: Java.URI, reference: string): Java.URI;
			/**
			 * Resolves a URI reference against a base URI. Work-around for bugs in
			 * java.net.URI (e.g. http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4708535)
			 *
			 * @param baseURI the base URI
			 * @param reference the URI reference
			 * @return the resulting URI
			 */
			resolve(baseURI: Java.URI, reference: Java.URI): Java.URI;
			/**
			 * Derives the interpreted (absolute) URI that was used to generate the last
			 * request. This is done by extracting the request-uri and target origin for
			 * the last request and scanning all the redirect locations for the last
			 * fragment identifier, then combining the result into a {@link URI}.
			 *
			 * @param originalURI
			 *            original request before any redirects
			 * @param target
			 *            if the last URI is relative, it is resolved against this target,
			 *            or {@code null} if not available.
			 * @param redirects
			 *            collection of redirect locations since the original request
			 *            or {@code null} if not available.
			 * @return interpreted (absolute) URI
			 */
			resolve(originalURI: Java.URI, target: Http.HttpHost, redirects: Java.List<Java.URI>): Java.URI;
			/**
			 * A convenience method for creating a new {@link URI} whose scheme, host
			 * and port are taken from the target host, but whose path, query and
			 * fragment are taken from the existing URI. The fragment is only used if
			 * dropFragment is false. The path is set to "/" if not explicitly specified.
			 *
			 * @param uri
			 *            Contains the path, query and fragment to use.
			 * @param target
			 *            Contains the scheme, host and port to use.
			 * @param dropFragment
			 *            True if the fragment should not be copied.
			 *
			 * @throws URISyntaxException
			 *             If the resulting URI is invalid.
			 */
			rewriteURI(uri: Java.URI, target: Http.HttpHost, dropFragment: boolean): Java.URI;
			/**
			 * A convenience method for
			 * {@link URIUtils#rewriteURI(URI, HttpHost, boolean)} that always keeps the
			 * fragment.
			 */
			rewriteURI(uri: Java.URI, target: Http.HttpHost): Java.URI;
			/**
			 * A convenience method that creates a new {@link URI} whose scheme, host, port, path,
			 * query are taken from the existing URI, dropping any fragment or user-information.
			 * The path is set to "/" if not explicitly specified. The existing URI is returned
			 * unmodified if it has no fragment or user-information and has a path.
			 *
			 * @param uri
			 *            original URI.
			 * @throws URISyntaxException
			 *             If the resulting URI is invalid.
			 */
			rewriteURI(uri: Java.URI): Java.URI;
			/**
			 * A convenience method that optionally converts the original {@link java.net.URI} either
			 * to a relative or an absolute form as required by the specified route.
			 *
			 * @param uri
			 *            original URI.
			 * @throws URISyntaxException
			 *             If the resulting URI is invalid.
			 *
			 * @since 4.4
			 */
			rewriteURIForRoute(uri: Java.URI, route: Http.RouteInfo): Java.URI;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.JdkIdn
	 * Uses the java.net.IDN class through reflection.
	 *
	 * @deprecated (4.4) use standard {@link java.net.IDN}.
	 *
	 * @since 4.0
	 */
	export interface JdkIdn extends Java.Object, Http.Idn {
	}
	export module JdkIdn {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.JdkIdn
		 * Uses the java.net.IDN class through reflection.
		 *
		 * @deprecated (4.4) use standard {@link java.net.IDN}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.Idn.Static {
			new(): Http.JdkIdn;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.CloneUtils
	 * A collection of utilities to workaround limitations of Java clone framework.
	 *
	 * @since 4.0
	 */
	export interface CloneUtils extends Java.Object {
	}
	export module CloneUtils {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.CloneUtils
		 * A collection of utilities to workaround limitations of Java clone framework.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			clone(obj: obj): obj;
			/**
			 * @since 4.3
			 */
			cloneObject<T>(obj: T): T;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.DateUtils
	 * A utility class for parsing and formatting HTTP dates as used in cookies and
	 * other headers.  This class handles dates as defined by RFC 2616 section
	 * 3.3.1 as well as some other common non-standard formats.
	 *
	 * @since 4.3
	 */
	export interface DateUtils extends Java.Object {
	}
	export module DateUtils {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.DateUtils
		 * A utility class for parsing and formatting HTTP dates as used in cookies and
		 * other headers.  This class handles dates as defined by RFC 2616 section
		 * 3.3.1 as well as some other common non-standard formats.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			DateFormatHolder: DateUtils$DateFormatHolder.Static;
			/**
			 * Date format pattern used to parse HTTP date headers in RFC 1123 format.
			 */
			PATTERN_RFC1123?: string;
			/**
			 * Date format pattern used to parse HTTP date headers in RFC 1036 format.
			 */
			PATTERN_RFC1036?: string;
			/**
			 * Date format pattern used to parse HTTP date headers in ANSI C
			 * {@code asctime()} format.
			 */
			PATTERN_ASCTIME?: string;
			GMT?: Java.TimeZone;
			/**
			 * Clears thread-local variable containing {@link java.text.DateFormat} cache.
			 *
			 * @since 4.3
			 */
			clearThreadLocal(): void;
			/**
			 * Formats the given date according to the RFC 1123 pattern.
			 *
			 * @param date The date to format.
			 * @return An RFC 1123 formatted date string.
			 *
			 * @see #PATTERN_RFC1123
			 */
			formatDate(date: Java.Date): string;
			/**
			 * Formats the given date according to the specified pattern.  The pattern
			 * must conform to that used by the {@link SimpleDateFormat simple date
			 * format} class.
			 *
			 * @param date The date to format.
			 * @param pattern The pattern to use for formatting the date.
			 * @return A formatted date string.
			 *
			 * @throws IllegalArgumentException If the given date pattern is invalid.
			 *
			 * @see SimpleDateFormat
			 */
			formatDate(date: Java.Date, pattern: string): string;
			/**
			 * Parses a date value.  The formats used for parsing the date value are retrieved from
			 * the default http params.
			 *
			 * @param dateValue the date value to parse
			 *
			 * @return the parsed date or null if input could not be parsed
			 */
			parseDate(dateValue: string): Java.Date;
			/**
			 * Parses the date value using the given date formats.
			 *
			 * @param dateValue the date value to parse
			 * @param dateFormats the date formats to use
			 *
			 * @return the parsed date or null if input could not be parsed
			 */
			parseDate(dateValue: string, dateFormats: array<string>): Java.Date;
			/**
			 * Parses the date value using the given date formats.
			 *
			 * @param dateValue the date value to parse
			 * @param dateFormats the date formats to use
			 * @param startDate During parsing, two digit years will be placed in the range
			 * {@code startDate} to {@code startDate + 100 years}. This value may
			 * be {@code null}. When {@code null} is given as a parameter, year
			 * {@code 2000} will be used.
			 *
			 * @return the parsed date or null if input could not be parsed
			 */
			parseDate(dateValue: string, dateFormats: array<string>, startDate: Java.Date): Java.Date;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.client.utils.DateUtils.DateFormatHolder
	 * A factory for {@link SimpleDateFormat}s. The instances are stored in a
	 * threadlocal way because SimpleDateFormat is not threadsafe as noted in
	 * {@link SimpleDateFormat its javadoc}.
	 *
	 */
	export interface DateUtils$DateFormatHolder extends Java.Object {
	}
	export module DateUtils$DateFormatHolder {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.DateUtils.DateFormatHolder
		 * A factory for {@link SimpleDateFormat}s. The instances are stored in a
		 * threadlocal way because SimpleDateFormat is not threadsafe as noted in
		 * {@link SimpleDateFormat its javadoc}.
		 *
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.DateUtils$DateFormatHolder;
			clearThreadLocal(): void;
			/**
			 * creates a {@link SimpleDateFormat} for the requested format string.
			 *
			 * @param pattern
			 *            a non-{@code null} format String according to
			 *            {@link SimpleDateFormat}. The format is not checked against
			 *            {@code null} since all paths go through
			 *            {@link DateUtils}.
			 * @return the requested format. This simple dateformat should not be used
			 *         to {@link SimpleDateFormat#applyPattern(String) apply} to a
			 *         different pattern.
			 */
			formatFor(pattern: string): Java.SimpleDateFormat;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.Rfc3492Idn
	 * Implementation from pseudo code in RFC 3492.
	 *
	 * @deprecated (4.4) use standard {@link java.net.IDN}.
	 *
	 * @since 4.0
	 */
	export interface Rfc3492Idn extends Java.Object, Http.Idn {
	}
	export module Rfc3492Idn {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.Rfc3492Idn
		 * Implementation from pseudo code in RFC 3492.
		 *
		 * @deprecated (4.4) use standard {@link java.net.IDN}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.Idn.Static {
			new(): Http.Rfc3492Idn;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.ResponseProcessCookies
	 * Response interceptor that populates the current {@link CookieStore} with data
	 * contained in response cookies received in the given the HTTP response.
	 *
	 * @since 4.0
	 */
	export interface ResponseProcessCookies extends Java.Object, Http.HttpResponseInterceptor {
		process(response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module ResponseProcessCookies {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.ResponseProcessCookies
		 * Response interceptor that populates the current {@link CookieStore} with data
		 * contained in response cookies received in the given the HTTP response.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpResponseInterceptor.Static {
			new(): Http.ResponseProcessCookies;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.ClientContext
	 * {@link org.apache.http.protocol.HttpContext} attribute names for
	 * client side HTTP protocol processing.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link HttpClientContext}.
	 */
	export interface ClientContext extends Java.Object {
	}
	export module ClientContext {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.ClientContext
		 * {@link org.apache.http.protocol.HttpContext} attribute names for
		 * client side HTTP protocol processing.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link HttpClientContext}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.ResponseAuthCache
	 * Response interceptor that adds successfully completed {@link AuthScheme}s
	 * to the local {@link AuthCache} instance. Cached {@link AuthScheme}s can be
	 * re-used when executing requests against known hosts, thus avoiding
	 * additional authentication round-trips.
	 *
	 * @since 4.1
	 *
	 * @deprecated (4.2)  use {@link org.apache.http.client.AuthenticationStrategy}
	 */
	export interface ResponseAuthCache extends Java.Object, Http.HttpResponseInterceptor {
	}
	export module ResponseAuthCache {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.ResponseAuthCache
		 * Response interceptor that adds successfully completed {@link AuthScheme}s
		 * to the local {@link AuthCache} instance. Cached {@link AuthScheme}s can be
		 * re-used when executing requests against known hosts, thus avoiding
		 * additional authentication round-trips.
		 *
		 * @since 4.1
		 *
		 * @deprecated (4.2)  use {@link org.apache.http.client.AuthenticationStrategy}
		 */
		export interface Static extends Java.Object.Static, Http.HttpResponseInterceptor.Static {
			new(): Http.ResponseAuthCache;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.RequestProxyAuthentication
	 * Generates authentication header for the proxy host, if required,
	 * based on the actual state of the HTTP authentication context.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.impl.auth.HttpAuthenticator}.
	 */
	export interface RequestProxyAuthentication extends Http.RequestAuthenticationBase {
	}
	export module RequestProxyAuthentication {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.RequestProxyAuthentication
		 * Generates authentication header for the proxy host, if required,
		 * based on the actual state of the HTTP authentication context.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.impl.auth.HttpAuthenticator}.
		 */
		export interface Static extends Http.RequestAuthenticationBase.Static {
			new(): Http.RequestProxyAuthentication;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpPost
	 * HTTP POST method.
	 * 
	 * The HTTP POST method is defined in section 9.5 of
	 * RFC2616:
	 * 
	 * 
	 * The POST method is used to request that the origin server accept the entity
	 * enclosed in the request as a new subordinate of the resource identified by
	 * the Request-URI in the Request-Line. POST is designed to allow a uniform
	 * method to cover the following functions:
	 * 
	 *   Annotation of existing resources
	 *   Posting a message to a bulletin board, newsgroup, mailing list, or
	 *     similar group of articles
	 *   Providing a block of data, such as the result of submitting a form,
	 *     to a data-handling process
	 *   Extending a database through an append operation
	 * 
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpPost extends Http.HttpEntityEnclosingRequestBase {
		getMethod(): string;
	}
	export module HttpPost {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpPost
		 * HTTP POST method.
		 * 
		 * The HTTP POST method is defined in section 9.5 of
		 * RFC2616:
		 * 
		 * 
		 * The POST method is used to request that the origin server accept the entity
		 * enclosed in the request as a new subordinate of the resource identified by
		 * the Request-URI in the Request-Line. POST is designed to allow a uniform
		 * method to cover the following functions:
		 * 
		 *   Annotation of existing resources
		 *   Posting a message to a bulletin board, newsgroup, mailing list, or
		 *     similar group of articles
		 *   Providing a block of data, such as the result of submitting a form,
		 *     to a data-handling process
		 *   Extending a database through an append operation
		 * 
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpEntityEnclosingRequestBase.Static {
			new(): Http.HttpPost;
			new(uri: Java.URI): Http.HttpPost;
			/**
			 * @throws IllegalArgumentException if the uri is invalid.
			 */
			new(uri: string): Http.HttpPost;
			METHOD_NAME?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.BasicManagedEntity
	 * An entity that releases a {@link ManagedClientConnection connection}.
	 * A {@link ManagedClientConnection} will
	 * typically not return a managed entity, but you can replace
	 * the unmanaged entity in the response with a managed one.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) do not use.
	 */
	export interface BasicManagedEntity extends Http.HttpEntityWrapper, Http.ConnectionReleaseTrigger, Http.EofSensorWatcher {
	}
	export module BasicManagedEntity {
		/**
		 * Corresponding Java class: org.apache.http.conn.BasicManagedEntity
		 * An entity that releases a {@link ManagedClientConnection connection}.
		 * A {@link ManagedClientConnection} will
		 * typically not return a managed entity, but you can replace
		 * the unmanaged entity in the response with a managed one.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) do not use.
		 */
		export interface Static extends Http.HttpEntityWrapper.Static, Http.ConnectionReleaseTrigger.Static, Http.EofSensorWatcher.Static {
			new(): Http.BasicManagedEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ConnectionKeepAliveStrategy
	 * Interface for deciding how long a connection can remain
	 * idle before being reused.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 *
	 * @since 4.0
	 */
	export interface ConnectionKeepAliveStrategy extends Java.Object {
		/**
		 * Returns the duration of time which this connection can be safely kept
		 * idle. If the connection is left idle for longer than this period of time,
		 * it MUST not reused. A value of 0 or less may be returned to indicate that
		 * there is no suitable suggestion.
		 *
		 * When coupled with a {@link org.apache.http.ConnectionReuseStrategy}, if
		 * {@link org.apache.http.ConnectionReuseStrategy#keepAlive(
		 *   HttpResponse, HttpContext)} returns true, this allows you to control
		 * how long the reuse will last. If keepAlive returns false, this should
		 * have no meaningful impact
		 *
		 * @param response
		 *            The last response received over the connection.
		 * @param context
		 *            the context in which the connection is being used.
		 *
		 * @return the duration in ms for which it is safe to keep the connection
		 *         idle, or &lt;=0 if no suggested duration.
		 */
		getKeepAliveDuration(response: Http.HttpResponse, context: Http.HttpContext): long;
	}
	export module ConnectionKeepAliveStrategy {
		/**
		 * Corresponding Java class: org.apache.http.conn.ConnectionKeepAliveStrategy
		 * Interface for deciding how long a connection can remain
		 * idle before being reused.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.HttpClientConnectionOperator
	 * Connection operator that performs connection connect and upgrade operations. Usually, components
	 * participating in these operations are registry of {@link org.apache.http.conn.socket.ConnectionSocketFactory},
	 * {@link SchemePortResolver} and {@link DnsResolver}. In general, HTTP client user should not
	 * provide implementations of this interface, as HttpClient will use the default one that covers
	 * most of the cases needed for majority of users.
	 *
	 * @since 4.4
	 */
	export interface HttpClientConnectionOperator extends Java.Object {
		connect(conn: Http.ManagedHttpClientConnection, host: Http.HttpHost, localAddress: Java.InetSocketAddress, connectTimeout: int, socketConfig: Http.SocketConfig, context: Http.HttpContext): void;
		upgrade(conn: Http.ManagedHttpClientConnection, host: Http.HttpHost, context: Http.HttpContext): void;
	}
	export module HttpClientConnectionOperator {
		/**
		 * Corresponding Java class: org.apache.http.conn.HttpClientConnectionOperator
		 * Connection operator that performs connection connect and upgrade operations. Usually, components
		 * participating in these operations are registry of {@link org.apache.http.conn.socket.ConnectionSocketFactory},
		 * {@link SchemePortResolver} and {@link DnsResolver}. In general, HTTP client user should not
		 * provide implementations of this interface, as HttpClient will use the default one that covers
		 * most of the cases needed for majority of users.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.BasicEofSensorWatcher
	 * Basic implementation of {@link EofSensorWatcher}. The underlying connection
	 * is released on close or EOF.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) do not use.
	 */
	export interface BasicEofSensorWatcher extends Java.Object, Http.EofSensorWatcher {
	}
	export module BasicEofSensorWatcher {
		/**
		 * Corresponding Java class: org.apache.http.conn.BasicEofSensorWatcher
		 * Basic implementation of {@link EofSensorWatcher}. The underlying connection
		 * is released on close or EOF.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) do not use.
		 */
		export interface Static extends Java.Object.Static, Http.EofSensorWatcher.Static {
			new(): Http.BasicEofSensorWatcher;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.HttpClientConnectionManager
	 * Represents a manager of persistent client connections.
	 * 
	 * The purpose of an HTTP connection manager is to serve as a factory for new
	 * HTTP connections, manage persistent connections and synchronize access to
	 * persistent connections making sure that only one thread of execution can
	 * have access to a connection at a time.
	 * 
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 * 
	 *
	 * @since 4.3
	 */
	export interface HttpClientConnectionManager extends Java.Object {
		/**
		 * Closes all expired connections in the pool.
		 * 
		 * Open connections in the pool that have not been used for
		 * the timespan defined when the connection was released will be closed.
		 * Currently allocated connections are not subject to this method.
		 * Times will be checked with milliseconds precision.
		 * 
		 */
		closeExpiredConnections(): void;
		/**
		 * Closes idle connections in the pool.
		 * 
		 * Open connections in the pool that have not been used for the
		 * timespan given by the argument will be closed.
		 * Currently allocated connections are not subject to this method.
		 * Times will be checked with milliseconds precision
		 * 
		 * 
		 * All expired connections will also be closed.
		 * 
		 *
		 * @param idletime  the idle time of connections to be closed
		 * @param tunit     the unit for the {@code idletime}
		 *
		 * @see #closeExpiredConnections()
		 */
		closeIdleConnections(idletime: long, tunit: Java.TimeUnit): void;
		/**
		 * Connects the underlying connection socket to the connection target in case
		 * of a direct route or to the first proxy hop in case of a route via a proxy
		 * (or multiple proxies).
		 *
		 * @param conn the managed connection.
		 * @param route the route of the connection.
		 * @param connectTimeout connect timeout in milliseconds.
		 * @param context the actual HTTP context.
		 * @throws IOException
		 */
		connect(conn: Http.HttpClientConnection, route: Http.HttpRoute, connectTimeout: int, context: Http.HttpContext): void;
		/**
		 * Releases the connection back to the manager making it potentially
		 * re-usable by other consumers. Optionally, the maximum period
		 * of how long the manager should keep the connection alive can be
		 * defined using {@code validDuration} and {@code timeUnit}
		 * parameters.
		 *
		 * @param conn      the managed connection to release.
		 * @param validDuration the duration of time this connection is valid for reuse.
		 * @param timeUnit the time unit.
		 *
		 * @see #closeExpiredConnections()
		 */
		releaseConnection(conn: Http.HttpClientConnection, newState: obj, validDuration: long, timeUnit: Java.TimeUnit): void;
		/**
		 * Returns a new {@link ConnectionRequest}, from which a
		 * {@link HttpClientConnection} can be obtained or the request can be
		 * aborted.
		 * 
		 * Please note that newly allocated connections can be returned
		 * in the closed state. The consumer of that connection is responsible
		 * for fully establishing the route the to the connection target
		 * by calling {@link #connect(org.apache.http.HttpClientConnection,
		 *   org.apache.http.conn.routing.HttpRoute, int,
		 *   org.apache.http.protocol.HttpContext) connect} in order to connect
		 * directly to the target or to the first proxy hop, optionally calling
		 * {@link #upgrade(org.apache.http.HttpClientConnection,
		 *   org.apache.http.conn.routing.HttpRoute,
		 *   org.apache.http.protocol.HttpContext) upgrade} method to upgrade
		 * the connection after having executed {@code CONNECT} method to
		 * all intermediate proxy hops and and finally calling {@link #routeComplete(
		 *  org.apache.http.HttpClientConnection,
		 *  org.apache.http.conn.routing.HttpRoute,
		 *  org.apache.http.protocol.HttpContext) routeComplete} to mark the route
		 *  as fully completed.
		 * 
		 *
		 * @param route HTTP route of the requested connection.
		 * @param state expected state of the connection or {@code null}
		 *              if the connection is not expected to carry any state.
		 */
		requestConnection(route: Http.HttpRoute, state: obj): Http.ConnectionRequest;
		/**
		 * Marks the connection as fully established with all its intermediate
		 * hops completed.
		 *
		 * @param conn the managed connection.
		 * @param route the route of the connection.
		 * @param context the actual HTTP context.
		 * @throws IOException
		 */
		routeComplete(conn: Http.HttpClientConnection, route: Http.HttpRoute, context: Http.HttpContext): void;
		/**
		 * Shuts down this connection manager and releases allocated resources.
		 * This includes closing all connections, whether they are currently
		 * used or not.
		 */
		shutdown(): void;
		/**
		 * Upgrades the underlying connection socket to TLS/SSL (or another layering
		 * protocol) after having executed {@code CONNECT} method to all
		 * intermediate proxy hops
		 *
		 * @param conn the managed connection.
		 * @param route the route of the connection.
		 * @param context the actual HTTP context.
		 * @throws IOException
		 */
		upgrade(conn: Http.HttpClientConnection, route: Http.HttpRoute, context: Http.HttpContext): void;
	}
	export module HttpClientConnectionManager {
		/**
		 * Corresponding Java class: org.apache.http.conn.HttpClientConnectionManager
		 * Represents a manager of persistent client connections.
		 * 
		 * The purpose of an HTTP connection manager is to serve as a factory for new
		 * HTTP connections, manage persistent connections and synchronize access to
		 * persistent connections making sure that only one thread of execution can
		 * have access to a connection at a time.
		 * 
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.HttpRoutedConnection
	 * Interface to access routing information of a client side connection.
	 *
	 * @since 4.1
	 *
	 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
	 */
	export interface HttpRoutedConnection extends Http.HttpInetConnection {
	}
	export module HttpRoutedConnection {
		/**
		 * Corresponding Java class: org.apache.http.conn.HttpRoutedConnection
		 * Interface to access routing information of a client side connection.
		 *
		 * @since 4.1
		 *
		 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
		 */
		export interface Static extends Http.HttpInetConnection.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.EofSensorWatcher
	 * A watcher for {@link EofSensorInputStream}. Each stream will notify its
	 * watcher at most once.
	 *
	 * @since 4.0
	 */
	export interface EofSensorWatcher extends Java.Object {
		/**
		 * Indicates that EOF is detected.
		 *
		 * @param wrapped   the underlying stream which has reached EOF
		 *
		 * @return  {@code true} if {@code wrapped} should be closed,
		 *          {@code false} if it should be left alone
		 *
		 * @throws IOException
		 *         in case of an IO problem, for example if the watcher itself
		 *         closes the underlying stream. The caller will leave the
		 *         wrapped stream alone, as if {@code false} was returned.
		 */
		eofDetected(wrapped: Java.InputStream): boolean;
		/**
		 * Indicates that the {@link EofSensorInputStream stream} is aborted.
		 * This method will be called only if EOF was not detected
		 * before aborting. Otherwise, {@link #eofDetected eofDetected} is called.
		 * 
		 * This method will also be invoked when an input operation causes an
		 * IOException to be thrown to make sure the input stream gets shut down.
		 * 
		 *
		 * @param wrapped   the underlying stream which has not reached EOF
		 *
		 * @return  {@code true} if {@code wrapped} should be closed,
		 *          {@code false} if it should be left alone
		 *
		 * @throws IOException
		 *         in case of an IO problem, for example if the watcher itself
		 *         closes the underlying stream. The caller will leave the
		 *         wrapped stream alone, as if {@code false} was returned.
		 */
		streamAbort(wrapped: Java.InputStream): boolean;
		/**
		 * Indicates that the {@link EofSensorInputStream stream} is closed.
		 * This method will be called only if EOF was not detected
		 * before closing. Otherwise, {@link #eofDetected eofDetected} is called.
		 *
		 * @param wrapped   the underlying stream which has not reached EOF
		 *
		 * @return  {@code true} if {@code wrapped} should be closed,
		 *          {@code false} if it should be left alone
		 *
		 * @throws IOException
		 *         in case of an IO problem, for example if the watcher itself
		 *         closes the underlying stream. The caller will leave the
		 *         wrapped stream alone, as if {@code false} was returned.
		 */
		streamClosed(wrapped: Java.InputStream): boolean;
	}
	export module EofSensorWatcher {
		/**
		 * Corresponding Java class: org.apache.http.conn.EofSensorWatcher
		 * A watcher for {@link EofSensorInputStream}. Each stream will notify its
		 * watcher at most once.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ManagedHttpClientConnection
	 * Represents a managed connection whose state and life cycle is managed by
	 * a connection manager. This interface extends {@link HttpClientConnection}
	 * with methods to bind the connection to an arbitrary socket and
	 * to obtain SSL session details.
	 *
	 * @since 4.3
	 */
	export interface ManagedHttpClientConnection extends Http.HttpClientConnection, Http.HttpInetConnection {
		/**
		 * Binds this connection to the given socket. The connection
		 * is considered open if it is bound and the underlying socket
		 * is connection to a remote host.
		 *
		 * @param socket the socket to bind the connection to.
		 * @throws IOException
		 */
		bind(socket: Java.Socket): void;
		/**
		 * Returns connection ID which is expected to be unique
		 * for the life span of the connection manager.
		 */
		getId(): string;
		/**
		 * Obtains the SSL session of the underlying connection, if any.
		 * If this connection is open, and the underlying socket is an
		 * {@link javax.net.ssl.SSLSocket SSLSocket}, the SSL session of
		 * that socket is obtained. This is a potentially blocking operation.
		 *
		 * @return  the underlying SSL session if available,
		 *          {@code null} otherwise
		 */
		getSSLSession(): Java.SSLSession;
		/**
		 * Returns the underlying socket.
		 */
		getSocket(): Java.Socket;
	}
	export module ManagedHttpClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.conn.ManagedHttpClientConnection
		 * Represents a managed connection whose state and life cycle is managed by
		 * a connection manager. This interface extends {@link HttpClientConnection}
		 * with methods to bind the connection to an arbitrary socket and
		 * to obtain SSL session details.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.HttpClientConnection.Static, Http.HttpInetConnection.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.routing.BasicRouteDirector
	 * Basic {@link HttpRouteDirector} implementation.
	 *
	 * @since 4.0
	 */
	export interface BasicRouteDirector extends Java.Object, Http.HttpRouteDirector {
		/**
		 * Provides the next step.
		 *
		 * @param plan      the planned route
		 * @param fact      the currently established route, or
		 *                  {@code null} if nothing is established
		 *
		 * @return  one of the constants defined in this class, indicating
		 *          either the next step to perform, or success, or failure.
		 *          0 is for success, a negative value for failure.
		 */
		nextStep(plan: Http.RouteInfo, fact: Http.RouteInfo): int;
	}
	export module BasicRouteDirector {
		/**
		 * Corresponding Java class: org.apache.http.conn.routing.BasicRouteDirector
		 * Basic {@link HttpRouteDirector} implementation.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRouteDirector.Static {
			new(): Http.BasicRouteDirector;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.routing.RouteInfo
	 * Read-only interface for route information.
	 *
	 * @since 4.0
	 */
	export interface RouteInfo extends Java.Object {
		/**
		 * Obtains the number of hops in this route.
		 * A direct route has one hop. A route through a proxy has two hops.
		 * A route through a chain of n proxies has n+1 hops.
		 *
		 * @return  the number of hops in this route
		 */
		getHopCount(): int;
		/**
		 * Obtains the target of a hop in this route.
		 * The target of the last hop is the {@link #getTargetHost target host},
		 * the target of previous hops is the respective proxy in the chain.
		 * For a route through exactly one proxy, target of hop 0 is the proxy
		 * and target of hop 1 is the target host.
		 *
		 * @param hop       index of the hop for which to get the target,
		 *                  0 for first
		 *
		 * @return  the target of the given hop
		 *
		 * @throws IllegalArgumentException
		 *  if the argument is negative or not less than
		 *  {@link #getHopCount getHopCount()}
		 */
		getHopTarget(hop: int): Http.HttpHost;
		/**
		 * Obtains the layering type of this route.
		 * In the presence of proxies, only layering over an end-to-end tunnel
		 * is considered.
		 *
		 * @return  the layering type
		 */
		getLayerType(): Http.RouteInfo$LayerType;
		/**
		 * Obtains the local address to connect from.
		 *
		 * @return  the local address,
		 *          or {@code null}
		 */
		getLocalAddress(): Java.InetAddress;
		/**
		 * Obtains the first proxy host.
		 *
		 * @return the first proxy in the proxy chain, or
		 *         {@code null} if this route is direct
		 */
		getProxyHost(): Http.HttpHost;
		/**
		 * Obtains the target host.
		 *
		 * @return the target host
		 */
		getTargetHost(): Http.HttpHost;
		/**
		 * Obtains the tunnel type of this route.
		 * If there is a proxy chain, only end-to-end tunnels are considered.
		 *
		 * @return  the tunnelling type
		 */
		getTunnelType(): Http.RouteInfo$TunnelType;
		/**
		 * Checks whether this route includes a layered protocol.
		 * In the presence of proxies, only layering over an end-to-end tunnel
		 * is considered.
		 *
		 * @return  {@code true} if layered,
		 *          {@code false} otherwise
		 */
		isLayered(): boolean;
		/**
		 * Checks whether this route is secure.
		 *
		 * @return  {@code true} if secure,
		 *          {@code false} otherwise
		 */
		isSecure(): boolean;
		/**
		 * Checks whether this route is tunnelled through a proxy.
		 * If there is a proxy chain, only end-to-end tunnels are considered.
		 *
		 * @return  {@code true} if tunnelled end-to-end through at least
		 *          one proxy,
		 *          {@code false} otherwise
		 */
		isTunnelled(): boolean;
	}
	export module RouteInfo {
		/**
		 * Corresponding Java class: org.apache.http.conn.routing.RouteInfo
		 * Read-only interface for route information.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.conn.routing.RouteInfo.TunnelType
	 * The tunnelling type of a route.
	 * Plain routes are established by   connecting to the target or
	 * the first proxy.
	 * Tunnelled routes are established by connecting to the first proxy
	 * and tunnelling through all proxies to the target.
	 * Routes without a proxy cannot be tunnelled.
	 */
	export interface RouteInfo$TunnelType extends Java.Enum<RouteInfo$TunnelType> {
	}
	export module RouteInfo$TunnelType {
		/**
		 * Corresponding Java class: org.apache.http.conn.routing.RouteInfo.TunnelType
		 * The tunnelling type of a route.
		 * Plain routes are established by   connecting to the target or
		 * the first proxy.
		 * Tunnelled routes are established by connecting to the first proxy
		 * and tunnelling through all proxies to the target.
		 * Routes without a proxy cannot be tunnelled.
		 */
		export interface Static extends Java.Enum.Static {
			PLAIN?: Http.RouteInfo$TunnelType;
			TUNNELLED?: Http.RouteInfo$TunnelType;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.conn.routing.RouteInfo.LayerType
	 * The layering type of a route.
	 * Plain routes are established by connecting or tunnelling.
	 * Layered routes are established by layering a protocol such as TLS/SSL
	 * over an existing connection.
	 * Protocols can only be layered over a tunnel to the target, or
	 * or over a direct connection without proxies.
	 * 
	 * Layering a protocol
	 * over a direct connection makes little sense, since the connection
	 * could be established with the new protocol in the first place.
	 * But we don't want to exclude that use case.
	 * 
	 */
	export interface RouteInfo$LayerType extends Java.Enum<RouteInfo$LayerType> {
	}
	export module RouteInfo$LayerType {
		/**
		 * Corresponding Java class: org.apache.http.conn.routing.RouteInfo.LayerType
		 * The layering type of a route.
		 * Plain routes are established by connecting or tunnelling.
		 * Layered routes are established by layering a protocol such as TLS/SSL
		 * over an existing connection.
		 * Protocols can only be layered over a tunnel to the target, or
		 * or over a direct connection without proxies.
		 * 
		 * Layering a protocol
		 * over a direct connection makes little sense, since the connection
		 * could be established with the new protocol in the first place.
		 * But we don't want to exclude that use case.
		 * 
		 */
		export interface Static extends Java.Enum.Static {
			PLAIN?: Http.RouteInfo$LayerType;
			LAYERED?: Http.RouteInfo$LayerType;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.routing.HttpRouteDirector
	 * Provides directions on establishing a route.
	 * Implementations of this interface compare a planned route with
	 * a tracked route and indicate the next step required.
	 *
	 * @since 4.0
	 */
	export interface HttpRouteDirector extends Java.Object {
		/**
		 * Provides the next step.
		 *
		 * @param plan      the planned route
		 * @param fact      the currently established route, or
		 *                  {@code null} if nothing is established
		 *
		 * @return  one of the constants defined in this interface, indicating
		 *          either the next step to perform, or success, or failure.
		 *          0 is for success, a negative value for failure.
		 */
		nextStep(plan: Http.RouteInfo, fact: Http.RouteInfo): int;
	}
	export module HttpRouteDirector {
		/**
		 * Corresponding Java class: org.apache.http.conn.routing.HttpRouteDirector
		 * Provides directions on establishing a route.
		 * Implementations of this interface compare a planned route with
		 * a tracked route and indicate the next step required.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 Indicates that the route can not be established at all.
			 */
			UNREACHABLE?: int;
			/**
			 Indicates that the route is complete.
			 */
			COMPLETE?: int;
			/**
			 Step: open connection to target.
			 */
			CONNECT_TARGET?: int;
			/**
			 Step: open connection to proxy.
			 */
			CONNECT_PROXY?: int;
			/**
			 Step: tunnel through proxy to target.
			 */
			TUNNEL_TARGET?: int;
			/**
			 Step: tunnel through proxy to other proxy.
			 */
			TUNNEL_PROXY?: int;
			/**
			 Step: layer protocol (over tunnel).
			 */
			LAYER_PROTOCOL?: int;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.routing.HttpRoutePlanner
	 * Encapsulates logic to compute a {@link HttpRoute} to a target host.
	 * Implementations may for example be based on parameters, or on the
	 * standard Java system properties.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpRoutePlanner extends Java.Object {
		/**
		 * Determines the route for a request.
		 *
		 * @param target    the target host for the request.
		 *                  Implementations may accept {@code null}
		 *                  if they can still determine a route, for example
		 *                  to a default target or by inspecting the request.
		 * @param request   the request to execute
		 * @param context   the context to use for the subsequent execution.
		 *                  Implementations may accept {@code null}.
		 *
		 * @return  the route that the request should take
		 *
		 * @throws HttpException    in case of a problem
		 */
		determineRoute(target: Http.HttpHost, request: Http.HttpRequest, context: Http.HttpContext): Http.HttpRoute;
	}
	export module HttpRoutePlanner {
		/**
		 * Corresponding Java class: org.apache.http.conn.routing.HttpRoutePlanner
		 * Encapsulates logic to compute a {@link HttpRoute} to a target host.
		 * Implementations may for example be based on parameters, or on the
		 * standard Java system properties.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.routing.RouteTracker
	 * Helps tracking the steps in establishing a route.
	 *
	 * @since 4.0
	 */
	export interface RouteTracker extends Java.Object, Http.RouteInfo, Java.Cloneable {
		clone(): obj;
		/**
		 * Tracks connecting to the first proxy.
		 *
		 * @param proxy     the proxy connected to
		 * @param secure    {@code true} if the route is secure,
		 *                  {@code false} otherwise
		 */
		connectProxy(proxy: Http.HttpHost, secure: boolean): void;
		/**
		 * Tracks connecting to the target.
		 *
		 * @param secure    {@code true} if the route is secure,
		 *                  {@code false} otherwise
		 */
		connectTarget(secure: boolean): void;
		/**
		 * Compares this tracked route to another.
		 *
		 * @param o         the object to compare with
		 *
		 * @return  {@code true} if the argument is the same tracked route,
		 *          {@code false}
		 */
		equals(o: obj): boolean;
		getHopCount(): int;
		getHopTarget(hop: int): Http.HttpHost;
		getLayerType(): Http.RouteInfo$LayerType;
		getLocalAddress(): Java.InetAddress;
		getProxyHost(): Http.HttpHost;
		getTargetHost(): Http.HttpHost;
		getTunnelType(): Http.RouteInfo$TunnelType;
		/**
		 * Generates a hash code for this tracked route.
		 * Route trackers are modifiable and should therefore not be used
		 * as lookup keys. Use {@link #toRoute toRoute} to obtain an
		 * unmodifiable representation of the tracked route.
		 *
		 * @return  the hash code
		 */
		hashCode(): int;
		isConnected(): boolean;
		isLayered(): boolean;
		isSecure(): boolean;
		isTunnelled(): boolean;
		/**
		 * Tracks layering a protocol.
		 *
		 * @param secure    {@code true} if the route is secure,
		 *                  {@code false} otherwise
		 */
		layerProtocol(secure: boolean): void;
		/**
		 * @since 4.2
		 */
		reset(): void;
		/**
		 * Obtains the tracked route.
		 * If a route has been tracked, it is {@link #isConnected connected}.
		 * If not connected, nothing has been tracked so far.
		 *
		 * @return  the tracked route, or
		 *          {@code null} if nothing has been tracked so far
		 */
		toRoute(): Http.HttpRoute;
		/**
		 * Obtains a description of the tracked route.
		 *
		 * @return  a human-readable representation of the tracked route
		 */
		toString(): string;
		/**
		 * Tracks tunnelling to a proxy in a proxy chain.
		 * This will extend the tracked proxy chain, but it does not mark
		 * the route as tunnelled. Only end-to-end tunnels are considered there.
		 *
		 * @param proxy     the proxy tunnelled to
		 * @param secure    {@code true} if the route is secure,
		 *                  {@code false} otherwise
		 */
		tunnelProxy(proxy: Http.HttpHost, secure: boolean): void;
		/**
		 * Tracks tunnelling to the target.
		 *
		 * @param secure    {@code true} if the route is secure,
		 *                  {@code false} otherwise
		 */
		tunnelTarget(secure: boolean): void;
	}
	export module RouteTracker {
		/**
		 * Corresponding Java class: org.apache.http.conn.routing.RouteTracker
		 * Helps tracking the steps in establishing a route.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.RouteInfo.Static, Java.Cloneable.Static {
			/**
			 * Creates a new route tracker.
			 * The target and origin need to be specified at creation time.
			 *
			 * @param target    the host to which to route
			 * @param local     the local address to route from, or
			 *                  {@code null} for the default
			 */
			new(target: Http.HttpHost, local: Java.InetAddress): Http.RouteTracker;
			/**
			 * Creates a new tracker for the given route.
			 * Only target and origin are taken from the route,
			 * everything else remains to be tracked.
			 *
			 * @param route     the route to track
			 */
			new(route: Http.HttpRoute): Http.RouteTracker;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.SchemePortResolver
	 * Strategy for default port resolution for protocol schemes.
	 *
	 * @since 4.3
	 */
	export interface SchemePortResolver extends Java.Object {
		/**
		 * Returns the actual port for the host based on the protocol scheme.
		 */
		resolve(host: Http.HttpHost): int;
	}
	export module SchemePortResolver {
		/**
		 * Corresponding Java class: org.apache.http.conn.SchemePortResolver
		 * Strategy for default port resolution for protocol schemes.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ClientConnectionManager
	 * Management interface for {@link ManagedClientConnection client connections}.
	 * The purpose of an HTTP connection manager is to serve as a factory for new
	 * HTTP connections, manage persistent connections and synchronize access to
	 * persistent connections making sure that only one thread of execution can
	 * have access to a connection at a time.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
	 */
	export interface ClientConnectionManager extends Java.Object {
	}
	export module ClientConnectionManager {
		/**
		 * Corresponding Java class: org.apache.http.conn.ClientConnectionManager
		 * Management interface for {@link ManagedClientConnection client connections}.
		 * The purpose of an HTTP connection manager is to serve as a factory for new
		 * HTTP connections, manage persistent connections and synchronize access to
		 * persistent connections making sure that only one thread of execution can
		 * have access to a connection at a time.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.routing.HttpRoute
	 * The route for a request.
	 *
	 * @since 4.0
	 */
	export interface HttpRoute extends Java.Object, Http.RouteInfo, Java.Cloneable {
		clone(): obj;
		/**
		 * Compares this route to another.
		 *
		 * @param obj         the object to compare with
		 *
		 * @return  {@code true} if the argument is the same route,
		 *          {@code false}
		 */
		equals(obj: obj): boolean;
		getHopCount(): int;
		getHopTarget(hop: int): Http.HttpHost;
		getLayerType(): Http.RouteInfo$LayerType;
		getLocalAddress(): Java.InetAddress;
		getLocalSocketAddress(): Java.InetSocketAddress;
		getProxyHost(): Http.HttpHost;
		getTargetHost(): Http.HttpHost;
		getTunnelType(): Http.RouteInfo$TunnelType;
		/**
		 * Generates a hash code for this route.
		 *
		 * @return  the hash code
		 */
		hashCode(): int;
		isLayered(): boolean;
		isSecure(): boolean;
		isTunnelled(): boolean;
		/**
		 * Obtains a description of this route.
		 *
		 * @return  a human-readable representation of this route
		 */
		toString(): string;
	}
	export module HttpRoute {
		/**
		 * Corresponding Java class: org.apache.http.conn.routing.HttpRoute
		 * The route for a request.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.RouteInfo.Static, Java.Cloneable.Static {
			/**
			 * Creates a new route with all attributes specified explicitly.
			 *
			 * @param target    the host to which to route
			 * @param local     the local address to route from, or
			 *                  {@code null} for the default
			 * @param proxies   the proxy chain to use, or
			 *                  {@code null} for a direct route
			 * @param secure    {@code true} if the route is (to be) secure,
			 *                  {@code false} otherwise
			 * @param tunnelled the tunnel type of this route
			 * @param layered   the layering type of this route
			 */
			new(target: Http.HttpHost, local: Java.InetAddress, proxies: array<Http.HttpHost>, secure: boolean, tunnelled: Http.RouteInfo$TunnelType, layered: Http.RouteInfo$LayerType): Http.HttpRoute;
			/**
			 * Creates a new route with at most one proxy.
			 *
			 * @param target    the host to which to route
			 * @param local     the local address to route from, or
			 *                  {@code null} for the default
			 * @param proxy     the proxy to use, or
			 *                  {@code null} for a direct route
			 * @param secure    {@code true} if the route is (to be) secure,
			 *                  {@code false} otherwise
			 * @param tunnelled {@code true} if the route is (to be) tunnelled
			 *                  via the proxy,
			 *                  {@code false} otherwise
			 * @param layered   {@code true} if the route includes a
			 *                  layered protocol,
			 *                  {@code false} otherwise
			 */
			new(target: Http.HttpHost, local: Java.InetAddress, proxy: Http.HttpHost, secure: boolean, tunnelled: Http.RouteInfo$TunnelType, layered: Http.RouteInfo$LayerType): Http.HttpRoute;
			/**
			 * Creates a new direct route.
			 * That is a route without a proxy.
			 *
			 * @param target    the host to which to route
			 * @param local     the local address to route from, or
			 *                  {@code null} for the default
			 * @param secure    {@code true} if the route is (to be) secure,
			 *                  {@code false} otherwise
			 */
			new(target: Http.HttpHost, local: Java.InetAddress, secure: boolean): Http.HttpRoute;
			/**
			 * Creates a new direct insecure route.
			 *
			 * @param target    the host to which to route
			 */
			new(target: Http.HttpHost): Http.HttpRoute;
			/**
			 * Creates a new route through a proxy.
			 * When using this constructor, the {@code proxy} MUST be given.
			 * For convenience, it is assumed that a secure connection will be
			 * layered over a tunnel through the proxy.
			 *
			 * @param target    the host to which to route
			 * @param local     the local address to route from, or
			 *                  {@code null} for the default
			 * @param proxy     the proxy to use
			 * @param secure    {@code true} if the route is (to be) secure,
			 *                  {@code false} otherwise
			 */
			new(target: Http.HttpHost, local: Java.InetAddress, proxy: Http.HttpHost, secure: boolean): Http.HttpRoute;
			/**
			 * Creates a new plain route through a proxy.
			 *
			 * @param target    the host to which to route
			 * @param proxy     the proxy to use
			 *
			 * @since 4.3
			 */
			new(target: Http.HttpHost, proxy: Http.HttpHost): Http.HttpRoute;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnManagerParamBean
	 * This is a Java Bean class that can be used to wrap an instance of
	 * {@link HttpParams} and manipulate connection manager parameters
	 * using Java Beans conventions.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1) use configuration methods of the specific connection manager implementation.
	 */
	export interface ConnManagerParamBean extends Http.HttpAbstractParamBean {
	}
	export module ConnManagerParamBean {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnManagerParamBean
		 * This is a Java Bean class that can be used to wrap an instance of
		 * {@link HttpParams} and manipulate connection manager parameters
		 * using Java Beans conventions.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1) use configuration methods of the specific connection manager implementation.
		 */
		export interface Static extends Http.HttpAbstractParamBean.Static {
			new(): Http.ConnManagerParamBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnManagerPNames
	 * Parameter names for connection managers in HttpConn.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1) use configuration methods of the specific connection manager implementation.
	 */
	export interface ConnManagerPNames extends Java.Object {
	}
	export module ConnManagerPNames {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnManagerPNames
		 * Parameter names for connection managers in HttpConn.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1) use configuration methods of the specific connection manager implementation.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnConnectionParamBean
	 * This is a Java Bean class that can be used to wrap an instance of
	 * {@link HttpParams} and manipulate HTTP client connection parameters
	 * using Java Beans conventions.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1) use custom {@link
	 *   org.apache.http.impl.conn.DefaultHttpResponseParser} implementation.
	 */
	export interface ConnConnectionParamBean extends Http.HttpAbstractParamBean {
	}
	export module ConnConnectionParamBean {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnConnectionParamBean
		 * This is a Java Bean class that can be used to wrap an instance of
		 * {@link HttpParams} and manipulate HTTP client connection parameters
		 * using Java Beans conventions.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1) use custom {@link
		 *   org.apache.http.impl.conn.DefaultHttpResponseParser} implementation.
		 */
		export interface Static extends Http.HttpAbstractParamBean.Static {
			new(): Http.ConnConnectionParamBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnPerRouteBean
	 * This class maintains a map of HTTP routes to maximum number of connections allowed
	 * for those routes. This class can be used by pooling
	 * {@link org.apache.http.conn.ClientConnectionManager connection managers} for
	 * a fine-grained control of connections on a per route basis.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link org.apache.http.pool.ConnPoolControl}
	 */
	export interface ConnPerRouteBean extends Java.Object, Http.ConnPerRoute {
	}
	export module ConnPerRouteBean {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnPerRouteBean
		 * This class maintains a map of HTTP routes to maximum number of connections allowed
		 * for those routes. This class can be used by pooling
		 * {@link org.apache.http.conn.ClientConnectionManager connection managers} for
		 * a fine-grained control of connections on a per route basis.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link org.apache.http.pool.ConnPoolControl}
		 */
		export interface Static extends Java.Object.Static, Http.ConnPerRoute.Static {
			new(): Http.ConnPerRouteBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnPerRoute
	 * This interface is intended for looking up maximum number of connections
	 * allowed for a given route. This class can be used by pooling
	 * {@link org.apache.http.conn.ClientConnectionManager connection managers} for
	 * a fine-grained control of connections on a per route basis.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) no longer used.
	 */
	export interface ConnPerRoute extends Java.Object {
	}
	export module ConnPerRoute {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnPerRoute
		 * This interface is intended for looking up maximum number of connections
		 * allowed for a given route. This class can be used by pooling
		 * {@link org.apache.http.conn.ClientConnectionManager connection managers} for
		 * a fine-grained control of connections on a per route basis.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) no longer used.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnRouteParams
	 * An adaptor for manipulating HTTP routing parameters
	 * in {@link HttpParams}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
	 */
	export interface ConnRouteParams extends Java.Object, Http.ConnRoutePNames {
	}
	export module ConnRouteParams {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnRouteParams
		 * An adaptor for manipulating HTTP routing parameters
		 * in {@link HttpParams}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
		 */
		export interface Static extends Java.Object.Static, Http.ConnRoutePNames.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnRouteParamBean
	 * This is a Java Bean class that can be used to wrap an instance of
	 * {@link HttpParams} and manipulate connection routing parameters
	 * using Java Beans conventions.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
	 */
	export interface ConnRouteParamBean extends Http.HttpAbstractParamBean {
	}
	export module ConnRouteParamBean {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnRouteParamBean
		 * This is a Java Bean class that can be used to wrap an instance of
		 * {@link HttpParams} and manipulate connection routing parameters
		 * using Java Beans conventions.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
		 */
		export interface Static extends Http.HttpAbstractParamBean.Static {
			new(): Http.ConnRouteParamBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.X509HostnameVerifier
	 * Interface for checking if a hostname matches the names stored inside the
	 * server's X.509 certificate.  This interface extends
	 * {@link javax.net.ssl.HostnameVerifier}, but it is recommended to use
	 * methods added by X509HostnameVerifier.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.4) Use {@link javax.net.ssl.HostnameVerifier}.
	 */
	export interface X509HostnameVerifier extends Java.HostnameVerifier {
	}
	export module X509HostnameVerifier {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.X509HostnameVerifier
		 * Interface for checking if a hostname matches the names stored inside the
		 * server's X.509 certificate.  This interface extends
		 * {@link javax.net.ssl.HostnameVerifier}, but it is recommended to use
		 * methods added by X509HostnameVerifier.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.4) Use {@link javax.net.ssl.HostnameVerifier}.
		 */
		export interface Static extends Java.HostnameVerifier.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.AbstractVerifier
	 * Abstract base class for all standard {@link X509HostnameVerifier}
	 * implementations.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.4) use an implementation of {@link javax.net.ssl.HostnameVerifier} or
	 *  {@link DefaultHostnameVerifier}.
	 */
	export interface AbstractVerifier extends Java.Object, Http.X509HostnameVerifier {
	}
	export module AbstractVerifier {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.AbstractVerifier
		 * Abstract base class for all standard {@link X509HostnameVerifier}
		 * implementations.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.4) use an implementation of {@link javax.net.ssl.HostnameVerifier} or
		 *  {@link DefaultHostnameVerifier}.
		 */
		export interface Static extends Java.Object.Static, Http.X509HostnameVerifier.Static {
			new(): Http.AbstractVerifier;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.SubjectName
	 */
	export interface SubjectName extends Java.Object {
		getType(): int;
		getValue(): string;
		toString(): string;
	}
	export module SubjectName {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.SubjectName
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.SubjectName;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.SSLContexts
	 * {@link SSLContext} factory methods.
	 *
	 * @since 4.3
	 *
	 * @deprecated (4.4) use {@link org.apache.http.ssl.SSLContexts}.
	 */
	export interface ConnectionSSLContexts extends Java.Object {
	}
	export module ConnectionSSLContexts {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.SSLContexts
		 * {@link SSLContext} factory methods.
		 *
		 * @since 4.3
		 *
		 * @deprecated (4.4) use {@link org.apache.http.ssl.SSLContexts}.
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.ConnectionSSLContexts;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.AllowAllHostnameVerifier
	 * The ALLOW_ALL HostnameVerifier essentially turns hostname verification
	 * off. This implementation is a no-op, and never throws the SSLException.
	 *
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.4) Use {@link org.apache.http.conn.ssl.NoopHostnameVerifier}
	 */
	export interface AllowAllHostnameVerifier extends Http.AbstractVerifier {
	}
	export module AllowAllHostnameVerifier {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.AllowAllHostnameVerifier
		 * The ALLOW_ALL HostnameVerifier essentially turns hostname verification
		 * off. This implementation is a no-op, and never throws the SSLException.
		 *
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.4) Use {@link org.apache.http.conn.ssl.NoopHostnameVerifier}
		 */
		export interface Static extends Http.AbstractVerifier.Static {
			new(): Http.AllowAllHostnameVerifier;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.socket.LayeredConnectionSocketFactory
	 * Extended {@link ConnectionSocketFactory} interface for layered sockets such as SSL/TLS.
	 *
	 * @since 4.3
	 */
	export interface LayeredConnectionSocketFactory extends Http.ConnectionSocketFactory {
		/**
		 * Returns a socket connected to the given host that is layered over an
		 * existing socket.  Used primarily for creating secure sockets through
		 * proxies.
		 *
		 * @param socket the existing socket
		 * @param target the name of the target host.
		 * @param port the port to connect to on the target host.
		 * @param context the actual HTTP context.
		 *
		 * @return Socket a new socket
		 *
		 * @throws IOException if an I/O error occurs while creating the socket
		 */
		createLayeredSocket(socket: Java.Socket, target: string, port: int, context: Http.HttpContext): Java.Socket;
	}
	export module LayeredConnectionSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.socket.LayeredConnectionSocketFactory
		 * Extended {@link ConnectionSocketFactory} interface for layered sockets such as SSL/TLS.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.ConnectionSocketFactory.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ConnectionPoolTimeoutException
	 * A timeout while waiting for an available connection
	 * from a connection manager.
	 *
	 *
	 * @since 4.0
	 */
	export interface ConnectionPoolTimeoutException extends Http.ConnectTimeoutException {
	}
	export module ConnectionPoolTimeoutException {
		/**
		 * Corresponding Java class: org.apache.http.conn.ConnectionPoolTimeoutException
		 * A timeout while waiting for an available connection
		 * from a connection manager.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.ConnectTimeoutException.Static {
			/**
			 * Creates a ConnectTimeoutException with a {@code null} detail message.
			 */
			new(): Http.ConnectionPoolTimeoutException;
			/**
			 * Creates a ConnectTimeoutException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.ConnectionPoolTimeoutException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ConnectionReleaseTrigger
	 * Interface for releasing a connection. This can be implemented by various
	 * "trigger" objects which are associated with a connection, for example
	 * a {@link EofSensorInputStream} or the {@link ManagedHttpClientConnection} itself.
	 * 
	 * The methods in this interface can safely be called multiple times.
	 * The first invocation releases the connection, subsequent calls
	 * are ignored.
	 *
	 * @since 4.0
	 */
	export interface ConnectionReleaseTrigger extends Java.Object {
		/**
		 * Releases the connection without the option of keep-alive.
		 * This is a "hard" release that implies a shutdown of the connection.
		 * Use {@link #releaseConnection()} for a graceful release.
		 *
		 * @throws IOException      in case of an IO problem.
		 *         The connection will be released anyway.
		 */
		abortConnection(): void;
		/**
		 * Releases the connection with the option of keep-alive. This is a
		 * "graceful" release and may cause IO operations for consuming the
		 * remainder of a response entity. Use
		 * {@link #abortConnection abortConnection} for a hard release. The
		 * connection may be reused as specified by the duration.
		 *
		 * @throws IOException
		 *             in case of an IO problem. The connection will be released
		 *             anyway.
		 */
		releaseConnection(): void;
	}
	export module ConnectionReleaseTrigger {
		/**
		 * Corresponding Java class: org.apache.http.conn.ConnectionReleaseTrigger
		 * Interface for releasing a connection. This can be implemented by various
		 * "trigger" objects which are associated with a connection, for example
		 * a {@link EofSensorInputStream} or the {@link ManagedHttpClientConnection} itself.
		 * 
		 * The methods in this interface can safely be called multiple times.
		 * The first invocation releases the connection, subsequent calls
		 * are ignored.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ClientConnectionManagerFactory
	 * A factory for creating new {@link ClientConnectionManager} instances.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
	 */
	export interface ClientConnectionManagerFactory extends Java.Object {
	}
	export module ClientConnectionManagerFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.ClientConnectionManagerFactory
		 * A factory for creating new {@link ClientConnectionManager} instances.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.SchemeSocketFactoryAdaptor
	 * @deprecated (4.1) do not use
	 */
	export interface SchemeSocketFactoryAdaptor extends Java.Object, Http.SchemeSocketFactory {
	}
	export module SchemeSocketFactoryAdaptor {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.SchemeSocketFactoryAdaptor
		 * @deprecated (4.1) do not use
		 */
		export interface Static extends Java.Object.Static, Http.SchemeSocketFactory.Static {
			new(): Http.SchemeSocketFactoryAdaptor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.Scheme
	 * Encapsulates specifics of a protocol scheme such as "http" or "https". Schemes are identified
	 * by lowercase names. Supported schemes are typically collected in a {@link SchemeRegistry
	 * SchemeRegistry}.
	 * 
	 * For example, to configure support for "https://" URLs, you could write code like the following:
	 * 
	 * 
	 * Scheme https = new Scheme("https", 443, new MySecureSocketFactory());
	 * SchemeRegistry registry = new SchemeRegistry();
	 * registry.register(https);
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.conn.SchemePortResolver} for default port
	 * resolution and {@link org.apache.http.config.Registry} for socket factory lookups.
	 */
	export interface Scheme extends Java.Object {
	}
	export module Scheme {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.Scheme
		 * Encapsulates specifics of a protocol scheme such as "http" or "https". Schemes are identified
		 * by lowercase names. Supported schemes are typically collected in a {@link SchemeRegistry
		 * SchemeRegistry}.
		 * 
		 * For example, to configure support for "https://" URLs, you could write code like the following:
		 * 
		 * 
		 * Scheme https = new Scheme("https", 443, new MySecureSocketFactory());
		 * SchemeRegistry registry = new SchemeRegistry();
		 * registry.register(https);
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.conn.SchemePortResolver} for default port
		 * resolution and {@link org.apache.http.config.Registry} for socket factory lookups.
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.Scheme;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.LayeredSchemeSocketFactory
	 * Extended {@link SchemeSocketFactory} interface for layered sockets such as SSL/TLS.
	 *
	 * @since 4.1
	 *
	 * @deprecated (4.2)  use {@link SchemeLayeredSocketFactory}
	 */
	export interface LayeredSchemeSocketFactory extends Http.SchemeSocketFactory {
	}
	export module LayeredSchemeSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.LayeredSchemeSocketFactory
		 * Extended {@link SchemeSocketFactory} interface for layered sockets such as SSL/TLS.
		 *
		 * @since 4.1
		 *
		 * @deprecated (4.2)  use {@link SchemeLayeredSocketFactory}
		 */
		export interface Static extends Http.SchemeSocketFactory.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.UnsupportedDigestAlgorithmException
	 * Authentication credentials required to respond to a authentication
	 * challenge are invalid
	 *
	 *
	 * @since 4.0
	 */
	export interface UnsupportedDigestAlgorithmException extends Java.RuntimeException {
	}
	export module UnsupportedDigestAlgorithmException {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.UnsupportedDigestAlgorithmException
		 * Authentication credentials required to respond to a authentication
		 * challenge are invalid
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.RuntimeException.Static {
			/**
			 * Creates a new UnsupportedAuthAlgoritmException with a {@code null} detail message.
			 */
			new(): Http.UnsupportedDigestAlgorithmException;
			/**
			 * Creates a new UnsupportedAuthAlgoritmException with the specified message.
			 *
			 * @param message the exception detail message
			 */
			new(message: string): Http.UnsupportedDigestAlgorithmException;
			/**
			 * Creates a new UnsupportedAuthAlgoritmException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.UnsupportedDigestAlgorithmException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.DefaultHostnameVerifier
	 * Default {@link javax.net.ssl.HostnameVerifier} implementation.
	 *
	 * @since 4.4
	 */
	export interface DefaultHostnameVerifier extends Java.Object, Java.HostnameVerifier {
		verify(host: string, session: Java.SSLSession): boolean;
		verify(host: string, cert: Java.X509Certificate): void;
	}
	export module DefaultHostnameVerifier {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.DefaultHostnameVerifier
		 * Default {@link javax.net.ssl.HostnameVerifier} implementation.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Java.HostnameVerifier.Static {
			new(publicSuffixMatcher: Http.PublicSuffixMatcher): Http.DefaultHostnameVerifier;
			new(): Http.DefaultHostnameVerifier;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.DefaultHostnameVerifier.HostNameType
	 */
	export interface DefaultHostnameVerifier$HostNameType extends Java.Enum<DefaultHostnameVerifier$HostNameType> {
	}
	export module DefaultHostnameVerifier$HostNameType {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.DefaultHostnameVerifier.HostNameType
		 */
		export interface Static extends Java.Enum.Static {
			IPv4?: Http.DefaultHostnameVerifier$HostNameType;
			IPv6?: Http.DefaultHostnameVerifier$HostNameType;
			DNS?: Http.DefaultHostnameVerifier$HostNameType;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965DiscardAttributeHandler
	 * {@code "Discard"} cookie attribute handler for RFC 2965 cookie spec.
	 *
	 * @since 4.0
	 */
	export interface RFC2965DiscardAttributeHandler extends Java.Object, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(cookie: Http.SetCookie, commenturl: string): void;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC2965DiscardAttributeHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965DiscardAttributeHandler
		 * {@code "Discard"} cookie attribute handler for RFC 2965 cookie spec.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.RFC2965DiscardAttributeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109Spec
	 * RFC 2109 compliant {@link org.apache.http.cookie.CookieSpec} implementation.
	 * 
	 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265StrictSpec}.
	 *
	 * @since 4.0
	 * @see org.apache.http.impl.cookie.RFC6265StrictSpec
	 */
	export interface RFC2109Spec extends Http.CookieSpecBase {
		formatCookies(cookies: Java.List<Http.Cookie>): Java.List<Http.Header>;
		getVersion(): int;
		getVersionHeader(): Http.Header;
		parse(header: Http.Header, origin: Http.CookieOrigin): Java.List<Http.Cookie>;
		toString(): string;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC2109Spec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109Spec
		 * RFC 2109 compliant {@link org.apache.http.cookie.CookieSpec} implementation.
		 * 
		 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265StrictSpec}.
		 *
		 * @since 4.0
		 * @see org.apache.http.impl.cookie.RFC6265StrictSpec
		 */
		export interface Static extends Http.CookieSpecBase.Static {
			/**
			 Default constructor
			 */
			new(datepatterns: array<string>, oneHeader: boolean): Http.RFC2109Spec;
			/**
			 Default constructor
			 */
			new(): Http.RFC2109Spec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.PublicSuffixFilter
	 * Wraps a CookieAttributeHandler and leverages its match method
	 * to never match a suffix from a black list. May be used to provide
	 * additional security for cross-site attack types by preventing
	 * cookies from apparent domains that are not publicly available.
	 * An uptodate list of suffixes can be obtained from
	 * publicsuffix.org
	 *
	 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.PublicSuffixDomainFilter}
	 *
	 * @since 4.0
	 */
	export interface PublicSuffixFilter extends Java.Object, Http.CookieAttributeHandler {
	}
	export module PublicSuffixFilter {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.PublicSuffixFilter
		 * Wraps a CookieAttributeHandler and leverages its match method
		 * to never match a suffix from a black list. May be used to provide
		 * additional security for cross-site attack types by preventing
		 * cookies from apparent domains that are not publicly available.
		 * An uptodate list of suffixes can be obtained from
		 * publicsuffix.org
		 *
		 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.PublicSuffixDomainFilter}
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CookieAttributeHandler.Static {
			new(): Http.PublicSuffixFilter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BasicDomainHandler
	 *
	 * @since 4.0
	 */
	export interface BasicDomainHandler extends Java.Object, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(cookie: Http.SetCookie, value: string): void;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module BasicDomainHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BasicDomainHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.BasicDomainHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109VersionHandler
	 *
	 * @since 4.0
	 */
	export interface RFC2109VersionHandler extends Http.AbstractCookieAttributeHandler, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		parse(cookie: Http.SetCookie, value: string): void;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC2109VersionHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109VersionHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractCookieAttributeHandler.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.RFC2109VersionHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BasicMaxAgeHandler
	 *
	 * @since 4.0
	 */
	export interface BasicMaxAgeHandler extends Http.AbstractCookieAttributeHandler, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		parse(cookie: Http.SetCookie, value: string): void;
	}
	export module BasicMaxAgeHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BasicMaxAgeHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractCookieAttributeHandler.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.BasicMaxAgeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.LaxExpiresHandler
	 *
	 * @since 4.4
	 */
	export interface LaxExpiresHandler extends Http.AbstractCookieAttributeHandler, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		parse(cookie: Http.SetCookie, value: string): void;
	}
	export module LaxExpiresHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.LaxExpiresHandler
		 *
		 * @since 4.4
		 */
		export interface Static extends Http.AbstractCookieAttributeHandler.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.LaxExpiresHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965SpecFactory
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * {@link org.apache.http.impl.cookie.RFC2965Spec}. The instance returned by this factory can
	 * be shared by multiple threads.
	 *
	 * @deprecated (4.4) Use {@link org.apache.http.impl.cookie.RFC2965SpecProvider}.
	 *
	 * @since 4.0
	 */
	export interface RFC2965SpecFactory extends Java.Object, Http.CookieSpecFactory, Http.CookieSpecProvider {
	}
	export module RFC2965SpecFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965SpecFactory
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * {@link org.apache.http.impl.cookie.RFC2965Spec}. The instance returned by this factory can
		 * be shared by multiple threads.
		 *
		 * @deprecated (4.4) Use {@link org.apache.http.impl.cookie.RFC2965SpecProvider}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecFactory.Static, Http.CookieSpecProvider.Static {
			new(): Http.RFC2965SpecFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.DefaultCookieSpec
	 * Default cookie specification that picks up the best matching cookie policy based on
	 * the format of cookies sent with the HTTP response.
	 *
	 * @since 4.4
	 */
	export interface DefaultCookieSpec extends Java.Object, Http.CookieSpec {
		formatCookies(cookies: Java.List<Http.Cookie>): Java.List<Http.Header>;
		getVersion(): int;
		getVersionHeader(): Http.Header;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(header: Http.Header, origin: Http.CookieOrigin): Java.List<Http.Cookie>;
		toString(): string;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module DefaultCookieSpec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.DefaultCookieSpec
		 * Default cookie specification that picks up the best matching cookie policy based on
		 * the format of cookies sent with the HTTP response.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpec.Static {
			new(datepatterns: array<string>, oneHeader: boolean): Http.DefaultCookieSpec;
			new(): Http.DefaultCookieSpec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BrowserCompatVersionAttributeHandler
	 * {@code "Version"} cookie attribute handler for BrowserCompat cookie spec.
	 *
	 *  @deprecated (4.4) no longer used.
	 *
	 * @since 4.3
	 */
	export interface BrowserCompatVersionAttributeHandler extends Http.AbstractCookieAttributeHandler, Http.CommonCookieAttributeHandler {
	}
	export module BrowserCompatVersionAttributeHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BrowserCompatVersionAttributeHandler
		 * {@code "Version"} cookie attribute handler for BrowserCompat cookie spec.
		 *
		 *  @deprecated (4.4) no longer used.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.AbstractCookieAttributeHandler.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.BrowserCompatVersionAttributeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.IgnoreSpec
	 * CookieSpec that ignores all cookies
	 *
	 * @since 4.1
	 */
	export interface IgnoreSpec extends Http.CookieSpecBase {
		formatCookies(cookies: Java.List<Http.Cookie>): Java.List<Http.Header>;
		getVersion(): int;
		getVersionHeader(): Http.Header;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(header: Http.Header, origin: Http.CookieOrigin): Java.List<Http.Cookie>;
	}
	export module IgnoreSpec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.IgnoreSpec
		 * CookieSpec that ignores all cookies
		 *
		 * @since 4.1
		 */
		export interface Static extends Http.CookieSpecBase.Static {
			new(): Http.IgnoreSpec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BestMatchSpecFactory
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * {@link org.apache.http.impl.cookie.BestMatchSpec}. The instance returned by this factory can
	 * be shared by multiple threads.
	 *
	 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.DefaultCookieSpecProvider}.
	 *
	 * @since 4.0
	 */
	export interface BestMatchSpecFactory extends Java.Object, Http.CookieSpecFactory, Http.CookieSpecProvider {
	}
	export module BestMatchSpecFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BestMatchSpecFactory
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * {@link org.apache.http.impl.cookie.BestMatchSpec}. The instance returned by this factory can
		 * be shared by multiple threads.
		 *
		 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.DefaultCookieSpecProvider}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecFactory.Static, Http.CookieSpecProvider.Static {
			new(): Http.BestMatchSpecFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265StrictSpec
	 * Standard {@link org.apache.http.cookie.CookieSpec} implementation that enforces syntax
	 * and semantics of the well-behaved profile of the HTTP state management specification
	 * (RFC 6265, section 4).
	 *
	 * @since 4.4
	 */
	export interface RFC6265StrictSpec extends Http.RFC6265CookieSpecBase {
		toString(): string;
	}
	export module RFC6265StrictSpec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265StrictSpec
		 * Standard {@link org.apache.http.cookie.CookieSpec} implementation that enforces syntax
		 * and semantics of the well-behaved profile of the HTTP state management specification
		 * (RFC 6265, section 4).
		 *
		 * @since 4.4
		 */
		export interface Static extends Http.RFC6265CookieSpecBase.Static {
			new(): Http.RFC6265StrictSpec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.IgnoreSpecProvider
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that ignores all cookies.
	 *
	 * @since 4.4
	 */
	export interface IgnoreSpecProvider extends Java.Object, Http.CookieSpecProvider {
		create(context: Http.HttpContext): Http.CookieSpec;
	}
	export module IgnoreSpecProvider {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.IgnoreSpecProvider
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that ignores all cookies.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecProvider.Static {
			new(): Http.IgnoreSpecProvider;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BasicClientCookie2
	 * Default implementation of {@link SetCookie2}.
	 *
	 * @since 4.0
	 */
	export interface BasicClientCookie2 extends Http.BasicClientCookie, Http.SetCookie2 {
		clone(): obj;
		getCommentURL(): string;
		getPorts(): array<int>;
		isExpired(date: Java.Date): boolean;
		isPersistent(): boolean;
		setCommentURL(commentURL: string): void;
		setDiscard(discard: boolean): void;
		setPorts(ports: array<int>): void;
	}
	export module BasicClientCookie2 {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BasicClientCookie2
		 * Default implementation of {@link SetCookie2}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.BasicClientCookie.Static, Http.SetCookie2.Static {
			/**
			 * Default Constructor taking a name and a value. The value may be null.
			 *
			 * @param name The name.
			 * @param value The value.
			 */
			new(name: string, value: string): Http.BasicClientCookie2;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265CookieSpecBase
	 */
	export interface RFC6265CookieSpecBase extends Http.RFC6265CookieSpec {
	}
	export module RFC6265CookieSpecBase {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265CookieSpecBase
		 */
		export interface Static extends Http.RFC6265CookieSpec.Static {
			new(): Http.RFC6265CookieSpecBase;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965SpecProvider
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * {@link RFC2965Spec}. The instance returned by this factory can
	 * be shared by multiple threads.
	 * 
	 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265CookieSpecProvider}
	 *
	 * @since 4.4
	 * @see org.apache.http.impl.cookie.RFC6265CookieSpecProvider
	 */
	export interface RFC2965SpecProvider extends Java.Object, Http.CookieSpecProvider {
		create(context: Http.HttpContext): Http.CookieSpec;
	}
	export module RFC2965SpecProvider {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965SpecProvider
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * {@link RFC2965Spec}. The instance returned by this factory can
		 * be shared by multiple threads.
		 * 
		 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265CookieSpecProvider}
		 *
		 * @since 4.4
		 * @see org.apache.http.impl.cookie.RFC6265CookieSpecProvider
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecProvider.Static {
			new(publicSuffixMatcher: Http.PublicSuffixMatcher, oneHeader: boolean): Http.RFC2965SpecProvider;
			new(publicSuffixMatcher: Http.PublicSuffixMatcher): Http.RFC2965SpecProvider;
			new(): Http.RFC2965SpecProvider;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965DomainAttributeHandler
	 * {@code "Domain"} cookie attribute handler for RFC 2965 cookie spec.
	 *
	 *
	 * @since 3.1
	 */
	export interface RFC2965DomainAttributeHandler extends Java.Object, Http.CommonCookieAttributeHandler {
		/**
		 * Performs domain-match as defined by the RFC2965.
		 * 
		 * Host A's name domain-matches host B's if
		 * 
		 * 
		 *   their host name strings string-compare equal; or
		 *   A is a HDN string and has the form NB, where N is a non-empty
		 *       name string, B has the form .B', and B' is a HDN string.  (So,
		 *       x.y.com domain-matches .Y.com but not Y.com.)
		 * 
		 *
		 * @param host host name where cookie is received from or being sent to.
		 * @param domain The cookie domain attribute.
		 * @return true if the specified host matches the given domain.
		 */
		domainMatch(host: string, domain: string): boolean;
		getAttributeName(): string;
		/**
		 * Match cookie domain attribute.
		 */
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		/**
		 * Parse cookie domain attribute.
		 */
		parse(cookie: Http.SetCookie, domain: string): void;
		/**
		 * Validate cookie domain attribute.
		 */
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC2965DomainAttributeHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965DomainAttributeHandler
		 * {@code "Domain"} cookie attribute handler for RFC 2965 cookie spec.
		 *
		 *
		 * @since 3.1
		 */
		export interface Static extends Java.Object.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.RFC2965DomainAttributeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.IgnoreSpecFactory
	 * {@link CookieSpecProvider} implementation that ignores all cookies.
	 *
	 * @deprecated (4.4) Use {@link org.apache.http.impl.cookie.IgnoreSpecProvider}.
	 *
	 * @since 4.1
	 */
	export interface IgnoreSpecFactory extends Java.Object, Http.CookieSpecFactory, Http.CookieSpecProvider {
	}
	export module IgnoreSpecFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.IgnoreSpecFactory
		 * {@link CookieSpecProvider} implementation that ignores all cookies.
		 *
		 * @deprecated (4.4) Use {@link org.apache.http.impl.cookie.IgnoreSpecProvider}.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecFactory.Static, Http.CookieSpecProvider.Static {
			new(): Http.IgnoreSpecFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965VersionAttributeHandler
	 * {@code "Version"} cookie attribute handler for RFC 2965 cookie spec.
	 *
	 * @since 4.0
	 */
	export interface RFC2965VersionAttributeHandler extends Java.Object, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		/**
		 * Parse cookie version attribute.
		 */
		parse(cookie: Http.SetCookie, value: string): void;
		/**
		 * validate cookie version attribute. Version attribute is REQUIRED.
		 */
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC2965VersionAttributeHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965VersionAttributeHandler
		 * {@code "Version"} cookie attribute handler for RFC 2965 cookie spec.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.RFC2965VersionAttributeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BrowserCompatSpecFactory
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * {@link org.apache.http.impl.cookie.BrowserCompatSpec}. The instance returned by this factory
	 * can be shared by multiple threads.
	 *
	 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.DefaultCookieSpecProvider}.
	 *
	 * @since 4.0
	 */
	export interface BrowserCompatSpecFactory extends Java.Object, Http.CookieSpecFactory, Http.CookieSpecProvider {
	}
	export module BrowserCompatSpecFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BrowserCompatSpecFactory
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * {@link org.apache.http.impl.cookie.BrowserCompatSpec}. The instance returned by this factory
		 * can be shared by multiple threads.
		 *
		 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.DefaultCookieSpecProvider}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecFactory.Static, Http.CookieSpecProvider.Static {
			new(): Http.BrowserCompatSpecFactory;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BrowserCompatSpecFactory.SecurityLevel
	 */
	export interface BrowserCompatSpecFactory$SecurityLevel extends Java.Enum<BrowserCompatSpecFactory$SecurityLevel> {
	}
	export module BrowserCompatSpecFactory$SecurityLevel {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BrowserCompatSpecFactory.SecurityLevel
		 */
		export interface Static extends Java.Enum.Static {
			SECURITYLEVEL_DEFAULT?: Http.BrowserCompatSpecFactory$SecurityLevel;
			SECURITYLEVEL_IE_MEDIUM?: Http.BrowserCompatSpecFactory$SecurityLevel;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.CookieSpecBase
	 * Cookie management functions shared by all specification.
	 *
	 * @since 4.0
	 */
	export interface CookieSpecBase extends Http.AbstractCookieSpec {
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module CookieSpecBase {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.CookieSpecBase
		 * Cookie management functions shared by all specification.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractCookieSpec.Static {
			new(): Http.CookieSpecBase;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109SpecFactory
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * {@link org.apache.http.impl.cookie.RFC2109Spec}. The instance returned by this factory
	 * can be shared by multiple threads.
	 *
	 * @deprecated (4.4) Use {@link org.apache.http.impl.cookie.RFC2109SpecProvider}.
	 *
	 * @since 4.0
	 */
	export interface RFC2109SpecFactory extends Java.Object, Http.CookieSpecFactory, Http.CookieSpecProvider {
	}
	export module RFC2109SpecFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109SpecFactory
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * {@link org.apache.http.impl.cookie.RFC2109Spec}. The instance returned by this factory
		 * can be shared by multiple threads.
		 *
		 * @deprecated (4.4) Use {@link org.apache.http.impl.cookie.RFC2109SpecProvider}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecFactory.Static, Http.CookieSpecProvider.Static {
			new(): Http.RFC2109SpecFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.PublicSuffixListParser
	 * Parses the list from publicsuffix.org
	 * and configures a PublicSuffixFilter.
	 *
	 * @deprecated (4.4) use {@link org.apache.http.conn.util.PublicSuffixListParser}.
	 *
	 * @since 4.0
	 */
	export interface CookiePublicSuffixListParser extends Java.Object {
	}
	export module CookiePublicSuffixListParser {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.PublicSuffixListParser
		 * Parses the list from publicsuffix.org
		 * and configures a PublicSuffixFilter.
		 *
		 * @deprecated (4.4) use {@link org.apache.http.conn.util.PublicSuffixListParser}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.CookiePublicSuffixListParser;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.AbstractCookieSpec
	 * Abstract cookie specification which can delegate the job of parsing,
	 * validation or matching cookie attributes to a number of arbitrary
	 * {@link CookieAttributeHandler}s.
	 *
	 *
	 * @since 4.0
	 */
	export interface AbstractCookieSpec extends Java.Object, Http.CookieSpec {
	}
	export module AbstractCookieSpec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.AbstractCookieSpec
		 * Abstract cookie specification which can delegate the job of parsing,
		 * validation or matching cookie attributes to a number of arbitrary
		 * {@link CookieAttributeHandler}s.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpec.Static {
			/**
			 * Default constructor
			 *
			 */
			new(): Http.AbstractCookieSpec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDraftHeaderParser
	 *
	 * @since 4.0
	 */
	export interface NetscapeDraftHeaderParser extends Java.Object {
		parseHeader(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.HeaderElement;
	}
	export module NetscapeDraftHeaderParser {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDraftHeaderParser
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.NetscapeDraftHeaderParser;
			DEFAULT?: Http.NetscapeDraftHeaderParser;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965CommentUrlAttributeHandler
	 * {@code "CommentURL"} cookie attribute handler for RFC 2965 cookie spec.
	 *
	 * @since 4.0
	 */
	export interface RFC2965CommentUrlAttributeHandler extends Java.Object, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(cookie: Http.SetCookie, commenturl: string): void;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC2965CommentUrlAttributeHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965CommentUrlAttributeHandler
		 * {@code "CommentURL"} cookie attribute handler for RFC 2965 cookie spec.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.RFC2965CommentUrlAttributeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.TargetAuthenticationStrategy
	 * Default {@link org.apache.http.client.AuthenticationStrategy} implementation
	 * for proxy host authentication.
	 *
	 * @since 4.2
	 */
	export interface TargetAuthenticationStrategy extends Http.AuthenticationStrategyImpl {
	}
	export module TargetAuthenticationStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.TargetAuthenticationStrategy
		 * Default {@link org.apache.http.client.AuthenticationStrategy} implementation
		 * for proxy host authentication.
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.AuthenticationStrategyImpl.Static {
			new(): Http.TargetAuthenticationStrategy;
			INSTANCE?: Http.TargetAuthenticationStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.NoopUserTokenHandler
	 * Noop implementation of {@link UserTokenHandler} that always returns {@code null}.
	 *
	 * @since 4.3
	 */
	export interface NoopUserTokenHandler extends Java.Object, Http.UserTokenHandler {
		getUserToken(context: Http.HttpContext): obj;
	}
	export module NoopUserTokenHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.NoopUserTokenHandler
		 * Noop implementation of {@link UserTokenHandler} that always returns {@code null}.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.UserTokenHandler.Static {
			new(): Http.NoopUserTokenHandler;
			INSTANCE?: Http.NoopUserTokenHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.AuthenticationStrategyImpl
	 */
	export interface AuthenticationStrategyImpl extends Java.Object, Http.AuthenticationStrategy {
		authFailed(authhost: Http.HttpHost, authScheme: Http.AuthScheme, context: Http.HttpContext): void;
		authSucceeded(authhost: Http.HttpHost, authScheme: Http.AuthScheme, context: Http.HttpContext): void;
		/**
		 * Generates a map of challenge auth-scheme =&gt; Header entries.
		 *
		 * @return map: key=lower-cased auth-scheme name, value=Header that contains the challenge
		 */
		getChallenges(authhost: Http.HttpHost, response: Http.HttpResponse, context: Http.HttpContext): Java.Map<string, Http.Header>;
		isAuthenticationRequested(authhost: Http.HttpHost, response: Http.HttpResponse, context: Http.HttpContext): boolean;
		select(challenges: Java.Map<string, Http.Header>, authhost: Http.HttpHost, response: Http.HttpResponse, context: Http.HttpContext): Java.Queue<Http.AuthOption>;
	}
	export module AuthenticationStrategyImpl {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.AuthenticationStrategyImpl
		 */
		export interface Static extends Java.Object.Static, Http.AuthenticationStrategy.Static {
			new(): Http.AuthenticationStrategyImpl;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultRedirectStrategy
	 * Default implementation of {@link RedirectStrategy}. This strategy honors the restrictions
	 * on automatic redirection of entity enclosing methods such as POST and PUT imposed by the
	 * HTTP specification. {@code 302 Moved Temporarily}, {@code 301 Moved Permanently} and
	 * {@code 307 Temporary Redirect} status codes will result in an automatic redirect of
	 * HEAD and GET methods only. POST and PUT methods will not be automatically redirected
	 * as requiring user confirmation.
	 * 
	 * The restriction on automatic redirection of POST methods can be relaxed by using
	 * {@link LaxRedirectStrategy} instead of {@link DefaultRedirectStrategy}.
	 * 
	 *
	 * @see LaxRedirectStrategy
	 * @since 4.1
	 */
	export interface DefaultRedirectStrategy extends Java.Object, Http.RedirectStrategy {
		getLocationURI(request: Http.HttpRequest, response: Http.HttpResponse, context: Http.HttpContext): Java.URI;
		getRedirect(request: Http.HttpRequest, response: Http.HttpResponse, context: Http.HttpContext): Http.HttpUriRequest;
		isRedirected(request: Http.HttpRequest, response: Http.HttpResponse, context: Http.HttpContext): boolean;
	}
	export module DefaultRedirectStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultRedirectStrategy
		 * Default implementation of {@link RedirectStrategy}. This strategy honors the restrictions
		 * on automatic redirection of entity enclosing methods such as POST and PUT imposed by the
		 * HTTP specification. {@code 302 Moved Temporarily}, {@code 301 Moved Permanently} and
		 * {@code 307 Temporary Redirect} status codes will result in an automatic redirect of
		 * HEAD and GET methods only. POST and PUT methods will not be automatically redirected
		 * as requiring user confirmation.
		 * 
		 * The restriction on automatic redirection of POST methods can be relaxed by using
		 * {@link LaxRedirectStrategy} instead of {@link DefaultRedirectStrategy}.
		 * 
		 *
		 * @see LaxRedirectStrategy
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static, Http.RedirectStrategy.Static {
			new(): Http.DefaultRedirectStrategy;
			INSTANCE?: Http.DefaultRedirectStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BasicCommentHandler
	 *
	 * @since 4.0
	 */
	export interface BasicCommentHandler extends Http.AbstractCookieAttributeHandler, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		parse(cookie: Http.SetCookie, value: string): void;
	}
	export module BasicCommentHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BasicCommentHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractCookieAttributeHandler.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.BasicCommentHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.ProxyAuthenticationStrategy
	 * Default {@link org.apache.http.client.AuthenticationStrategy} implementation
	 * for proxy host authentication.
	 *
	 * @since 4.2
	 */
	export interface ProxyAuthenticationStrategy extends Http.AuthenticationStrategyImpl {
	}
	export module ProxyAuthenticationStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.ProxyAuthenticationStrategy
		 * Default {@link org.apache.http.client.AuthenticationStrategy} implementation
		 * for proxy host authentication.
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.AuthenticationStrategyImpl.Static {
			new(): Http.ProxyAuthenticationStrategy;
			INSTANCE?: Http.ProxyAuthenticationStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.ProtocolExec
	 * Request executor in the request execution chain that is responsible
	 * for implementation of HTTP specification requirements.
	 * Internally this executor relies on a {@link HttpProcessor} to populate
	 * requisite HTTP request headers, process HTTP response headers and update
	 * session state in {@link HttpClientContext}.
	 * 
	 * Further responsibilities such as communication with the opposite
	 * endpoint is delegated to the next executor in the request execution
	 * chain.
	 * 
	 *
	 * @since 4.3
	 */
	export interface ProtocolExec extends Java.Object, Http.ClientExecChain {
		execute(route: Http.HttpRoute, request: Http.HttpRequestWrapper, context: Http.HttpClientContext, execAware: Http.HttpExecutionAware): Http.CloseableHttpResponse;
	}
	export module ProtocolExec {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.ProtocolExec
		 * Request executor in the request execution chain that is responsible
		 * for implementation of HTTP specification requirements.
		 * Internally this executor relies on a {@link HttpProcessor} to populate
		 * requisite HTTP request headers, process HTTP response headers and update
		 * session state in {@link HttpClientContext}.
		 * 
		 * Further responsibilities such as communication with the opposite
		 * endpoint is delegated to the next executor in the request execution
		 * chain.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ClientExecChain.Static {
			new(requestExecutor: Http.ClientExecChain, httpProcessor: Http.HttpProcessor): Http.ProtocolExec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.RedirectExec
	 * Request executor in the request execution chain that is responsible
	 * for handling of request redirects.
	 * 
	 * Further responsibilities such as communication with the opposite
	 * endpoint is delegated to the next executor in the request execution
	 * chain.
	 * 
	 *
	 * @since 4.3
	 */
	export interface RedirectExec extends Java.Object, Http.ClientExecChain {
		execute(route: Http.HttpRoute, request: Http.HttpRequestWrapper, context: Http.HttpClientContext, execAware: Http.HttpExecutionAware): Http.CloseableHttpResponse;
	}
	export module RedirectExec {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.RedirectExec
		 * Request executor in the request execution chain that is responsible
		 * for handling of request redirects.
		 * 
		 * Further responsibilities such as communication with the opposite
		 * endpoint is delegated to the next executor in the request execution
		 * chain.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ClientExecChain.Static {
			new(requestExecutor: Http.ClientExecChain, routePlanner: Http.HttpRoutePlanner, redirectStrategy: Http.RedirectStrategy): Http.RedirectExec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.ConnectionHolder
	 * Internal connection holder.
	 *
	 * @since 4.3
	 */
	export interface ConnectionHolder extends Java.Object, Http.ConnectionReleaseTrigger, Http.Cancellable, Java.Closeable {
		abortConnection(): void;
		cancel(): boolean;
		close(): void;
		isReleased(): boolean;
		isReusable(): boolean;
		markNonReusable(): void;
		markReusable(): void;
		releaseConnection(): void;
		setState(state: obj): void;
		setValidFor(duration: long, tunit: Java.TimeUnit): void;
	}
	export module ConnectionHolder {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.ConnectionHolder
		 * Internal connection holder.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionReleaseTrigger.Static, Http.Cancellable.Static, Java.Closeable.Static {
			new(log: Commons.Logging.Log, manager: Http.HttpClientConnectionManager, managedConn: Http.HttpClientConnection): Http.ConnectionHolder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.RetryExec
	 * Request executor in the request execution chain that is responsible
	 * for making a decision whether a request failed due to an I/O error
	 * should be re-executed.
	 * 
	 * Further responsibilities such as communication with the opposite
	 * endpoint is delegated to the next executor in the request execution
	 * chain.
	 * 
	 *
	 * @since 4.3
	 */
	export interface RetryExec extends Java.Object, Http.ClientExecChain {
		execute(route: Http.HttpRoute, request: Http.HttpRequestWrapper, context: Http.HttpClientContext, execAware: Http.HttpExecutionAware): Http.CloseableHttpResponse;
	}
	export module RetryExec {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.RetryExec
		 * Request executor in the request execution chain that is responsible
		 * for making a decision whether a request failed due to an I/O error
		 * should be re-executed.
		 * 
		 * Further responsibilities such as communication with the opposite
		 * endpoint is delegated to the next executor in the request execution
		 * chain.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ClientExecChain.Static {
			new(requestExecutor: Http.ClientExecChain, retryHandler: Http.HttpRequestRetryHandler): Http.RetryExec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.BackoffStrategyExec
	 * @since 4.3
	 */
	export interface BackoffStrategyExec extends Java.Object, Http.ClientExecChain {
		execute(route: Http.HttpRoute, request: Http.HttpRequestWrapper, context: Http.HttpClientContext, execAware: Http.HttpExecutionAware): Http.CloseableHttpResponse;
	}
	export module BackoffStrategyExec {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.BackoffStrategyExec
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ClientExecChain.Static {
			new(requestExecutor: Http.ClientExecChain, connectionBackoffStrategy: Http.ConnectionBackoffStrategy, backoffManager: Http.BackoffManager): Http.BackoffStrategyExec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.HttpClientBuilder
	 * Builder for {@link CloseableHttpClient} instances.
	 * 
	 * When a particular component is not explicitly set this class will
	 * use its default implementation. System properties will be taken
	 * into account when configuring the default implementations when
	 * {@link #useSystemProperties()} method is called prior to calling
	 * {@link #build()}.
	 * 
	 * 
	 *  ssl.TrustManagerFactory.algorithm
	 *  javax.net.ssl.trustStoreType
	 *  javax.net.ssl.trustStore
	 *  javax.net.ssl.trustStoreProvider
	 *  javax.net.ssl.trustStorePassword
	 *  ssl.KeyManagerFactory.algorithm
	 *  javax.net.ssl.keyStoreType
	 *  javax.net.ssl.keyStore
	 *  javax.net.ssl.keyStoreProvider
	 *  javax.net.ssl.keyStorePassword
	 *  https.protocols
	 *  https.cipherSuites
	 *  http.proxyHost
	 *  http.proxyPort
	 *  https.proxyHost
	 *  https.proxyPort
	 *  http.nonProxyHosts
	 *  http.keepAlive
	 *  http.maxConnections
	 *  http.agent
	 * 
	 * 
	 * Please note that some settings used by this class can be mutually
	 * exclusive and may not apply when building {@link CloseableHttpClient}
	 * instances.
	 * 
	 *
	 * @since 4.3
	 */
	export interface HttpClientBuilder extends Java.Object {
		/**
		 * Adds this protocol interceptor to the head of the protocol processing list.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 * 
		 */
		addInterceptorFirst(itcp: Http.HttpResponseInterceptor): Http.HttpClientBuilder;
		/**
		 * Adds this protocol interceptor to the head of the protocol processing list.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		addInterceptorFirst(itcp: Http.HttpRequestInterceptor): Http.HttpClientBuilder;
		/**
		 * Adds this protocol interceptor to the tail of the protocol processing list.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 * 
		 */
		addInterceptorLast(itcp: Http.HttpResponseInterceptor): Http.HttpClientBuilder;
		/**
		 * Adds this protocol interceptor to the tail of the protocol processing list.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		addInterceptorLast(itcp: Http.HttpRequestInterceptor): Http.HttpClientBuilder;
		build(): Http.CloseableHttpClient;
		/**
		 * Disables authentication scheme caching.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		disableAuthCaching(): Http.HttpClientBuilder;
		/**
		 * Disables automatic request recovery and re-execution.
		 */
		disableAutomaticRetries(): Http.HttpClientBuilder;
		/**
		 * Disables connection state tracking.
		 */
		disableConnectionState(): Http.HttpClientBuilder;
		/**
		 * Disables automatic content decompression.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		disableContentCompression(): Http.HttpClientBuilder;
		/**
		 * Disables state (cookie) management.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		disableCookieManagement(): Http.HttpClientBuilder;
		/**
		 * Disables automatic redirect handling.
		 */
		disableRedirectHandling(): Http.HttpClientBuilder;
		/**
		 * Makes this instance of HttpClient proactively evict expired connections from the
		 * connection pool using a background thread.
		 * 
		 * One MUST explicitly close HttpClient with {@link CloseableHttpClient#close()} in order
		 * to stop and release the background thread.
		 * 
		 * Please note this method has no effect if the instance of HttpClient is configuted to
		 * use a shared connection manager.
		 * 
		 * Please note this method may not be used when the instance of HttpClient is created
		 * inside an EJB container.
		 *
		 * @see #setConnectionManagerShared(boolean)
		 * @see org.apache.http.conn.HttpClientConnectionManager#closeExpiredConnections()
		 *
		 * @since 4.4
		 */
		evictExpiredConnections(): Http.HttpClientBuilder;
		/**
		 * Makes this instance of HttpClient proactively evict idle connections from the
		 * connection pool using a background thread.
		 * 
		 * One MUST explicitly close HttpClient with {@link CloseableHttpClient#close()} in order
		 * to stop and release the background thread.
		 * 
		 * Please note this method has no effect if the instance of HttpClient is configuted to
		 * use a shared connection manager.
		 * 
		 * Please note this method may not be used when the instance of HttpClient is created
		 * inside an EJB container.
		 *
		 * @see #setConnectionManagerShared(boolean)
		 * @see org.apache.http.conn.HttpClientConnectionManager#closeExpiredConnections()
		 *
		 * @param maxIdleTime maximum time persistent connections can stay idle while kept alive
		 * in the connection pool. Connections whose inactivity period exceeds this value will
		 * get closed and evicted from the pool.
		 * @param maxIdleTimeUnit time unit for the above parameter.
		 *
		 * @since 4.4
		 */
		evictIdleConnections(maxIdleTime: long, maxIdleTimeUnit: Java.TimeUnit): Http.HttpClientBuilder;
		/**
		 * Assigns {@link BackoffManager} instance.
		 */
		setBackoffManager(backoffManager: Http.BackoffManager): Http.HttpClientBuilder;
		/**
		 * Assigns {@link ConnectionBackoffStrategy} instance.
		 */
		setConnectionBackoffStrategy(connectionBackoffStrategy: Http.ConnectionBackoffStrategy): Http.HttpClientBuilder;
		/**
		 * Assigns {@link HttpClientConnectionManager} instance.
		 */
		setConnectionManager(connManager: Http.HttpClientConnectionManager): Http.HttpClientBuilder;
		/**
		 * Defines the connection manager is to be shared by multiple
		 * client instances.
		 * 
		 * If the connection manager is shared its life-cycle is expected
		 * to be managed by the caller and it will not be shut down
		 * if the client is closed.
		 * 
		 *
		 * @param shared defines whether or not the connection manager can be shared
		 *  by multiple clients.
		 *
		 * @since 4.4
		 */
		setConnectionManagerShared(shared: boolean): Http.HttpClientBuilder;
		/**
		 * Assigns {@link ConnectionReuseStrategy} instance.
		 */
		setConnectionReuseStrategy(reuseStrategy: Http.ConnectionReuseStrategy): Http.HttpClientBuilder;
		/**
		 * Sets maximum time to live for persistent connections
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionManager(
		 *   org.apache.http.conn.HttpClientConnectionManager)} method.
		 * 
		 *
		 * @since 4.4
		 */
		setConnectionTimeToLive(connTimeToLive: long, connTimeToLiveTimeUnit: Java.TimeUnit): Http.HttpClientBuilder;
		/**
		 * Assigns a map of {@link org.apache.http.client.entity.InputStreamFactory}s
		 * to be used for automatic content decompression.
		 */
		setContentDecoderRegistry(contentDecoderMap: Java.Map<string, Http.InputStreamFactory>): Http.HttpClientBuilder;
		/**
		 * Assigns default {@link org.apache.http.auth.AuthScheme} registry which will
		 * be used for request execution if not explicitly set in the client execution
		 * context.
		 */
		setDefaultAuthSchemeRegistry(authSchemeRegistry: Http.Lookup<Http.AuthSchemeProvider>): Http.HttpClientBuilder;
		/**
		 * Assigns default {@link ConnectionConfig}.
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionManager(
		 *   org.apache.http.conn.HttpClientConnectionManager)} method.
		 * 
		 */
		setDefaultConnectionConfig(config: Http.ConnectionConfig): Http.HttpClientBuilder;
		/**
		 * Assigns default {@link org.apache.http.cookie.CookieSpec} registry which will
		 * be used for request execution if not explicitly set in the client execution
		 * context.
		 *
		 * @see org.apache.http.impl.client.CookieSpecRegistries
		 *
		 */
		setDefaultCookieSpecRegistry(cookieSpecRegistry: Http.Lookup<Http.CookieSpecProvider>): Http.HttpClientBuilder;
		/**
		 * Assigns default {@link CookieStore} instance which will be used for
		 * request execution if not explicitly set in the client execution context.
		 */
		setDefaultCookieStore(cookieStore: Http.CookieStore): Http.HttpClientBuilder;
		/**
		 * Assigns default {@link CredentialsProvider} instance which will be used
		 * for request execution if not explicitly set in the client execution
		 * context.
		 */
		setDefaultCredentialsProvider(credentialsProvider: Http.CredentialsProvider): Http.HttpClientBuilder;
		/**
		 * Assigns default request header values.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 * 
		 */
		setDefaultHeaders(defaultHeaders: Java.Collection<Http.Header>): Http.HttpClientBuilder;
		/**
		 * Assigns default {@link RequestConfig} instance which will be used
		 * for request execution if not explicitly set in the client execution
		 * context.
		 */
		setDefaultRequestConfig(config: Http.RequestConfig): Http.HttpClientBuilder;
		/**
		 * Assigns default {@link SocketConfig}.
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionManager(
		 *   org.apache.http.conn.HttpClientConnectionManager)} method.
		 * 
		 */
		setDefaultSocketConfig(config: Http.SocketConfig): Http.HttpClientBuilder;
		/**
		 * Assigns {@link DnsResolver} instance.
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionManager(HttpClientConnectionManager)} method.
		 */
		setDnsResolver(dnsResolver: Http.DnsResolver): Http.HttpClientBuilder;
		/**
		 * Assigns {@link HttpProcessor} instance.
		 */
		setHttpProcessor(httpprocessor: Http.HttpProcessor): Http.HttpClientBuilder;
		/**
		 * Assigns {@link ConnectionKeepAliveStrategy} instance.
		 */
		setKeepAliveStrategy(keepAliveStrategy: Http.ConnectionKeepAliveStrategy): Http.HttpClientBuilder;
		/**
		 * Assigns maximum connection per route value.
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionManager(
		 *   org.apache.http.conn.HttpClientConnectionManager)} method.
		 * 
		 */
		setMaxConnPerRoute(maxConnPerRoute: int): Http.HttpClientBuilder;
		/**
		 * Assigns maximum total connection value.
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionManager(
		 *   org.apache.http.conn.HttpClientConnectionManager)} method.
		 * 
		 */
		setMaxConnTotal(maxConnTotal: int): Http.HttpClientBuilder;
		/**
		 * Assigns default proxy value.
		 * 
		 * Please note this value can be overridden by the {@link #setRoutePlanner(
		 *   org.apache.http.conn.routing.HttpRoutePlanner)} method.
		 */
		setProxy(proxy: Http.HttpHost): Http.HttpClientBuilder;
		/**
		 * Assigns {@link AuthenticationStrategy} instance for proxy
		 * authentication.
		 */
		setProxyAuthenticationStrategy(proxyAuthStrategy: Http.AuthenticationStrategy): Http.HttpClientBuilder;
		/**
		 * Assigns file containing public suffix matcher. Instances of this class can be created
		 * with {@link org.apache.http.conn.util.PublicSuffixMatcherLoader}.
		 *
		 * @see org.apache.http.conn.util.PublicSuffixMatcher
		 * @see org.apache.http.conn.util.PublicSuffixMatcherLoader
		 *
		 *   @since 4.4
		 */
		setPublicSuffixMatcher(publicSuffixMatcher: Http.PublicSuffixMatcher): Http.HttpClientBuilder;
		/**
		 * Assigns {@link RedirectStrategy} instance.
		 * 
		 * Please note this value can be overridden by the {@link #disableRedirectHandling()}
		 * method.
		 * 
		 `
		 */
		setRedirectStrategy(redirectStrategy: Http.RedirectStrategy): Http.HttpClientBuilder;
		/**
		 * Assigns {@link HttpRequestExecutor} instance.
		 */
		setRequestExecutor(requestExec: Http.HttpRequestExecutor): Http.HttpClientBuilder;
		/**
		 * Assigns {@link HttpRequestRetryHandler} instance.
		 * 
		 * Please note this value can be overridden by the {@link #disableAutomaticRetries()}
		 * method.
		 */
		setRetryHandler(retryHandler: Http.HttpRequestRetryHandler): Http.HttpClientBuilder;
		/**
		 * Assigns {@link HttpRoutePlanner} instance.
		 */
		setRoutePlanner(routePlanner: Http.HttpRoutePlanner): Http.HttpClientBuilder;
		/**
		 * Assigns {@link SSLContext} instance.
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionManager(
		 *   org.apache.http.conn.HttpClientConnectionManager)} and the {@link #setSSLSocketFactory(
		 *   org.apache.http.conn.socket.LayeredConnectionSocketFactory)} methods.
		 * 
		 */
		setSSLContext(sslContext: Java.SSLContext): Http.HttpClientBuilder;
		/**
		 * Assigns {@link javax.net.ssl.HostnameVerifier} instance.
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionManager(
		 *   org.apache.http.conn.HttpClientConnectionManager)} and the {@link #setSSLSocketFactory(
		 *   org.apache.http.conn.socket.LayeredConnectionSocketFactory)} methods.
		 * 
		 *
		 *   @since 4.4
		 */
		setSSLHostnameVerifier(hostnameVerifier: Java.HostnameVerifier): Http.HttpClientBuilder;
		/**
		 * Assigns {@link LayeredConnectionSocketFactory} instance.
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionManager(
		 *   org.apache.http.conn.HttpClientConnectionManager)} method.
		 * 
		 */
		setSSLSocketFactory(sslSocketFactory: Http.LayeredConnectionSocketFactory): Http.HttpClientBuilder;
		/**
		 * Assigns {@link SchemePortResolver} instance.
		 */
		setSchemePortResolver(schemePortResolver: Http.SchemePortResolver): Http.HttpClientBuilder;
		/**
		 * Assigns {@link ServiceUnavailableRetryStrategy} instance.
		 */
		setServiceUnavailableRetryStrategy(serviceUnavailStrategy: Http.ServiceUnavailableRetryStrategy): Http.HttpClientBuilder;
		/**
		 * Assigns {@link AuthenticationStrategy} instance for target
		 * host authentication.
		 */
		setTargetAuthenticationStrategy(targetAuthStrategy: Http.AuthenticationStrategy): Http.HttpClientBuilder;
		/**
		 * Assigns {@code User-Agent} value.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 * 
		 */
		setUserAgent(userAgent: string): Http.HttpClientBuilder;
		/**
		 * Assigns {@link UserTokenHandler} instance.
		 * 
		 * Please note this value can be overridden by the {@link #disableConnectionState()}
		 * method.
		 * 
		 */
		setUserTokenHandler(userTokenHandler: Http.UserTokenHandler): Http.HttpClientBuilder;
		/**
		 * Use system properties when creating and configuring default
		 * implementations.
		 */
		useSystemProperties(): Http.HttpClientBuilder;
	}
	export module HttpClientBuilder {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.HttpClientBuilder
		 * Builder for {@link CloseableHttpClient} instances.
		 * 
		 * When a particular component is not explicitly set this class will
		 * use its default implementation. System properties will be taken
		 * into account when configuring the default implementations when
		 * {@link #useSystemProperties()} method is called prior to calling
		 * {@link #build()}.
		 * 
		 * 
		 *  ssl.TrustManagerFactory.algorithm
		 *  javax.net.ssl.trustStoreType
		 *  javax.net.ssl.trustStore
		 *  javax.net.ssl.trustStoreProvider
		 *  javax.net.ssl.trustStorePassword
		 *  ssl.KeyManagerFactory.algorithm
		 *  javax.net.ssl.keyStoreType
		 *  javax.net.ssl.keyStore
		 *  javax.net.ssl.keyStoreProvider
		 *  javax.net.ssl.keyStorePassword
		 *  https.protocols
		 *  https.cipherSuites
		 *  http.proxyHost
		 *  http.proxyPort
		 *  https.proxyHost
		 *  https.proxyPort
		 *  http.nonProxyHosts
		 *  http.keepAlive
		 *  http.maxConnections
		 *  http.agent
		 * 
		 * 
		 * Please note that some settings used by this class can be mutually
		 * exclusive and may not apply when building {@link CloseableHttpClient}
		 * instances.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.HttpClientBuilder;
			create(): Http.HttpClientBuilder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.Wire
	 * Logs data to the wire LOG.
	 * TODO: make package private. Should not be part of the public API.
	 *
	 * @since 4.0
	 */
	export interface Wire extends Java.Object {
		enabled(): boolean;
		input(instream: Java.InputStream): void;
		input(b: array<byte>, off: int, len: int): void;
		input(b: array<byte>): void;
		input(b: int): void;
		input(s: string): void;
		output(outstream: Java.InputStream): void;
		output(b: array<byte>, off: int, len: int): void;
		output(b: array<byte>): void;
		output(b: int): void;
		output(s: string): void;
	}
	export module Wire {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.Wire
		 * Logs data to the wire LOG.
		 * TODO: make package private. Should not be part of the public API.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * @since 4.3
			 */
			new(log: Commons.Logging.Log, id: string): Http.Wire;
			new(log: Commons.Logging.Log): Http.Wire;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.IdleConnectionHandler
	 * A helper class for connection managers to track idle connections.
	 *
	 * This class is not synchronized.
	 *
	 * @see org.apache.http.conn.ClientConnectionManager#closeIdleConnections
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1)  no longer used
	 */
	export interface IdleConnectionHandler extends Java.Object {
	}
	export module IdleConnectionHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.IdleConnectionHandler
		 * A helper class for connection managers to track idle connections.
		 *
		 * This class is not synchronized.
		 *
		 * @see org.apache.http.conn.ClientConnectionManager#closeIdleConnections
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1)  no longer used
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.IdleConnectionHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.ManagedHttpClientConnectionFactory
	 * Factory for {@link ManagedHttpClientConnection} instances.
	 * @since 4.3
	 */
	export interface ManagedHttpClientConnectionFactory extends Java.Object, Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection> {
		create(route: Http.HttpRoute, config: Http.ConnectionConfig): Http.ManagedHttpClientConnection;
	}
	export module ManagedHttpClientConnectionFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.ManagedHttpClientConnectionFactory
		 * Factory for {@link ManagedHttpClientConnection} instances.
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionHttpConnectionFactory.Static {
			/**
			 * @since 4.4
			 */
			new(requestWriterFactory: Http.HttpMessageWriterFactory<Http.HttpRequest>, responseParserFactory: Http.HttpMessageParserFactory<Http.HttpResponse>, incomingContentStrategy: Http.ContentLengthStrategy, outgoingContentStrategy: Http.ContentLengthStrategy): Http.ManagedHttpClientConnectionFactory;
			new(requestWriterFactory: Http.HttpMessageWriterFactory<Http.HttpRequest>, responseParserFactory: Http.HttpMessageParserFactory<Http.HttpResponse>): Http.ManagedHttpClientConnectionFactory;
			new(responseParserFactory: Http.HttpMessageParserFactory<Http.HttpResponse>): Http.ManagedHttpClientConnectionFactory;
			new(): Http.ManagedHttpClientConnectionFactory;
			INSTANCE?: Http.ManagedHttpClientConnectionFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.PoolingClientConnectionManager
	 * Manages a pool of {@link org.apache.http.conn.OperatedClientConnection}
	 * and is able to service connection requests from multiple execution threads.
	 * Connections are pooled on a per route basis. A request for a route which
	 * already the manager has persistent connections for available in the pool
	 * will be services by leasing a connection from the pool rather than
	 * creating a brand new connection.
	 * 
	 * PoolingConnectionManager maintains a maximum limit of connection on
	 * a per route basis and in total. Per default this implementation will
	 * create no more than than 2 concurrent connections per given route
	 * and no more 20 connections in total. For many real-world applications
	 * these limits may prove too constraining, especially if they use HTTP
	 * as a transport protocol for their services. Connection limits, however,
	 * can be adjusted using HTTP parameters.
	 *
	 * @since 4.2
	 *
	 * @deprecated (4.3) use {@link PoolingHttpClientConnectionManager}.
	 */
	export interface PoolingClientConnectionManager extends Java.Object, Http.ClientConnectionManager, Http.ConnPoolControl<Http.HttpRoute> {
	}
	export module PoolingClientConnectionManager {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.PoolingClientConnectionManager
		 * Manages a pool of {@link org.apache.http.conn.OperatedClientConnection}
		 * and is able to service connection requests from multiple execution threads.
		 * Connections are pooled on a per route basis. A request for a route which
		 * already the manager has persistent connections for available in the pool
		 * will be services by leasing a connection from the pool rather than
		 * creating a brand new connection.
		 * 
		 * PoolingConnectionManager maintains a maximum limit of connection on
		 * a per route basis and in total. Per default this implementation will
		 * create no more than than 2 concurrent connections per given route
		 * and no more 20 connections in total. For many real-world applications
		 * these limits may prove too constraining, especially if they use HTTP
		 * as a transport protocol for their services. Connection limits, however,
		 * can be adjusted using HTTP parameters.
		 *
		 * @since 4.2
		 *
		 * @deprecated (4.3) use {@link PoolingHttpClientConnectionManager}.
		 */
		export interface Static extends Java.Object.Static, Http.ClientConnectionManager.Static, Http.ConnPoolControl.Static {
			new(): Http.PoolingClientConnectionManager;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.LoggingInputStream
	 * Internal class.
	 *
	 * @since 4.3
	 */
	export interface LoggingInputStream extends Java.InputStream {
		available(): int;
		close(): void;
		mark(readlimit: int): void;
		markSupported(): boolean;
		read(): int;
		read(b: array<byte>): int;
		read(b: array<byte>, off: int, len: int): int;
		reset(): void;
		skip(n: long): long;
	}
	export module LoggingInputStream {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.LoggingInputStream
		 * Internal class.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.InputStream.Static {
			new(in_: Java.InputStream, wire: Http.Wire): Http.LoggingInputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.SystemDefaultRoutePlanner
	 * {@link org.apache.http.conn.routing.HttpRoutePlanner} implementation
	 * based on {@link ProxySelector}. By default, this class will pick up
	 * the proxy settings of the JVM, either from system properties
	 * or from the browser running the application.
	 *
	 * @since 4.3
	 */
	export interface SystemDefaultRoutePlanner extends Http.DefaultRoutePlanner {
	}
	export module SystemDefaultRoutePlanner {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.SystemDefaultRoutePlanner
		 * {@link org.apache.http.conn.routing.HttpRoutePlanner} implementation
		 * based on {@link ProxySelector}. By default, this class will pick up
		 * the proxy settings of the JVM, either from system properties
		 * or from the browser running the application.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.DefaultRoutePlanner.Static {
			/**
			 * @param proxySelector the proxy selector, or {@code null} for the system default
			 */
			new(schemePortResolver: Http.SchemePortResolver, proxySelector: Java.ProxySelector): Http.SystemDefaultRoutePlanner;
			/**
			 * @param proxySelector the proxy selector, or {@code null} for the system default
			 */
			new(proxySelector: Java.ProxySelector): Http.SystemDefaultRoutePlanner;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.PoolEntryRequest
	 * Encapsulates a request for a {@link BasicPoolEntry}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link java.util.concurrent.Future}
	 */
	export interface PoolEntryRequest extends Java.Object {
	}
	export module PoolEntryRequest {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.PoolEntryRequest
		 * Encapsulates a request for a {@link BasicPoolEntry}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link java.util.concurrent.Future}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager
	 * Manages a pool of {@link org.apache.http.conn.OperatedClientConnection }
	 * and is able to service connection requests from multiple execution threads.
	 * Connections are pooled on a per route basis. A request for a route which
	 * already the manager has persistent connections for available in the pool
	 * will be services by leasing a connection from the pool rather than
	 * creating a brand new connection.
	 * 
	 * ThreadSafeClientConnManager maintains a maximum limit of connection on
	 * a per route basis and in total. Per default this implementation will
	 * create no more than than 2 concurrent connections per given route
	 * and no more 20 connections in total. For many real-world applications
	 * these limits may prove too constraining, especially if they use HTTP
	 * as a transport protocol for their services. Connection limits, however,
	 * can be adjusted using HTTP parameters.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link org.apache.http.impl.conn.PoolingHttpClientConnectionManager}
	 */
	export interface ThreadSafeClientConnManager extends Java.Object, Http.ClientConnectionManager {
	}
	export module ThreadSafeClientConnManager {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager
		 * Manages a pool of {@link org.apache.http.conn.OperatedClientConnection }
		 * and is able to service connection requests from multiple execution threads.
		 * Connections are pooled on a per route basis. A request for a route which
		 * already the manager has persistent connections for available in the pool
		 * will be services by leasing a connection from the pool rather than
		 * creating a brand new connection.
		 * 
		 * ThreadSafeClientConnManager maintains a maximum limit of connection on
		 * a per route basis and in total. Per default this implementation will
		 * create no more than than 2 concurrent connections per given route
		 * and no more 20 connections in total. For many real-world applications
		 * these limits may prove too constraining, especially if they use HTTP
		 * as a transport protocol for their services. Connection limits, however,
		 * can be adjusted using HTTP parameters.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link org.apache.http.impl.conn.PoolingHttpClientConnectionManager}
		 */
		export interface Static extends Java.Object.Static, Http.ClientConnectionManager.Static {
			new(): Http.ThreadSafeClientConnManager;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.WaitingThreadAborter
	 * A simple class that can interrupt a {@link WaitingThread}.
	 *
	 * Must be called with the pool lock held.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  do not use
	 */
	export interface WaitingThreadAborter extends Java.Object {
	}
	export module WaitingThreadAborter {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.WaitingThreadAborter
		 * A simple class that can interrupt a {@link WaitingThread}.
		 *
		 * Must be called with the pool lock held.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  do not use
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.WaitingThreadAborter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.BasicPoolEntryRef
	 * A weak reference to a {@link BasicPoolEntry BasicPoolEntry}.
	 * This reference explicitly keeps the planned route, so the connection
	 * can be reclaimed if it is lost to garbage collection.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  do not use
	 */
	export interface BasicPoolEntryRef extends Java.WeakReference<Http.ConnectionBasicPoolEntry> {
	}
	export module BasicPoolEntryRef {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.BasicPoolEntryRef
		 * A weak reference to a {@link BasicPoolEntry BasicPoolEntry}.
		 * This reference explicitly keeps the planned route, so the connection
		 * can be reclaimed if it is lost to garbage collection.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  do not use
		 */
		export interface Static extends Java.WeakReference.Static {
			new(): Http.BasicPoolEntryRef;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.BasicPoolEntry
	 * Basic implementation of a connection pool entry.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link org.apache.http.pool.PoolEntry}
	 */
	export interface ConnectionBasicPoolEntry extends Http.AbstractPoolEntry {
	}
	export module ConnectionBasicPoolEntry {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.BasicPoolEntry
		 * Basic implementation of a connection pool entry.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link org.apache.http.pool.PoolEntry}
		 */
		export interface Static extends Http.AbstractPoolEntry.Static {
			new(): Http.ConnectionBasicPoolEntry;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.AbstractPoolEntry
	 * A pool entry for use by connection manager implementations.
	 * Pool entries work in conjunction with an
	 * {@link AbstractClientConnAdapter adapter}.
	 * The adapter is handed out to applications that obtain a connection.
	 * The pool entry stores the underlying connection and tracks the
	 * {@link HttpRoute route} established.
	 * The adapter delegates methods for establishing the route to
	 * its pool entry.
	 * 
	 * If the managed connections is released or revoked, the adapter
	 * gets disconnected, but the pool entry still contains the
	 * underlying connection and the established route.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  do not use
	 */
	export interface AbstractPoolEntry extends Java.Object {
	}
	export module AbstractPoolEntry {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.AbstractPoolEntry
		 * A pool entry for use by connection manager implementations.
		 * Pool entries work in conjunction with an
		 * {@link AbstractClientConnAdapter adapter}.
		 * The adapter is handed out to applications that obtain a connection.
		 * The pool entry stores the underlying connection and tracks the
		 * {@link HttpRoute route} established.
		 * The adapter delegates methods for establishing the route to
		 * its pool entry.
		 * 
		 * If the managed connections is released or revoked, the adapter
		 * gets disconnected, but the pool entry still contains the
		 * underlying connection and the established route.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  do not use
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.AbstractPoolEntry;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.LoggingManagedHttpClientConnection
	 */
	export interface LoggingManagedHttpClientConnection extends Http.DefaultManagedHttpClientConnection {
		close(): void;
		setSocketTimeout(timeout: int): void;
		shutdown(): void;
	}
	export module LoggingManagedHttpClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.LoggingManagedHttpClientConnection
		 */
		export interface Static extends Http.DefaultManagedHttpClientConnection.Static {
			new(id: string, log: Commons.Logging.Log, headerlog: Commons.Logging.Log, wirelog: Commons.Logging.Log, buffersize: int, fragmentSizeHint: int, chardecoder: Java.CharsetDecoder, charencoder: Java.CharsetEncoder, constraints: Http.MessageConstraints, incomingContentStrategy: Http.ContentLengthStrategy, outgoingContentStrategy: Http.ContentLengthStrategy, requestWriterFactory: Http.HttpMessageWriterFactory<Http.HttpRequest>, responseParserFactory: Http.HttpMessageParserFactory<Http.HttpResponse>): Http.LoggingManagedHttpClientConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultSchemePortResolver
	 * Default {@link SchemePortResolver}.
	 *
	 * @since 4.3
	 */
	export interface DefaultSchemePortResolver extends Java.Object, Http.SchemePortResolver {
		resolve(host: Http.HttpHost): int;
	}
	export module DefaultSchemePortResolver {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultSchemePortResolver
		 * Default {@link SchemePortResolver}.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.SchemePortResolver.Static {
			new(): Http.DefaultSchemePortResolver;
			INSTANCE?: Http.DefaultSchemePortResolver;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.SingleClientConnManager
	 * A connection manager for a single connection. This connection manager
	 * maintains only one active connection at a time. Even though this class
	 * is thread-safe it ought to be used by one execution thread only.
	 * 
	 * SingleClientConnManager will make an effort to reuse the connection
	 * for subsequent requests with the same {@link HttpRoute route}.
	 * It will, however, close the existing connection and open it
	 * for the given route, if the route of the persistent connection does
	 * not match that of the connection request. If the connection has been
	 * already been allocated {@link IllegalStateException} is thrown.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link BasicClientConnectionManager}
	 */
	export interface SingleClientConnManager extends Java.Object, Http.ClientConnectionManager {
	}
	export module SingleClientConnManager {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.SingleClientConnManager
		 * A connection manager for a single connection. This connection manager
		 * maintains only one active connection at a time. Even though this class
		 * is thread-safe it ought to be used by one execution thread only.
		 * 
		 * SingleClientConnManager will make an effort to reuse the connection
		 * for subsequent requests with the same {@link HttpRoute route}.
		 * It will, however, close the existing connection and open it
		 * for the given route, if the route of the persistent connection does
		 * not match that of the connection request. If the connection has been
		 * already been allocated {@link IllegalStateException} is thrown.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link BasicClientConnectionManager}
		 */
		export interface Static extends Java.Object.Static, Http.ClientConnectionManager.Static {
			new(): Http.SingleClientConnManager;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.conn.SingleClientConnManager.PoolEntry
	 * The pool entry for this connection manager.
	 */
	export interface SingleClientConnManager$PoolEntry extends Http.AbstractPoolEntry {
	}
	export module SingleClientConnManager$PoolEntry {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.SingleClientConnManager.PoolEntry
		 * The pool entry for this connection manager.
		 */
		export interface Static extends Http.AbstractPoolEntry.Static {
			new(): Http.SingleClientConnManager$PoolEntry;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.conn.SingleClientConnManager.ConnAdapter
	 * The connection adapter used by this manager.
	 */
	export interface SingleClientConnManager$ConnAdapter extends Http.AbstractPooledConnAdapter {
	}
	export module SingleClientConnManager$ConnAdapter {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.SingleClientConnManager.ConnAdapter
		 * The connection adapter used by this manager.
		 */
		export interface Static extends Http.AbstractPooledConnAdapter.Static {
			new(): Http.SingleClientConnManager$ConnAdapter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.BasicClientConnectionManager
	 * A connection manager for a single connection. This connection manager maintains only one active
	 * connection. Even though this class is fully thread-safe it ought to be used by one execution
	 * thread only, as only one thread a time can lease the connection at a time.
	 * 
	 * This connection manager will make an effort to reuse the connection for subsequent requests
	 * with the same {@link HttpRoute route}. It will, however, close the existing connection and
	 * open it for the given route, if the route of the persistent connection does not match that
	 * of the connection request. If the connection has been already been allocated
	 * {@link IllegalStateException} is thrown.
	 * 
	 * 
	 * This connection manager implementation should be used inside an EJB container instead of
	 * {@link PoolingClientConnectionManager}.
	 * 
	 *
	 * @since 4.2
	 *
	 * @deprecated (4.3) use {@link BasicHttpClientConnectionManager}.
	 */
	export interface BasicClientConnectionManager extends Java.Object, Http.ClientConnectionManager {
	}
	export module BasicClientConnectionManager {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.BasicClientConnectionManager
		 * A connection manager for a single connection. This connection manager maintains only one active
		 * connection. Even though this class is fully thread-safe it ought to be used by one execution
		 * thread only, as only one thread a time can lease the connection at a time.
		 * 
		 * This connection manager will make an effort to reuse the connection for subsequent requests
		 * with the same {@link HttpRoute route}. It will, however, close the existing connection and
		 * open it for the given route, if the route of the persistent connection does not match that
		 * of the connection request. If the connection has been already been allocated
		 * {@link IllegalStateException} is thrown.
		 * 
		 * 
		 * This connection manager implementation should be used inside an EJB container instead of
		 * {@link PoolingClientConnectionManager}.
		 * 
		 *
		 * @since 4.2
		 *
		 * @deprecated (4.3) use {@link BasicHttpClientConnectionManager}.
		 */
		export interface Static extends Java.Object.Static, Http.ClientConnectionManager.Static {
			new(): Http.BasicClientConnectionManager;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.ChallengeState
	 * Challenge mode (TARGET or PROXY)
	 *
	 * @since 4.2
	 */
	export interface ChallengeState extends Java.Enum<ChallengeState> {
	}
	export module ChallengeState {
		/**
		 * Corresponding Java class: org.apache.http.auth.ChallengeState
		 * Challenge mode (TARGET or PROXY)
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Enum.Static {
			TARGET?: Http.ChallengeState;
			PROXY?: Http.ChallengeState;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.InvalidCredentialsException
	 * Authentication credentials required to respond to a authentication
	 * challenge are invalid
	 *
	 *
	 * @since 4.0
	 */
	export interface InvalidCredentialsException extends Http.AuthenticationException {
	}
	export module InvalidCredentialsException {
		/**
		 * Corresponding Java class: org.apache.http.auth.InvalidCredentialsException
		 * Authentication credentials required to respond to a authentication
		 * challenge are invalid
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AuthenticationException.Static {
			/**
			 * Creates a new InvalidCredentialsException with a {@code null} detail message.
			 */
			new(): Http.InvalidCredentialsException;
			/**
			 * Creates a new InvalidCredentialsException with the specified message.
			 *
			 * @param message the exception detail message
			 */
			new(message: string): Http.InvalidCredentialsException;
			/**
			 * Creates a new InvalidCredentialsException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.InvalidCredentialsException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AuthenticationException
	 * Signals a failure in authentication process
	 *
	 *
	 * @since 4.0
	 */
	export interface AuthenticationException extends Http.ProtocolException {
	}
	export module AuthenticationException {
		/**
		 * Corresponding Java class: org.apache.http.auth.AuthenticationException
		 * Signals a failure in authentication process
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.ProtocolException.Static {
			/**
			 * Creates a new AuthenticationException with a {@code null} detail message.
			 */
			new(): Http.AuthenticationException;
			/**
			 * Creates a new AuthenticationException with the specified message.
			 *
			 * @param message the exception detail message
			 */
			new(message: string): Http.AuthenticationException;
			/**
			 * Creates a new AuthenticationException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.AuthenticationException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AUTH
	 * Constants and static helpers related to the HTTP authentication.
	 *
	 *
	 * @since 4.0
	 */
	export interface AUTH extends Java.Object {
	}
	export module AUTH {
		/**
		 * Corresponding Java class: org.apache.http.auth.AUTH
		 * Constants and static helpers related to the HTTP authentication.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * The www authenticate challange header.
			 */
			WWW_AUTH?: string;
			/**
			 * The www authenticate response header.
			 */
			WWW_AUTH_RESP?: string;
			/**
			 * The proxy authenticate challange header.
			 */
			PROXY_AUTH?: string;
			/**
			 * The proxy authenticate response header.
			 */
			PROXY_AUTH_RESP?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.MalformedChallengeException
	 * Signals that authentication challenge is in some way invalid or
	 * illegal in the given context
	 *
	 *
	 * @since 4.0
	 */
	export interface MalformedChallengeException extends Http.ProtocolException {
	}
	export module MalformedChallengeException {
		/**
		 * Corresponding Java class: org.apache.http.auth.MalformedChallengeException
		 * Signals that authentication challenge is in some way invalid or
		 * illegal in the given context
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.ProtocolException.Static {
			/**
			 * Creates a new MalformedChallengeException with a {@code null} detail message.
			 */
			new(): Http.MalformedChallengeException;
			/**
			 * Creates a new MalformedChallengeException with the specified message.
			 *
			 * @param message the exception detail message
			 */
			new(message: string): Http.MalformedChallengeException;
			/**
			 * Creates a new MalformedChallengeException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.MalformedChallengeException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.cookie.CookieSpecFactory
	 * Factory for {@link CookieSpec} implementations.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link CookieSpecProvider}
	 */
	export interface CookieSpecFactory extends Java.Object {
	}
	export module CookieSpecFactory {
		/**
		 * Corresponding Java class: org.apache.http.cookie.CookieSpecFactory
		 * Factory for {@link CookieSpec} implementations.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link CookieSpecProvider}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.HttpClient
	 * This interface represents only the most basic contract for HTTP request
	 * execution. It imposes no restrictions or particular details on the request
	 * execution process and leaves the specifics of state management,
	 * authentication and redirect handling up to individual implementations.
	 *
	 * @since 4.0
	 */
	export interface HttpClient extends Java.Object {
		/**
		 * Executes HTTP request using the default context.
		 *
		 * @param request   the request to execute
		 *
		 * @return  the response to the request. This is always a final response,
		 *          never an intermediate response with an 1xx status code.
		 *          Whether redirects or authentication challenges will be returned
		 *          or handled automatically depends on the implementation and
		 *          configuration of this client.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute(request: Http.HttpUriRequest): Http.HttpResponse;
		/**
		 * Executes HTTP request using the given context.
		 *
		 * @param request   the request to execute
		 * @param context   the context to use for the execution, or
		 *                  {@code null} to use the default context
		 *
		 * @return  the response to the request. This is always a final response,
		 *          never an intermediate response with an 1xx status code.
		 *          Whether redirects or authentication challenges will be returned
		 *          or handled automatically depends on the implementation and
		 *          configuration of this client.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute(request: Http.HttpUriRequest, context: Http.HttpContext): Http.HttpResponse;
		/**
		 * Executes HTTP request using the default context.
		 *
		 * @param target    the target host for the request.
		 *                  Implementations may accept {@code null}
		 *                  if they can still determine a route, for example
		 *                  to a default target or by inspecting the request.
		 * @param request   the request to execute
		 *
		 * @return  the response to the request. This is always a final response,
		 *          never an intermediate response with an 1xx status code.
		 *          Whether redirects or authentication challenges will be returned
		 *          or handled automatically depends on the implementation and
		 *          configuration of this client.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute(target: Http.HttpHost, request: Http.HttpRequest): Http.HttpResponse;
		/**
		 * Executes HTTP request using the given context.
		 *
		 * @param target    the target host for the request.
		 *                  Implementations may accept {@code null}
		 *                  if they can still determine a route, for example
		 *                  to a default target or by inspecting the request.
		 * @param request   the request to execute
		 * @param context   the context to use for the execution, or
		 *                  {@code null} to use the default context
		 *
		 * @return  the response to the request. This is always a final response,
		 *          never an intermediate response with an 1xx status code.
		 *          Whether redirects or authentication challenges will be returned
		 *          or handled automatically depends on the implementation and
		 *          configuration of this client.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute(target: Http.HttpHost, request: Http.HttpRequest, context: Http.HttpContext): Http.HttpResponse;
		/**
		 * Executes HTTP request using the default context and processes the
		 * response using the given response handler.
		 * 
		 * Implementing classes are required to ensure that the content entity
		 * associated with the response is fully consumed and the underlying
		 * connection is released back to the connection manager automatically
		 * in all cases relieving individual {@link ResponseHandler}s from
		 * having to manage resource deallocation internally.
		 * 
		 *
		 * @param request   the request to execute
		 * @param responseHandler the response handler
		 *
		 * @return  the response object as generated by the response handler.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute<T>(request: Http.HttpUriRequest, responseHandler: Http.ResponseHandler<T>): T;
		/**
		 * Executes HTTP request using the given context and processes the
		 * response using the given response handler.
		 * 
		 * Implementing classes are required to ensure that the content entity
		 * associated with the response is fully consumed and the underlying
		 * connection is released back to the connection manager automatically
		 * in all cases relieving individual {@link ResponseHandler}s from
		 * having to manage resource deallocation internally.
		 * 
		 *
		 * @param request   the request to execute
		 * @param responseHandler the response handler
		 * @param context   the context to use for the execution, or
		 *                  {@code null} to use the default context
		 *
		 * @return  the response object as generated by the response handler.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute<T>(request: Http.HttpUriRequest, responseHandler: Http.ResponseHandler<T>, context: Http.HttpContext): T;
		/**
		 * Executes HTTP request to the target using the default context and
		 * processes the response using the given response handler.
		 * 
		 * Implementing classes are required to ensure that the content entity
		 * associated with the response is fully consumed and the underlying
		 * connection is released back to the connection manager automatically
		 * in all cases relieving individual {@link ResponseHandler}s from
		 * having to manage resource deallocation internally.
		 * 
		 *
		 * @param target    the target host for the request.
		 *                  Implementations may accept {@code null}
		 *                  if they can still determine a route, for example
		 *                  to a default target or by inspecting the request.
		 * @param request   the request to execute
		 * @param responseHandler the response handler
		 *
		 * @return  the response object as generated by the response handler.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute<T>(target: Http.HttpHost, request: Http.HttpRequest, responseHandler: Http.ResponseHandler<T>): T;
		/**
		 * Executes HTTP request to the target using the given context and
		 * processes the response using the given response handler.
		 * 
		 * Implementing classes are required to ensure that the content entity
		 * associated with the response is fully consumed and the underlying
		 * connection is released back to the connection manager automatically
		 * in all cases relieving individual {@link ResponseHandler}s from
		 * having to manage resource deallocation internally.
		 * 
		 *
		 * @param target    the target host for the request.
		 *                  Implementations may accept {@code null}
		 *                  if they can still determine a route, for example
		 *                  to a default target or by inspecting the request.
		 * @param request   the request to execute
		 * @param responseHandler the response handler
		 * @param context   the context to use for the execution, or
		 *                  {@code null} to use the default context
		 *
		 * @return  the response object as generated by the response handler.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute<T>(target: Http.HttpHost, request: Http.HttpRequest, responseHandler: Http.ResponseHandler<T>, context: Http.HttpContext): T;
	}
	export module HttpClient {
		/**
		 * Corresponding Java class: org.apache.http.client.HttpClient
		 * This interface represents only the most basic contract for HTTP request
		 * execution. It imposes no restrictions or particular details on the request
		 * execution process and leaves the specifics of state management,
		 * authentication and redirect handling up to individual implementations.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.CloseableHttpResponse
	 * Extended version of the {@link HttpResponse} interface that also extends {@link Closeable}.
	 *
	 * @since 4.3
	 */
	export interface CloseableHttpResponse extends Http.HttpResponse, Java.Closeable {
	}
	export module CloseableHttpResponse {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.CloseableHttpResponse
		 * Extended version of the {@link HttpResponse} interface that also extends {@link Closeable}.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.HttpResponse.Static, Java.Closeable.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.AbstractExecutionAwareRequest
	 */
	export interface AbstractExecutionAwareRequest extends Http.AbstractHttpMessage, Http.HttpExecutionAware, Http.AbortableHttpRequest, Java.Cloneable, Http.HttpRequest {
		abort(): void;
		clone(): obj;
		/**
		 * @since 4.2
		 */
		completed(): void;
		isAborted(): boolean;
		/**
		 * Resets internal state of the request making it reusable.
		 *
		 * @since 4.2
		 */
		reset(): void;
		/**
		 * @since 4.2
		 */
		setCancellable(cancellable: Http.Cancellable): void;
	}
	export module AbstractExecutionAwareRequest {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.AbstractExecutionAwareRequest
		 */
		export interface Static extends Http.AbstractHttpMessage.Static, Http.HttpExecutionAware.Static, Http.AbortableHttpRequest.Static, Java.Cloneable.Static, Http.HttpRequest.Static {
			new(): Http.AbstractExecutionAwareRequest;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpTrace
	 * HTTP TRACE method.
	 * 
	 * The HTTP TRACE method is defined in section 9.6 of
	 * RFC2616:
	 * 
	 * 
	 *  The TRACE method is used to invoke a remote, application-layer loop-
	 *  back of the request message. The final recipient of the request
	 *  SHOULD reflect the message received back to the client as the
	 *  entity-body of a 200 (OK) response. The final recipient is either the
	 *  origin server or the first proxy or gateway to receive a Max-Forwards
	 *  value of zero (0) in the request (see section 14.31). A TRACE request
	 *  MUST NOT include an entity.
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpTrace extends Http.HttpRequestBase {
		getMethod(): string;
	}
	export module HttpTrace {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpTrace
		 * HTTP TRACE method.
		 * 
		 * The HTTP TRACE method is defined in section 9.6 of
		 * RFC2616:
		 * 
		 * 
		 *  The TRACE method is used to invoke a remote, application-layer loop-
		 *  back of the request message. The final recipient of the request
		 *  SHOULD reflect the message received back to the client as the
		 *  entity-body of a 200 (OK) response. The final recipient is either the
		 *  origin server or the first proxy or gateway to receive a Max-Forwards
		 *  value of zero (0) in the request (see section 14.31). A TRACE request
		 *  MUST NOT include an entity.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpRequestBase.Static {
			new(): Http.HttpTrace;
			new(uri: Java.URI): Http.HttpTrace;
			/**
			 * @throws IllegalArgumentException if the uri is invalid.
			 */
			new(uri: string): Http.HttpTrace;
			METHOD_NAME?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.CookieStore
	 * This interface represents an abstract store for {@link Cookie}
	 * objects.
	 *
	 * @since 4.0
	 */
	export interface CookieStore extends Java.Object {
		/**
		 * Adds an {@link Cookie}, replacing any existing equivalent cookies.
		 * If the given cookie has already expired it will not be added, but existing
		 * values will still be removed.
		 *
		 * @param cookie the {@link Cookie cookie} to be added
		 */
		addCookie(cookie: Http.Cookie): void;
		/**
		 * Clears all cookies.
		 */
		clear(): void;
		/**
		 * Removes all of {@link Cookie}s in this store that have expired by
		 * the specified {@link java.util.Date}.
		 *
		 * @return true if any cookies were purged.
		 */
		clearExpired(date: Java.Date): boolean;
		/**
		 * Returns all cookies contained in this store.
		 *
		 * @return all cookies
		 */
		getCookies(): Java.List<Http.Cookie>;
	}
	export module CookieStore {
		/**
		 * Corresponding Java class: org.apache.http.client.CookieStore
		 * This interface represents an abstract store for {@link Cookie}
		 * objects.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.HttpResponseException
	 * Signals a non 2xx HTTP response.
	 *
	 * @since 4.0
	 */
	export interface HttpResponseException extends Http.ClientProtocolException {
		getStatusCode(): int;
	}
	export module HttpResponseException {
		/**
		 * Corresponding Java class: org.apache.http.client.HttpResponseException
		 * Signals a non 2xx HTTP response.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.ClientProtocolException.Static {
			new(statusCode: int, s: string): Http.HttpResponseException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.ClientProtocolException
	 * Signals an error in the HTTP protocol.
	 *
	 * @since 4.0
	 */
	export interface ClientProtocolException extends Java.IOException {
	}
	export module ClientProtocolException {
		/**
		 * Corresponding Java class: org.apache.http.client.ClientProtocolException
		 * Signals an error in the HTTP protocol.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.IOException.Static {
			new(): Http.ClientProtocolException;
			new(s: string): Http.ClientProtocolException;
			new(cause: Java.Throwable): Http.ClientProtocolException;
			new(message: string, cause: Java.Throwable): Http.ClientProtocolException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.AuthenticationHandler
	 /**
	 * A handler for determining if an HTTP response represents an authentication
	 * challenge that was sent back to the client as a result of authentication
	 * failure.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link AuthenticationStrategy}
	 */
	export interface AuthenticationHandler extends Java.Object {
	}
	export module AuthenticationHandler {
		/**
		 * Corresponding Java class: org.apache.http.client.AuthenticationHandler
		 /**
		 * A handler for determining if an HTTP response represents an authentication
		 * challenge that was sent back to the client as a result of authentication
		 * failure.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link AuthenticationStrategy}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.params.CookiePolicy
	 * Standard cookie specifications supported by HttpClient.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.CookieSpecs}.
	 */
	export interface CookiePolicy extends Java.Object {
	}
	export module CookiePolicy {
		/**
		 * Corresponding Java class: org.apache.http.client.params.CookiePolicy
		 * Standard cookie specifications supported by HttpClient.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.CookieSpecs}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.CircularRedirectException
	 * Signals a circular redirect
	 *
	 *
	 * @since 4.0
	 */
	export interface CircularRedirectException extends Http.RedirectException {
	}
	export module CircularRedirectException {
		/**
		 * Corresponding Java class: org.apache.http.client.CircularRedirectException
		 * Signals a circular redirect
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.RedirectException.Static {
			/**
			 * Creates a new CircularRedirectException with a {@code null} detail message.
			 */
			new(): Http.CircularRedirectException;
			/**
			 * Creates a new CircularRedirectException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.CircularRedirectException;
			/**
			 * Creates a new CircularRedirectException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.CircularRedirectException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.URIBuilder
	 * Builder for {@link URI} instances.
	 *
	 * @since 4.2
	 */
	export interface URIBuilder extends Java.Object {
		/**
		 * Adds parameter to URI query. The parameter name and value are expected to be unescaped
		 * and may contain non ASCII characters.
		 * 
		 * Please note query parameters and custom query component are mutually exclusive. This method
		 * will remove custom query if present.
		 * 
		 */
		addParameter(param: string, value: string): Http.URIBuilder;
		/**
		 * Adds URI query parameters. The parameter name / values are expected to be unescaped
		 * and may contain non ASCII characters.
		 * 
		 * Please note query parameters and custom query component are mutually exclusive. This method
		 * will remove custom query if present.
		 * 
		 *
		 * @since 4.3
		 */
		addParameters(nvps: Java.List<Http.NameValuePair>): Http.URIBuilder;
		/**
		 * Builds a {@link URI} instance.
		 */
		build(): Java.URI;
		/**
		 * Clears URI query parameters.
		 *
		 * @since 4.3
		 */
		clearParameters(): Http.URIBuilder;
		/**
		 * @since 4.4
		 */
		getCharset(): Java.Charset;
		getFragment(): string;
		getHost(): string;
		getPath(): string;
		getPort(): int;
		getQueryParams(): Java.List<Http.NameValuePair>;
		getScheme(): string;
		getUserInfo(): string;
		/**
		 * @since 4.3
		 */
		isAbsolute(): boolean;
		/**
		 * @since 4.3
		 */
		isOpaque(): boolean;
		/**
		 * Removes URI query.
		 */
		removeQuery(): Http.URIBuilder;
		/**
		 * @since 4.4
		 */
		setCharset(charset: Java.Charset): Http.URIBuilder;
		/**
		 * Sets custom URI query. The value is expected to be unescaped and may contain non ASCII
		 * characters.
		 * 
		 * Please note query parameters and custom query component are mutually exclusive. This method
		 * will remove query parameters if present.
		 * 
		 *
		 * @since 4.3
		 */
		setCustomQuery(query: string): Http.URIBuilder;
		/**
		 * Sets URI fragment. The value is expected to be unescaped and may contain non ASCII
		 * characters.
		 */
		setFragment(fragment: string): Http.URIBuilder;
		/**
		 * Sets URI host.
		 */
		setHost(host: string): Http.URIBuilder;
		/**
		 * Sets parameter of URI query overriding existing value if set. The parameter name and value
		 * are expected to be unescaped and may contain non ASCII characters.
		 * 
		 * Please note query parameters and custom query component are mutually exclusive. This method
		 * will remove custom query if present.
		 * 
		 */
		setParameter(param: string, value: string): Http.URIBuilder;
		/**
		 * Sets URI query parameters. The parameter name / values are expected to be unescaped
		 * and may contain non ASCII characters.
		 * 
		 * Please note query parameters and custom query component are mutually exclusive. This method
		 * will remove custom query if present.
		 * 
		 *
		 * @since 4.3
		 */
		setParameters(nvps: Java.List<Http.NameValuePair>): Http.URIBuilder;
		/**
		 * Sets URI query parameters. The parameter name / values are expected to be unescaped
		 * and may contain non ASCII characters.
		 * 
		 * Please note query parameters and custom query component are mutually exclusive. This method
		 * will remove custom query if present.
		 * 
		 *
		 * @since 4.3
		 */
		setParameters(...nvps: Http.NameValuePair[]): Http.URIBuilder;
		/**
		 * Sets URI query parameters. The parameter name / values are expected to be unescaped
		 * and may contain non ASCII characters.
		 * 
		 * Please note query parameters and custom query component are mutually exclusive. This method
		 * will remove custom query if present.
		 * 
		 *
		 * @since 4.3
		 */
		setParameters(nvps: array<Http.NameValuePair>): Http.URIBuilder;
		/**
		 * Sets URI path. The value is expected to be unescaped and may contain non ASCII characters.
		 */
		setPath(path: string): Http.URIBuilder;
		/**
		 * Sets URI port.
		 */
		setPort(port: int): Http.URIBuilder;
		/**
		 * Sets URI scheme.
		 */
		setScheme(scheme: string): Http.URIBuilder;
		/**
		 * Sets URI user info. The value is expected to be unescaped and may contain non ASCII
		 * characters.
		 */
		setUserInfo(userInfo: string): Http.URIBuilder;
		/**
		 * Sets URI user info as a combination of username and password. These values are expected to
		 * be unescaped and may contain non ASCII characters.
		 */
		setUserInfo(username: string, password: string): Http.URIBuilder;
		toString(): string;
	}
	export module URIBuilder {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.URIBuilder
		 * Builder for {@link URI} instances.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Constructs an empty instance.
			 */
			new(): Http.URIBuilder;
			/**
			 * Construct an instance from the string which must be a valid URI.
			 *
			 * @param string a valid URI in string form
			 * @throws URISyntaxException if the input is not a valid URI
			 */
			new(string: string): Http.URIBuilder;
			/**
			 * Construct an instance from the provided URI.
			 * @param uri
			 */
			new(uri: Java.URI): Http.URIBuilder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.AuthCache
	 * Abstract {@link AuthScheme} cache. Initialized {@link AuthScheme} objects
	 * from this cache can be used to preemptively authenticate against known
	 * hosts.
	 *
	 * @since 4.1
	 */
	export interface AuthCache extends Java.Object {
		clear(): void;
		get(host: Http.HttpHost): Http.AuthScheme;
		put(host: Http.HttpHost, authScheme: Http.AuthScheme): void;
		remove(host: Http.HttpHost): void;
	}
	export module AuthCache {
		/**
		 * Corresponding Java class: org.apache.http.client.AuthCache
		 * Abstract {@link AuthScheme} cache. Initialized {@link AuthScheme} objects
		 * from this cache can be used to preemptively authenticate against known
		 * hosts.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.RedirectHandler
	 * A handler for determining if an HTTP request should be redirected to
	 * a new location in response to an HTTP response received from the target
	 * server.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1)  use {@link RedirectStrategy}
	 */
	export interface RedirectHandler extends Java.Object {
	}
	export module RedirectHandler {
		/**
		 * Corresponding Java class: org.apache.http.client.RedirectHandler
		 * A handler for determining if an HTTP request should be redirected to
		 * a new location in response to an HTTP response received from the target
		 * server.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1)  use {@link RedirectStrategy}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.DeflateInputStream
	 * Deflate input stream.    This class includes logic needed for various Rfc's in order
	 * to reasonably implement the "deflate" compression style.
	 */
	export interface DeflateInputStream extends Java.InputStream {
		/**
		 * Get available.
		 */
		available(): int;
		/**
		 * Close.
		 */
		close(): void;
		/**
		 * Mark.
		 */
		mark(readLimit: int): void;
		/**
		 * Check if mark is supported.
		 */
		markSupported(): boolean;
		/**
		 * Read a byte.
		 */
		read(): int;
		/**
		 * Read lots of bytes.
		 */
		read(b: array<byte>): int;
		/**
		 * Read lots of specific bytes.
		 */
		read(b: array<byte>, off: int, len: int): int;
		/**
		 * Reset.
		 */
		reset(): void;
		/**
		 * Skip
		 */
		skip(n: long): long;
	}
	export module DeflateInputStream {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.DeflateInputStream
		 * Deflate input stream.    This class includes logic needed for various Rfc's in order
		 * to reasonably implement the "deflate" compression style.
		 */
		export interface Static extends Java.InputStream.Static {
			DeflateStream: DeflateInputStream$DeflateStream.Static;
			new(wrapped: Java.InputStream): Http.DeflateInputStream;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.client.entity.DeflateInputStream.DeflateStream
	 */
	export interface DeflateInputStream$DeflateStream extends Java.InflaterInputStream {
		close(): void;
	}
	export module DeflateInputStream$DeflateStream {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.DeflateInputStream.DeflateStream
		 */
		export interface Static extends Java.InflaterInputStream.Static {
			new(in_: Java.InputStream, inflater: Java.Inflater): Http.DeflateInputStream$DeflateStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.GzipCompressingEntity
	 * Wrapping entity that compresses content when {@link #writeTo writing}.
	 *
	 *
	 * @since 4.0
	 */
	export interface GzipCompressingEntity extends Http.HttpEntityWrapper {
		getContent(): Java.InputStream;
		getContentEncoding(): Http.Header;
		getContentLength(): long;
		isChunked(): boolean;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module GzipCompressingEntity {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.GzipCompressingEntity
		 * Wrapping entity that compresses content when {@link #writeTo writing}.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpEntityWrapper.Static {
			new(entity: Http.HttpEntity): Http.GzipCompressingEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.DecompressingEntity
	 * Common base class for decompressing {@link HttpEntity} implementations.
	 *
	 * @since 4.4
	 */
	export interface DecompressingEntity extends Http.HttpEntityWrapper {
		getContent(): Java.InputStream;
		getContentEncoding(): Http.Header;
		getContentLength(): long;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module DecompressingEntity {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.DecompressingEntity
		 * Common base class for decompressing {@link HttpEntity} implementations.
		 *
		 * @since 4.4
		 */
		export interface Static extends Http.HttpEntityWrapper.Static {
			/**
			 * Creates a new {@link DecompressingEntity}.
			 *
			 * @param wrapped the non-null {@link HttpEntity} to be wrapped
			 * @param inputStreamFactory factory to create decompressing stream.
			 */
			new(wrapped: Http.HttpEntity, inputStreamFactory: Http.InputStreamFactory): Http.DecompressingEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.GZIPInputStreamFactory
	 * {@link InputStreamFactory} for handling GZIPContent Coded responses.
	 *
	 * @since 4.5.4
	 */
	export interface GZIPInputStreamFactory extends Java.Object, Http.InputStreamFactory {
		create(inputStream: Java.InputStream): Java.InputStream;
	}
	export module GZIPInputStreamFactory {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.GZIPInputStreamFactory
		 * {@link InputStreamFactory} for handling GZIPContent Coded responses.
		 *
		 * @since 4.5.4
		 */
		export interface Static extends Java.Object.Static, Http.InputStreamFactory.Static {
			new(): Http.GZIPInputStreamFactory;
			/**
			 * Gets the singleton instance.
			 *
			 * @return the singleton instance.
			 */
			getInstance(): Http.GZIPInputStreamFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.RequestDirector
	 * A client-side request director.
	 * The director decides which steps are necessary to execute a request.
	 * It establishes connections and optionally processes redirects and
	 * authentication challenges. The director may therefore generate and
	 * send a sequence of requests in order to execute one initial request.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) No longer used
	 */
	export interface RequestDirector extends Java.Object {
	}
	export module RequestDirector {
		/**
		 * Corresponding Java class: org.apache.http.client.RequestDirector
		 * A client-side request director.
		 * The director decides which steps are necessary to execute a request.
		 * It establishes connections and optionally processes redirects and
		 * authentication challenges. The director may therefore generate and
		 * send a sequence of requests in order to execute one initial request.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) No longer used
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ManagedClientConnection
	 * A client-side connection with advanced connection logic.
	 * Instances are typically obtained from a connection manager.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
	 */
	export interface ManagedClientConnection extends Http.HttpClientConnection, Http.HttpRoutedConnection, Http.ManagedHttpClientConnection, Http.ConnectionReleaseTrigger {
	}
	export module ManagedClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.conn.ManagedClientConnection
		 * A client-side connection with advanced connection logic.
		 * Instances are typically obtained from a connection manager.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
		 */
		export interface Static extends Http.HttpClientConnection.Static, Http.HttpRoutedConnection.Static, Http.ManagedHttpClientConnection.Static, Http.ConnectionReleaseTrigger.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ClientConnectionOperator
	 * ClientConnectionOperator represents a strategy for creating
	 * {@link OperatedClientConnection} instances and updating the underlying
	 * {@link java.net.Socket} of those objects. Implementations will most
	 * likely make use of {@link org.apache.http.conn.scheme.SchemeSocketFactory}s
	 * to create {@link java.net.Socket} instances.
	 * 
	 * The methods in this interface allow the creation of plain and layered
	 * sockets. Creating a tunnelled connection through a proxy, however,
	 * is not within the scope of the operator.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
	 */
	export interface ClientConnectionOperator extends Java.Object {
	}
	export module ClientConnectionOperator {
		/**
		 * Corresponding Java class: org.apache.http.conn.ClientConnectionOperator
		 * ClientConnectionOperator represents a strategy for creating
		 * {@link OperatedClientConnection} instances and updating the underlying
		 * {@link java.net.Socket} of those objects. Implementations will most
		 * likely make use of {@link org.apache.http.conn.scheme.SchemeSocketFactory}s
		 * to create {@link java.net.Socket} instances.
		 * 
		 * The methods in this interface allow the creation of plain and layered
		 * sockets. Creating a tunnelled connection through a proxy, however,
		 * is not within the scope of the operator.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) replaced by {@link HttpClientConnectionManager}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.socket.ConnectionSocketFactory
	 * A factory for creating and connecting connection sockets.
	 *
	 * @since 4.3
	 */
	export interface ConnectionSocketFactory extends Java.Object {
		/**
		 * Connects the socket to the target host with the given resolved remote address.
		 *
		 * @param connectTimeout connect timeout.
		 * @param sock the socket to connect, as obtained from {@link #createSocket(HttpContext)}.
		 * {@code null} indicates that a new socket should be created and connected.
		 * @param host target host as specified by the caller (end user).
		 * @param remoteAddress the resolved remote address to connect to.
		 * @param localAddress the local address to bind the socket to, or {@code null} for any.
		 * @param context the actual HTTP context.
		 *
		 * @return  the connected socket. The returned object may be different
		 *          from the {@code sock} argument if this factory supports
		 *          a layered protocol.
		 *
		 * @throws IOException if an I/O error occurs
		 */
		connectSocket(connectTimeout: int, sock: Java.Socket, host: Http.HttpHost, remoteAddress: Java.InetSocketAddress, localAddress: Java.InetSocketAddress, context: Http.HttpContext): Java.Socket;
		/**
		 * Creates new, unconnected socket. The socket should subsequently be passed to
		 * {@link #connectSocket(int, Socket, HttpHost, InetSocketAddress, InetSocketAddress,
		 *    HttpContext) connectSocket} method.
		 *
		 * @return  a new socket
		 *
		 * @throws IOException if an I/O error occurs while creating the socket
		 */
		createSocket(context: Http.HttpContext): Java.Socket;
	}
	export module ConnectionSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.socket.ConnectionSocketFactory
		 * A factory for creating and connecting connection sockets.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.TrustSelfSignedStrategy
	 * A trust strategy that accepts self-signed certificates as trusted. Verification of all other
	 * certificates is done by the trust manager configured in the SSL context.
	 *
	 * @since 4.1
	 */
	export interface TrustSelfSignedStrategy extends Java.Object, Http.ConnectionTrustStrategy {
		isTrusted(chain: array<Java.X509Certificate>, authType: string): boolean;
	}
	export module TrustSelfSignedStrategy {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.TrustSelfSignedStrategy
		 * A trust strategy that accepts self-signed certificates as trusted. Verification of all other
		 * certificates is done by the trust manager configured in the SSL context.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionTrustStrategy.Static {
			new(): Http.TrustSelfSignedStrategy;
			INSTANCE?: Http.TrustSelfSignedStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.CPool
	 * @since 4.3
	 */
	export interface CPool extends Http.AbstractConnPool<Http.HttpRoute, Http.ManagedHttpClientConnection, Http.CPoolEntry> {
	}
	export module CPool {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.CPool
		 * @since 4.3
		 */
		export interface Static extends Http.AbstractConnPool.Static {
			new(connFactory: Http.ConnFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>, defaultMaxPerRoute: int, maxTotal: int, timeToLive: long, tunit: Java.TimeUnit): Http.CPool;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.PrivateKeyStrategy
	 * A strategy allowing for a choice of an alias during SSL authentication.
	 *
	 * @since 4.3
	 *
	 * @deprecated (4.4) use {@link org.apache.http.ssl.PrivateKeyStrategy}.
	 */
	export interface ConnectionPrivateKeyStrategy extends Java.Object {
	}
	export module ConnectionPrivateKeyStrategy {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.PrivateKeyStrategy
		 * A strategy allowing for a choice of an alias during SSL authentication.
		 *
		 * @since 4.3
		 *
		 * @deprecated (4.4) use {@link org.apache.http.ssl.PrivateKeyStrategy}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.TrustStrategy
	 * A strategy to establish trustworthiness of certificates without consulting
	 * the trust manager configured in the actual SSL context. This interface can be
	 * used to override the standard JSSE certificate verification process.
	 *
	 * @since 4.1
	 */
	export interface ConnectionTrustStrategy extends Http.TrustStrategy {
	}
	export module ConnectionTrustStrategy {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.TrustStrategy
		 * A strategy to establish trustworthiness of certificates without consulting
		 * the trust manager configured in the actual SSL context. This interface can be
		 * used to override the standard JSSE certificate verification process.
		 *
		 * @since 4.1
		 */
		export interface Static extends Http.TrustStrategy.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.SSLContextBuilder
	 * Builder for {@link SSLContext} instances.
	 *
	 * @since 4.3
	 *
	 * @deprecated (4.4) use {@link org.apache.http.ssl.SSLContextBuilder}.
	 */
	export interface ConnectionSSLContextBuilder extends Java.Object {
	}
	export module ConnectionSSLContextBuilder {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.SSLContextBuilder
		 * Builder for {@link SSLContext} instances.
		 *
		 * @since 4.3
		 *
		 * @deprecated (4.4) use {@link org.apache.http.ssl.SSLContextBuilder}.
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.ConnectionSSLContextBuilder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.PrivateKeyDetails
	 * Private key details.
	 *
	 * @since 4.3
	 *
	 * @deprecated (4.4) use {@link org.apache.http.ssl.PrivateKeyDetails}.
	 */
	export interface ConnectionPrivateKeyDetails extends Java.Object {
	}
	export module ConnectionPrivateKeyDetails {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.PrivateKeyDetails
		 * Private key details.
		 *
		 * @since 4.3
		 *
		 * @deprecated (4.4) use {@link org.apache.http.ssl.PrivateKeyDetails}.
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.ConnectionPrivateKeyDetails;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.LayeredSocketFactoryAdaptor
	 * @deprecated (4.1) do not use
	 */
	export interface LayeredSocketFactoryAdaptor extends Http.SocketFactoryAdaptor, Http.LayeredSocketFactory {
	}
	export module LayeredSocketFactoryAdaptor {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.LayeredSocketFactoryAdaptor
		 * @deprecated (4.1) do not use
		 */
		export interface Static extends Http.SocketFactoryAdaptor.Static, Http.LayeredSocketFactory.Static {
			new(): Http.LayeredSocketFactoryAdaptor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.SchemeLayeredSocketFactoryAdaptor2
	 * @deprecated (4.2) do not use
	 */
	export interface SchemeLayeredSocketFactoryAdaptor2 extends Java.Object, Http.SchemeLayeredSocketFactory {
	}
	export module SchemeLayeredSocketFactoryAdaptor2 {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.SchemeLayeredSocketFactoryAdaptor2
		 * @deprecated (4.2) do not use
		 */
		export interface Static extends Java.Object.Static, Http.SchemeLayeredSocketFactory.Static {
			new(): Http.SchemeLayeredSocketFactoryAdaptor2;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.SocketFactory
	 * A factory for creating, initializing and connecting sockets.
	 * The factory encapsulates the logic for establishing a socket connection.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1)  use {@link SchemeSocketFactory}
	 */
	export interface SocketFactory extends Java.Object {
	}
	export module SocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.SocketFactory
		 * A factory for creating, initializing and connecting sockets.
		 * The factory encapsulates the logic for establishing a socket connection.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1)  use {@link SchemeSocketFactory}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.LayeredSocketFactory
	 * A {@link SocketFactory SocketFactory} for layered sockets (SSL/TLS).
	 * See there for things to consider when implementing a socket factory.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1)  use {@link SchemeSocketFactory}
	 */
	export interface LayeredSocketFactory extends Http.SocketFactory {
	}
	export module LayeredSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.LayeredSocketFactory
		 * A {@link SocketFactory SocketFactory} for layered sockets (SSL/TLS).
		 * See there for things to consider when implementing a socket factory.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1)  use {@link SchemeSocketFactory}
		 */
		export interface Static extends Http.SocketFactory.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ConnectTimeoutException
	 * A timeout while connecting to an HTTP server or waiting for an
	 * available connection from an HttpConnectionManager.
	 *
	 *
	 * @since 4.0
	 */
	export interface ConnectTimeoutException extends Java.InterruptedIOException {
		/**
		 * @since 4.3
		 */
		getHost(): Http.HttpHost;
	}
	export module ConnectTimeoutException {
		/**
		 * Corresponding Java class: org.apache.http.conn.ConnectTimeoutException
		 * A timeout while connecting to an HTTP server or waiting for an
		 * available connection from an HttpConnectionManager.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.InterruptedIOException.Static {
			/**
			 * Creates a ConnectTimeoutException with a {@code null} detail message.
			 */
			new(): Http.ConnectTimeoutException;
			/**
			 * Creates a ConnectTimeoutException with the specified detail message.
			 */
			new(message: string): Http.ConnectTimeoutException;
			/**
			 * Creates a ConnectTimeoutException based on original {@link IOException}.
			 *
			 * @since 4.3
			 */
			new(cause: Java.IOException, host: Http.HttpHost, ...remoteAddresses: Java.InetAddress[]): Http.ConnectTimeoutException;
			new(cause: Java.IOException, host: Http.HttpHost, remoteAddresses: array<Java.InetAddress>): Http.ConnectTimeoutException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.util.DomainType
	 * Domain types differentiated by Mozilla Public Suffix List.
	 *
	 * @since 4.5
	 */
	export interface DomainType extends Java.Enum<DomainType> {
	}
	export module DomainType {
		/**
		 * Corresponding Java class: org.apache.http.conn.util.DomainType
		 * Domain types differentiated by Mozilla Public Suffix List.
		 *
		 * @since 4.5
		 */
		export interface Static extends Java.Enum.Static {
			UNKNOWN?: Http.DomainType;
			ICANN?: Http.DomainType;
			PRIVATE?: Http.DomainType;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.SSLConnectionSocketFactory
	 * Layered socket factory for TLS/SSL connections.
	 * 
	 * SSLSocketFactory can be used to validate the identity of the HTTPS server against a list of
	 * trusted certificates and to authenticate to the HTTPS server using a private key.
	 * 
	 * SSLSocketFactory will enable server authentication when supplied with
	 * a {@link java.security.KeyStore trust-store} file containing one or several trusted certificates. The client
	 * secure socket will reject the connection during the SSL session handshake if the target HTTPS
	 * server attempts to authenticate itself with a non-trusted certificate.
	 * 
	 * Use JDK keytool utility to import a trusted certificate and generate a trust-store file:
	 *    
	 *     keytool -import -alias "my server cert" -file server.crt -keystore my.truststore
	 *    
	 * 
	 * In special cases the standard trust verification process can be bypassed by using a custom
	 * {@link org.apache.http.conn.ssl.TrustStrategy}. This interface is primarily intended for allowing self-signed
	 * certificates to be accepted as trusted without having to add them to the trust-store file.
	 * 
	 * SSLSocketFactory will enable client authentication when supplied with
	 * a {@link java.security.KeyStore key-store} file containing a private key/public certificate
	 * pair. The client secure socket will use the private key to authenticate
	 * itself to the target HTTPS server during the SSL session handshake if
	 * requested to do so by the server.
	 * The target HTTPS server will in its turn verify the certificate presented
	 * by the client in order to establish client's authenticity.
	 * 
	 * Use the following sequence of actions to generate a key-store file
	 * 
	 *   
	 *     
	 *      
	 *      Use JDK keytool utility to generate a new key
	 *      
	 *      keytool -genkey -v -alias "my client key" -validity 365 -keystore my.keystore
	 *      
	 *      For simplicity use the same password for the key as that of the key-store
	 *      
	 *     
	 *     
	 *      
	 *      Issue a certificate signing request (CSR)
	 *      
	 *      keytool -certreq -alias "my client key" -file mycertreq.csr -keystore my.keystore
	 *     
	 *     
	 *      
	 *      Send the certificate request to the trusted Certificate Authority for signature.
	 *      One may choose to act as her own CA and sign the certificate request using a PKI
	 *      tool, such as OpenSSL.
	 *      
	 *     
	 *     
	 *      
	 *       Import the trusted CA root certificate
	 *      
	 *       keytool -import -alias "my trusted ca" -file caroot.crt -keystore my.keystore
	 *     
	 *     
	 *       
	 *       Import the PKCS#7 file containing the complete certificate chain
	 *       
	 *       keytool -import -alias "my client key" -file mycert.p7 -keystore my.keystore
	 *     
	 *     
	 *       
	 *       Verify the content of the resultant keystore file
	 *       
	 *       keytool -list -v -keystore my.keystore
	 *     
	 *   
	 *
	 * @since 4.3
	 */
	export interface SSLConnectionSocketFactory extends Java.Object, Http.LayeredConnectionSocketFactory {
		connectSocket(connectTimeout: int, socket: Java.Socket, host: Http.HttpHost, remoteAddress: Java.InetSocketAddress, localAddress: Java.InetSocketAddress, context: Http.HttpContext): Java.Socket;
		createLayeredSocket(socket: Java.Socket, target: string, port: int, context: Http.HttpContext): Java.Socket;
		createSocket(context: Http.HttpContext): Java.Socket;
	}
	export module SSLConnectionSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.SSLConnectionSocketFactory
		 * Layered socket factory for TLS/SSL connections.
		 * 
		 * SSLSocketFactory can be used to validate the identity of the HTTPS server against a list of
		 * trusted certificates and to authenticate to the HTTPS server using a private key.
		 * 
		 * SSLSocketFactory will enable server authentication when supplied with
		 * a {@link java.security.KeyStore trust-store} file containing one or several trusted certificates. The client
		 * secure socket will reject the connection during the SSL session handshake if the target HTTPS
		 * server attempts to authenticate itself with a non-trusted certificate.
		 * 
		 * Use JDK keytool utility to import a trusted certificate and generate a trust-store file:
		 *    
		 *     keytool -import -alias "my server cert" -file server.crt -keystore my.truststore
		 *    
		 * 
		 * In special cases the standard trust verification process can be bypassed by using a custom
		 * {@link org.apache.http.conn.ssl.TrustStrategy}. This interface is primarily intended for allowing self-signed
		 * certificates to be accepted as trusted without having to add them to the trust-store file.
		 * 
		 * SSLSocketFactory will enable client authentication when supplied with
		 * a {@link java.security.KeyStore key-store} file containing a private key/public certificate
		 * pair. The client secure socket will use the private key to authenticate
		 * itself to the target HTTPS server during the SSL session handshake if
		 * requested to do so by the server.
		 * The target HTTPS server will in its turn verify the certificate presented
		 * by the client in order to establish client's authenticity.
		 * 
		 * Use the following sequence of actions to generate a key-store file
		 * 
		 *   
		 *     
		 *      
		 *      Use JDK keytool utility to generate a new key
		 *      
		 *      keytool -genkey -v -alias "my client key" -validity 365 -keystore my.keystore
		 *      
		 *      For simplicity use the same password for the key as that of the key-store
		 *      
		 *     
		 *     
		 *      
		 *      Issue a certificate signing request (CSR)
		 *      
		 *      keytool -certreq -alias "my client key" -file mycertreq.csr -keystore my.keystore
		 *     
		 *     
		 *      
		 *      Send the certificate request to the trusted Certificate Authority for signature.
		 *      One may choose to act as her own CA and sign the certificate request using a PKI
		 *      tool, such as OpenSSL.
		 *      
		 *     
		 *     
		 *      
		 *       Import the trusted CA root certificate
		 *      
		 *       keytool -import -alias "my trusted ca" -file caroot.crt -keystore my.keystore
		 *     
		 *     
		 *       
		 *       Import the PKCS#7 file containing the complete certificate chain
		 *       
		 *       keytool -import -alias "my client key" -file mycert.p7 -keystore my.keystore
		 *     
		 *     
		 *       
		 *       Verify the content of the resultant keystore file
		 *       
		 *       keytool -list -v -keystore my.keystore
		 *     
		 *   
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.LayeredConnectionSocketFactory.Static {
			new(sslContext: Java.SSLContext): Http.SSLConnectionSocketFactory;
			/**
			 * @since 4.4
			 */
			new(sslContext: Java.SSLContext, hostnameVerifier: Java.HostnameVerifier): Http.SSLConnectionSocketFactory;
			/**
			 * @since 4.4
			 */
			new(sslContext: Java.SSLContext, supportedProtocols: array<string>, supportedCipherSuites: array<string>, hostnameVerifier: Java.HostnameVerifier): Http.SSLConnectionSocketFactory;
			/**
			 * @since 4.4
			 */
			new(socketfactory: Java.SSLSocketFactory, hostnameVerifier: Java.HostnameVerifier): Http.SSLConnectionSocketFactory;
			/**
			 * @since 4.4
			 */
			new(socketfactory: Java.SSLSocketFactory, supportedProtocols: array<string>, supportedCipherSuites: array<string>, hostnameVerifier: Java.HostnameVerifier): Http.SSLConnectionSocketFactory;
			TLS?: string;
			SSL?: string;
			SSLV2?: string;
			/**
			 * @since 4.4
			 */
			getDefaultHostnameVerifier(): Java.HostnameVerifier;
			/**
			 * Obtains default SSL socket factory with an SSL context based on the standard JSSE
			 * trust material ({@code cacerts} file in the security properties directory).
			 * System properties are not taken into consideration.
			 *
			 * @return default SSL socket factory
			 */
			getSocketFactory(): Http.SSLConnectionSocketFactory;
			/**
			 * Obtains default SSL socket factory with an SSL context based on system properties
			 * as described in
			 * 
			 * Java&#x2122; Secure Socket Extension (JSSE) Reference Guide.
			 *
			 * @return default system SSL socket factory
			 */
			getSystemSocketFactory(): Http.SSLConnectionSocketFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.util.InetAddressUtils
	 * A collection of utilities relating to InetAddresses.
	 *
	 * @since 4.0
	 */
	export interface InetAddressUtils extends Java.Object {
	}
	export module InetAddressUtils {
		/**
		 * Corresponding Java class: org.apache.http.conn.util.InetAddressUtils
		 * A collection of utilities relating to InetAddresses.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Checks whether the parameter is a valid IPv4 address
			 *
			 * @param input the address string to check for validity
			 * @return true if the input parameter is a valid IPv4 address
			 */
			isIPv4Address(input: string): boolean;
			isIPv4MappedIPv64Address(input: string): boolean;
			/**
			 * Checks whether the parameter is a valid IPv6 address (including compressed).
			 *
			 * @param input the address string to check for validity
			 * @return true if the input parameter is a valid standard or compressed IPv6 address
			 */
			isIPv6Address(input: string): boolean;
			/**
			 * Checks whether the parameter is a valid compressed IPv6 address
			 *
			 * @param input the address string to check for validity
			 * @return true if the input parameter is a valid compressed IPv6 address
			 */
			isIPv6HexCompressedAddress(input: string): boolean;
			/**
			 * Checks whether the parameter is a valid standard (non-compressed) IPv6 address
			 *
			 * @param input the address string to check for validity
			 * @return true if the input parameter is a valid standard (non-compressed) IPv6 address
			 */
			isIPv6StdAddress(input: string): boolean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.util.PublicSuffixMatcher
	 * Utility class that can test if DNS names match the content of the Public Suffix List.
	 * 
	 * An up-to-date list of suffixes can be obtained from
	 * publicsuffix.org
	 *
	 * @see org.apache.http.conn.util.PublicSuffixList
	 *
	 * @since 4.4
	 */
	export interface PublicSuffixMatcher extends Java.Object {
		/**
		 * Returns registrable part of the domain for the given domain name or {@code null}
		 * if given domain represents a public suffix.
		 *
		 * @param domain
		 * @return domain root
		 */
		getDomainRoot(domain: string): string;
		/**
		 * Returns registrable part of the domain for the given domain name or {@code null}
		 * if given domain represents a public suffix.
		 *
		 * @param domain
		 * @param expectedType expected domain type or {@code null} if any.
		 * @return domain root
		 *
		 * @since 4.5
		 */
		getDomainRoot(domain: string, expectedType: Http.DomainType): string;
		/**
		 * Tests whether the given domain matches any of entry from the public suffix list.
		 */
		matches(domain: string): boolean;
		/**
		 * Tests whether the given domain matches any of entry from the public suffix list.
		 *
		 * @param domain
		 * @param expectedType expected domain type or {@code null} if any.
		 * @return {@code true} if the given domain matches any of the public suffixes.
		 *
		 * @since 4.5
		 */
		matches(domain: string, expectedType: Http.DomainType): boolean;
	}
	export module PublicSuffixMatcher {
		/**
		 * Corresponding Java class: org.apache.http.conn.util.PublicSuffixMatcher
		 * Utility class that can test if DNS names match the content of the Public Suffix List.
		 * 
		 * An up-to-date list of suffixes can be obtained from
		 * publicsuffix.org
		 *
		 * @see org.apache.http.conn.util.PublicSuffixList
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			new(rules: Java.Collection<string>, exceptions: Java.Collection<string>): Http.PublicSuffixMatcher;
			/**
			 * @since 4.5
			 */
			new(domainType: Http.DomainType, rules: Java.Collection<string>, exceptions: Java.Collection<string>): Http.PublicSuffixMatcher;
			/**
			 * @since 4.5
			 */
			new(lists: Java.Collection<Http.PublicSuffixList>): Http.PublicSuffixMatcher;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.util.PublicSuffixList
	 * Public suffix is a set of DNS names or wildcards concatenated with dots. It represents
	 * the part of a domain name which is not under the control of the individual registrant
	 * 
	 * An up-to-date list of suffixes can be obtained from
	 * publicsuffix.org
	 *
	 * @since 4.4
	 */
	export interface PublicSuffixList extends Java.Object {
		getExceptions(): Java.List<string>;
		getRules(): Java.List<string>;
		/**
		 * @since 4.5
		 */
		getType(): Http.DomainType;
	}
	export module PublicSuffixList {
		/**
		 * Corresponding Java class: org.apache.http.conn.util.PublicSuffixList
		 * Public suffix is a set of DNS names or wildcards concatenated with dots. It represents
		 * the part of a domain name which is not under the control of the individual registrant
		 * 
		 * An up-to-date list of suffixes can be obtained from
		 * publicsuffix.org
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * @since 4.5
			 */
			new(type: Http.DomainType, rules: Java.List<string>, exceptions: Java.List<string>): Http.PublicSuffixList;
			new(rules: Java.List<string>, exceptions: Java.List<string>): Http.PublicSuffixList;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.util.PublicSuffixMatcherLoader
	 * {@link org.apache.http.conn.util.PublicSuffixMatcher} loader.
	 *
	 * @since 4.4
	 */
	export interface PublicSuffixMatcherLoader extends Java.Object {
	}
	export module PublicSuffixMatcherLoader {
		/**
		 * Corresponding Java class: org.apache.http.conn.util.PublicSuffixMatcherLoader
		 * {@link org.apache.http.conn.util.PublicSuffixMatcher} loader.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.PublicSuffixMatcherLoader;
			getDefault(): Http.PublicSuffixMatcher;
			load(url: Java.URL): Http.PublicSuffixMatcher;
			load(file: Java.File): Http.PublicSuffixMatcher;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.HttpInetSocketAddress
	 * Extended {@link InetSocketAddress} implementation that also provides access to the original
	 * {@link HttpHost} used to resolve the address.
	 *
	 * @since 4.2 no longer used.
	 *
	 * @deprecated (4.3)
	 */
	export interface HttpInetSocketAddress extends Java.InetSocketAddress {
	}
	export module HttpInetSocketAddress {
		/**
		 * Corresponding Java class: org.apache.http.conn.HttpInetSocketAddress
		 * Extended {@link InetSocketAddress} implementation that also provides access to the original
		 * {@link HttpHost} used to resolve the address.
		 *
		 * @since 4.2 no longer used.
		 *
		 * @deprecated (4.3)
		 */
		export interface Static extends Java.InetSocketAddress.Static {
			new(): Http.HttpInetSocketAddress;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.HttpConnectionFactory
	 * Generic {@link HttpConnection} factory.
	 *
	 * @since 4.3
	 */
	export interface ConnectionHttpConnectionFactory<T = any, C extends HttpConnection = any> extends Java.Object {
		create(route: T, config: Http.ConnectionConfig): C;
	}
	export module ConnectionHttpConnectionFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.HttpConnectionFactory
		 * Generic {@link HttpConnection} factory.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.HttpHostConnectException
	 * A {@link ConnectException} that specifies the {@link HttpHost} that was
	 * being connected to.
	 *
	 * @since 4.0
	 */
	export interface HttpHostConnectException extends Java.ConnectException {
		getHost(): Http.HttpHost;
	}
	export module HttpHostConnectException {
		/**
		 * Corresponding Java class: org.apache.http.conn.HttpHostConnectException
		 * A {@link ConnectException} that specifies the {@link HttpHost} that was
		 * being connected to.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.ConnectException.Static {
			/**
			 * Creates a HttpHostConnectException based on original {@link java.io.IOException}.
			 *
			 * @since 4.3
			 */
			new(cause: Java.IOException, host: Http.HttpHost, ...remoteAddresses: Java.InetAddress[]): Http.HttpHostConnectException;
			new(cause: Java.IOException, host: Http.HttpHost, remoteAddresses: array<Java.InetAddress>): Http.HttpHostConnectException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.DnsResolver
	 * Users may implement this interface to override the normal DNS lookup offered
	 * by the OS.
	 *
	 * @since 4.2
	 */
	export interface DnsResolver extends Java.Object {
		/**
		 * Returns the IP address for the specified host name, or null if the given
		 * host is not recognized or the associated IP address cannot be used to
		 * build an InetAddress instance.
		 *
		 * @see InetAddress
		 *
		 * @param host
		 *            The host name to be resolved by this resolver.
		 * @return The IP address associated to the given host name, or null if the
		 *         host name is not known by the implementation class.
		 */
		resolve(host: string): array<Java.InetAddress>;
	}
	export module DnsResolver {
		/**
		 * Corresponding Java class: org.apache.http.conn.DnsResolver
		 * Users may implement this interface to override the normal DNS lookup offered
		 * by the OS.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.MultihomePlainSocketFactory
	 * Socket factory that implements a simple multi-home fail-over on connect failure,
	 * provided the same hostname resolves to multiple {@link InetAddress}es. Please note
	 * the {@link #connectSocket(Socket, String, int, InetAddress, int, HttpParams)}
	 * method cannot be reliably interrupted by closing the socket returned by the
	 * {@link #createSocket()} method.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1)  Do not use. For multihome support socket factories must implement
	 * {@link org.apache.http.conn.scheme.SchemeSocketFactory} interface.
	 */
	export interface MultihomePlainSocketFactory extends Java.Object, Http.SocketFactory {
	}
	export module MultihomePlainSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.MultihomePlainSocketFactory
		 * Socket factory that implements a simple multi-home fail-over on connect failure,
		 * provided the same hostname resolves to multiple {@link InetAddress}es. Please note
		 * the {@link #connectSocket(Socket, String, int, InetAddress, int, HttpParams)}
		 * method cannot be reliably interrupted by closing the socket returned by the
		 * {@link #createSocket()} method.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1)  Do not use. For multihome support socket factories must implement
		 * {@link org.apache.http.conn.scheme.SchemeSocketFactory} interface.
		 */
		export interface Static extends Java.Object.Static, Http.SocketFactory.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineException
	 * Signals NTLM protocol failure.
	 *
	 *
	 * @since 4.0
	 */
	export interface NTLMEngineException extends Http.AuthenticationException {
	}
	export module NTLMEngineException {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngineException
		 * Signals NTLM protocol failure.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AuthenticationException.Static {
			new(): Http.NTLMEngineException;
			/**
			 * Creates a new NTLMEngineException with the specified message.
			 *
			 * @param message the exception detail message
			 */
			new(message: string): Http.NTLMEngineException;
			/**
			 * Creates a new NTLMEngineException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.NTLMEngineException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.KerberosSchemeFactory
	 * {@link AuthSchemeProvider} implementation that creates and initializes
	 * {@link KerberosScheme} instances.
	 *
	 * @since 4.2
	 */
	export interface KerberosSchemeFactory extends Java.Object, Http.AuthSchemeFactory, Http.AuthSchemeProvider {
		create(context: Http.HttpContext): Http.AuthScheme;
		isStripPort(): boolean;
		isUseCanonicalHostname(): boolean;
		newInstance(params: Http.HttpParams): Http.AuthScheme;
	}
	export module KerberosSchemeFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.KerberosSchemeFactory
		 * {@link AuthSchemeProvider} implementation that creates and initializes
		 * {@link KerberosScheme} instances.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.AuthSchemeFactory.Static, Http.AuthSchemeProvider.Static {
			/**
			 * @since 4.4
			 */
			new(stripPort: boolean, useCanonicalHostname: boolean): Http.KerberosSchemeFactory;
			new(stripPort: boolean): Http.KerberosSchemeFactory;
			new(): Http.KerberosSchemeFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMScheme
	 * NTLM is a proprietary authentication scheme developed by Microsoft
	 * and optimized for Windows platforms.
	 *
	 * @since 4.0
	 */
	export interface NTLMScheme extends Http.AuthSchemeBase {
		authenticate(credentials: Http.Credentials, request: Http.HttpRequest): Http.Header;
		getParameter(name: string): string;
		getRealm(): string;
		getSchemeName(): string;
		isComplete(): boolean;
		isConnectionBased(): boolean;
	}
	export module NTLMScheme {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMScheme
		 * NTLM is a proprietary authentication scheme developed by Microsoft
		 * and optimized for Windows platforms.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AuthSchemeBase.Static {
			new(engine: Http.NTLMEngine): Http.NTLMScheme;
			/**
			 * @since 4.3
			 */
			new(): Http.NTLMScheme;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMScheme.State
	 */
	export interface NTLMScheme$State extends Java.Enum<NTLMScheme$State> {
	}
	export module NTLMScheme$State {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMScheme.State
		 */
		export interface Static extends Java.Enum.Static {
			UNINITIATED?: Http.NTLMScheme$State;
			CHALLENGE_RECEIVED?: Http.NTLMScheme$State;
			MSG_TYPE1_GENERATED?: Http.NTLMScheme$State;
			MSG_TYPE2_RECEVIED?: Http.NTLMScheme$State;
			MSG_TYPE3_GENERATED?: Http.NTLMScheme$State;
			FAILED?: Http.NTLMScheme$State;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.HttpEntityDigester
	 */
	export interface HttpEntityDigester extends Java.OutputStream {
		close(): void;
		getDigest(): array<byte>;
		write(b: int): void;
		write(b: array<byte>, off: int, len: int): void;
		/**
		 * Writes b.length bytes from the specified byte array
		 * to this output stream. The general contract for write(b)
		 * is that it should have exactly the same effect as the call
		 * write(b, 0, b.length).
		 *
		 * @param      b   the data.
		 * @exception  IOException  if an I/O error occurs.
		 * @see        java.io.OutputStream#write(byte[], int, int)
		 */
		write(b: array<byte>): void;
	}
	export module HttpEntityDigester {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.HttpEntityDigester
		 */
		export interface Static extends Java.OutputStream.Static {
			new(): Http.HttpEntityDigester;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.BasicSchemeFactory
	 * {@link AuthSchemeProvider} implementation that creates and initializes
	 * {@link BasicScheme} instances.
	 *
	 * @since 4.0
	 */
	export interface BasicSchemeFactory extends Java.Object, Http.AuthSchemeFactory, Http.AuthSchemeProvider {
		create(context: Http.HttpContext): Http.AuthScheme;
		newInstance(params: Http.HttpParams): Http.AuthScheme;
	}
	export module BasicSchemeFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.BasicSchemeFactory
		 * {@link AuthSchemeProvider} implementation that creates and initializes
		 * {@link BasicScheme} instances.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.AuthSchemeFactory.Static, Http.AuthSchemeProvider.Static {
			/**
			 * @since 4.3
			 */
			new(charset: Java.Charset): Http.BasicSchemeFactory;
			new(): Http.BasicSchemeFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMSchemeFactory
	 * {@link AuthSchemeProvider} implementation that creates and initializes
	 * {@link NTLMScheme} instances configured to use the default {@link NTLMEngine}
	 * implementation.
	 *
	 * @since 4.1
	 */
	export interface NTLMSchemeFactory extends Java.Object, Http.AuthSchemeFactory, Http.AuthSchemeProvider {
		create(context: Http.HttpContext): Http.AuthScheme;
		newInstance(params: Http.HttpParams): Http.AuthScheme;
	}
	export module NTLMSchemeFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMSchemeFactory
		 * {@link AuthSchemeProvider} implementation that creates and initializes
		 * {@link NTLMScheme} instances configured to use the default {@link NTLMEngine}
		 * implementation.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static, Http.AuthSchemeFactory.Static, Http.AuthSchemeProvider.Static {
			new(): Http.NTLMSchemeFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109DomainHandler
	 *
	 * @since 4.0
	 */
	export interface RFC2109DomainHandler extends Java.Object, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(cookie: Http.SetCookie, value: string): void;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC2109DomainHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109DomainHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.RFC2109DomainHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.util.PublicSuffixListParser
	 * Parses the list from publicsuffix.org
	 * and configures a PublicSuffixFilter.
	 *
	 * @since 4.4
	 */
	export interface PublicSuffixListParser extends Java.Object {
		/**
		 * Parses the public suffix list format.
		 * 
		 * When creating the reader from the file, make sure to use the correct encoding
		 * (the original list is in UTF-8).
		 *
		 * @param reader the data reader. The caller is responsible for closing the reader.
		 * @throws java.io.IOException on error while reading from list
		 */
		parse(reader: Java.Reader): Http.PublicSuffixList;
		/**
		 * Parses the public suffix list format by domain type (currently supported ICANN and PRIVATE).
		 * 
		 * When creating the reader from the file, make sure to use the correct encoding
		 * (the original list is in UTF-8).
		 *
		 * @param reader the data reader. The caller is responsible for closing the reader.
		 * @throws java.io.IOException on error while reading from list
		 *
		 * @since 4.5
		 */
		parseByType(reader: Java.Reader): Java.List<Http.PublicSuffixList>;
	}
	export module PublicSuffixListParser {
		/**
		 * Corresponding Java class: org.apache.http.conn.util.PublicSuffixListParser
		 * Parses the list from publicsuffix.org
		 * and configures a PublicSuffixFilter.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.PublicSuffixListParser;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BasicExpiresHandler
	 *
	 * @since 4.0
	 */
	export interface BasicExpiresHandler extends Http.AbstractCookieAttributeHandler, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		parse(cookie: Http.SetCookie, value: string): void;
	}
	export module BasicExpiresHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BasicExpiresHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractCookieAttributeHandler.Static, Http.CommonCookieAttributeHandler.Static {
			new(datepatterns: array<string>): Http.BasicExpiresHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BrowserCompatSpec
	 * Cookie specification that strives to closely mimic (mis)behavior of
	 * common web browser applications such as Microsoft Internet Explorer
	 * and Mozilla FireFox.
	 *
	 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.DefaultCookieSpec}.
	 *
	 * @since 4.0
	 */
	export interface BrowserCompatSpec extends Http.CookieSpecBase {
	}
	export module BrowserCompatSpec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BrowserCompatSpec
		 * Cookie specification that strives to closely mimic (mis)behavior of
		 * common web browser applications such as Microsoft Internet Explorer
		 * and Mozilla FireFox.
		 *
		 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.DefaultCookieSpec}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.CookieSpecBase.Static {
			new(): Http.BrowserCompatSpec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265CookieSpecProvider
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * RFC 6265 conformant cookie policy. The instance returned by this factory can be shared by
	 * multiple threads.
	 *
	 * @since 4.4
	 */
	export interface RFC6265CookieSpecProvider extends Java.Object, Http.CookieSpecProvider {
		create(context: Http.HttpContext): Http.CookieSpec;
	}
	export module RFC6265CookieSpecProvider {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265CookieSpecProvider
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * RFC 6265 conformant cookie policy. The instance returned by this factory can be shared by
		 * multiple threads.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecProvider.Static {
			new(compatibilityLevel: Http.RFC6265CookieSpecProvider$CompatibilityLevel, publicSuffixMatcher: Http.PublicSuffixMatcher): Http.RFC6265CookieSpecProvider;
			new(publicSuffixMatcher: Http.PublicSuffixMatcher): Http.RFC6265CookieSpecProvider;
			new(): Http.RFC6265CookieSpecProvider;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265CookieSpecProvider.CompatibilityLevel
	 */
	export interface RFC6265CookieSpecProvider$CompatibilityLevel extends Java.Enum<RFC6265CookieSpecProvider$CompatibilityLevel> {
	}
	export module RFC6265CookieSpecProvider$CompatibilityLevel {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265CookieSpecProvider.CompatibilityLevel
		 */
		export interface Static extends Java.Enum.Static {
			STRICT?: Http.RFC6265CookieSpecProvider$CompatibilityLevel;
			RELAXED?: Http.RFC6265CookieSpecProvider$CompatibilityLevel;
			IE_MEDIUM_SECURITY?: Http.RFC6265CookieSpecProvider$CompatibilityLevel;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965PortAttributeHandler
	 * {@code "Port"} cookie attribute handler for RFC 2965 cookie spec.
	 *
	 * @since 4.0
	 */
	export interface RFC2965PortAttributeHandler extends Java.Object, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		/**
		 * Match cookie port attribute. If the Port attribute is not specified
		 * in header, the cookie can be sent to any port. Otherwise, the request port
		 * must be in the cookie's port list.
		 */
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		/**
		 * Parse cookie port attribute.
		 */
		parse(cookie: Http.SetCookie, portValue: string): void;
		/**
		 * Validate cookie port attribute. If the Port attribute was specified
		 * in header, the request port must be in cookie's port list.
		 */
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC2965PortAttributeHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965PortAttributeHandler
		 * {@code "Port"} cookie attribute handler for RFC 2965 cookie spec.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.RFC2965PortAttributeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BasicClientCookie
	 * Default implementation of {@link SetCookie}.
	 *
	 * @since 4.0
	 */
	export interface BasicClientCookie extends Java.Object, Http.SetCookie, Http.ClientCookie, Java.Cloneable, Java.Serializable {
		clone(): obj;
		containsAttribute(name: string): boolean;
		getAttribute(name: string): string;
		/**
		 * Returns the comment describing the purpose of this cookie, or
		 * {@code null} if no such comment has been defined.
		 *
		 * @return comment
		 *
		 * @see #setComment(String)
		 */
		getComment(): string;
		/**
		 * Returns null. Cookies prior to RFC2965 do not set this attribute
		 */
		getCommentURL(): string;
		/**
		 * @since 4.4
		 */
		getCreationDate(): Java.Date;
		/**
		 * Returns domain attribute of the cookie.
		 *
		 * @return the value of the domain attribute
		 *
		 * @see #setDomain(java.lang.String)
		 */
		getDomain(): string;
		/**
		 * Returns the expiration {@link Date} of the cookie, or {@code null}
		 * if none exists.
		 * Note: the object returned by this method is
		 * considered immutable. Changing it (e.g. using setTime()) could result
		 * in undefined behaviour. Do so at your peril. 
		 * @return Expiration {@link Date}, or {@code null}.
		 *
		 * @see #setExpiryDate(java.util.Date)
		 *
		 */
		getExpiryDate(): Java.Date;
		/**
		 * Returns the name.
		 *
		 * @return String name The name
		 */
		getName(): string;
		/**
		 * Returns the path attribute of the cookie
		 *
		 * @return The value of the path attribute.
		 *
		 * @see #setPath(java.lang.String)
		 */
		getPath(): string;
		/**
		 * Returns null. Cookies prior to RFC2965 do not set this attribute
		 */
		getPorts(): array<int>;
		/**
		 * Returns the value.
		 *
		 * @return String value The current value.
		 */
		getValue(): string;
		/**
		 * Returns the version of the cookie specification to which this
		 * cookie conforms.
		 *
		 * @return the version of the cookie.
		 *
		 * @see #setVersion(int)
		 *
		 */
		getVersion(): int;
		/**
		 * Returns true if this cookie has expired.
		 * @param date Current time
		 *
		 * @return {@code true} if the cookie has expired.
		 */
		isExpired(date: Java.Date): boolean;
		/**
		 * Returns {@code false} if the cookie should be discarded at the end
		 * of the "session"; {@code true} otherwise.
		 *
		 * @return {@code false} if the cookie should be discarded at the end
		 *         of the "session"; {@code true} otherwise
		 */
		isPersistent(): boolean;
		/**
		 * @return {@code true} if this cookie should only be sent over secure connections.
		 * @see #setSecure(boolean)
		 */
		isSecure(): boolean;
		/**
		 * @since 4.4
		 */
		removeAttribute(name: string): boolean;
		setAttribute(name: string, value: string): void;
		/**
		 * If a user agent (web browser) presents this cookie to a user, the
		 * cookie's purpose will be described using this comment.
		 *
		 * @param comment
		 *
		 * @see #getComment()
		 */
		setComment(comment: string): void;
		/**
		 * @since 4.4
		 */
		setCreationDate(creationDate: Java.Date): void;
		/**
		 * Sets the domain attribute.
		 *
		 * @param domain The value of the domain attribute
		 *
		 * @see #getDomain
		 */
		setDomain(domain: string): void;
		/**
		 * Sets expiration date.
		 * Note: the object returned by this method is considered
		 * immutable. Changing it (e.g. using setTime()) could result in undefined
		 * behaviour. Do so at your peril.
		 *
		 * @param expiryDate the {@link Date} after which this cookie is no longer valid.
		 *
		 * @see #getExpiryDate
		 *
		 */
		setExpiryDate(expiryDate: Java.Date): void;
		/**
		 * Sets the path attribute.
		 *
		 * @param path The value of the path attribute
		 *
		 * @see #getPath
		 *
		 */
		setPath(path: string): void;
		/**
		 * Sets the secure attribute of the cookie.
		 * 
		 * When {@code true} the cookie should only be sent
		 * using a secure protocol (https).  This should only be set when
		 * the cookie's originating server used a secure protocol to set the
		 * cookie's value.
		 *
		 * @param secure The value of the secure attribute
		 *
		 * @see #isSecure()
		 */
		setSecure(secure: boolean): void;
		/**
		 * Sets the value
		 *
		 * @param value
		 */
		setValue(value: string): void;
		/**
		 * Sets the version of the cookie specification to which this
		 * cookie conforms.
		 *
		 * @param version the version of the cookie.
		 *
		 * @see #getVersion
		 */
		setVersion(version: int): void;
		toString(): string;
	}
	export module BasicClientCookie {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BasicClientCookie
		 * Default implementation of {@link SetCookie}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.SetCookie.Static, Http.ClientCookie.Static, Java.Cloneable.Static, Java.Serializable.Static {
			/**
			 * Default Constructor taking a name and a value. The value may be null.
			 *
			 * @param name The name.
			 * @param value The value.
			 */
			new(name: string, value: string): Http.BasicClientCookie;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BasicPathHandler
	 *
	 * @since 4.0
	 */
	export interface BasicPathHandler extends Java.Object, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(cookie: Http.SetCookie, value: string): void;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module BasicPathHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BasicPathHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.BasicPathHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.LaxMaxAgeHandler
	 *
	 * @since 4.4
	 */
	export interface LaxMaxAgeHandler extends Http.AbstractCookieAttributeHandler, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		parse(cookie: Http.SetCookie, value: string): void;
	}
	export module LaxMaxAgeHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.LaxMaxAgeHandler
		 *
		 * @since 4.4
		 */
		export interface Static extends Http.AbstractCookieAttributeHandler.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.LaxMaxAgeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDomainHandler
	 *
	 * @since 4.0
	 */
	export interface NetscapeDomainHandler extends Http.BasicDomainHandler {
		getAttributeName(): string;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(cookie: Http.SetCookie, value: string): void;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module NetscapeDomainHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDomainHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.BasicDomainHandler.Static {
			new(): Http.NetscapeDomainHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.PublicSuffixDomainFilter
	 * Wraps a {@link org.apache.http.cookie.CookieAttributeHandler} and leverages its match method
	 * to never match a suffix from a black list. May be used to provide additional security for
	 * cross-site attack types by preventing cookies from apparent domains that are not publicly
	 * available.
	 *
	 *  @see org.apache.http.conn.util.PublicSuffixList
	 *  @see org.apache.http.conn.util.PublicSuffixMatcher
	 *
	 * @since 4.4
	 */
	export interface PublicSuffixDomainFilter extends Java.Object, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		/**
		 * Never matches if the cookie's domain is from the blacklist.
		 */
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(cookie: Http.SetCookie, value: string): void;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module PublicSuffixDomainFilter {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.PublicSuffixDomainFilter
		 * Wraps a {@link org.apache.http.cookie.CookieAttributeHandler} and leverages its match method
		 * to never match a suffix from a black list. May be used to provide additional security for
		 * cross-site attack types by preventing cookies from apparent domains that are not publicly
		 * available.
		 *
		 *  @see org.apache.http.conn.util.PublicSuffixList
		 *  @see org.apache.http.conn.util.PublicSuffixMatcher
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Http.CommonCookieAttributeHandler.Static {
			new(handler: Http.CommonCookieAttributeHandler, publicSuffixMatcher: Http.PublicSuffixMatcher): Http.PublicSuffixDomainFilter;
			new(handler: Http.CommonCookieAttributeHandler, suffixList: Http.PublicSuffixList): Http.PublicSuffixDomainFilter;
			decorate(handler: Http.CommonCookieAttributeHandler, publicSuffixMatcher: Http.PublicSuffixMatcher): Http.CommonCookieAttributeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.AbstractCookieAttributeHandler
	 *
	 * @since 4.0
	 */
	export interface AbstractCookieAttributeHandler extends Java.Object, Http.CookieAttributeHandler {
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module AbstractCookieAttributeHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.AbstractCookieAttributeHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CookieAttributeHandler.Static {
			new(): Http.AbstractCookieAttributeHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109SpecProvider
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * {@link RFC2109Spec}. The instance returned by this factory
	 * can be shared by multiple threads.
	 * 
	 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265CookieSpecProvider}
	 *
	 * @since 4.4
	 * @see org.apache.http.impl.cookie.RFC6265CookieSpecProvider
	 */
	export interface RFC2109SpecProvider extends Java.Object, Http.CookieSpecProvider {
		create(context: Http.HttpContext): Http.CookieSpec;
	}
	export module RFC2109SpecProvider {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2109SpecProvider
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * {@link RFC2109Spec}. The instance returned by this factory
		 * can be shared by multiple threads.
		 * 
		 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265CookieSpecProvider}
		 *
		 * @since 4.4
		 * @see org.apache.http.impl.cookie.RFC6265CookieSpecProvider
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecProvider.Static {
			new(publicSuffixMatcher: Http.PublicSuffixMatcher, oneHeader: boolean): Http.RFC2109SpecProvider;
			new(publicSuffixMatcher: Http.PublicSuffixMatcher): Http.RFC2109SpecProvider;
			new(): Http.RFC2109SpecProvider;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDraftSpecFactory
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * {@link org.apache.http.impl.cookie.NetscapeDraftSpec}. The instance returned by this factory
	 * can be shared by multiple threads.
	 *
	 * @deprecated (4.4) Use {@link org.apache.http.impl.cookie.NetscapeDraftSpecProvider}.
	 *
	 * @since 4.0
	 */
	export interface NetscapeDraftSpecFactory extends Java.Object, Http.CookieSpecFactory, Http.CookieSpecProvider {
	}
	export module NetscapeDraftSpecFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDraftSpecFactory
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * {@link org.apache.http.impl.cookie.NetscapeDraftSpec}. The instance returned by this factory
		 * can be shared by multiple threads.
		 *
		 * @deprecated (4.4) Use {@link org.apache.http.impl.cookie.NetscapeDraftSpecProvider}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecFactory.Static, Http.CookieSpecProvider.Static {
			new(): Http.NetscapeDraftSpecFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265LaxSpec
	 * Standard {@link org.apache.http.cookie.CookieSpec} implementation that enforces a more relaxed
	 * interpretation of the HTTP state management specification (RFC 6265, section 5)
	 * for interoperability with existing servers that do not conform to the well behaved profile
	 * (RFC 6265, section 4).
	 *
	 * @since 4.4
	 */
	export interface RFC6265LaxSpec extends Http.RFC6265CookieSpecBase {
		toString(): string;
	}
	export module RFC6265LaxSpec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265LaxSpec
		 * Standard {@link org.apache.http.cookie.CookieSpec} implementation that enforces a more relaxed
		 * interpretation of the HTTP state management specification (RFC 6265, section 5)
		 * for interoperability with existing servers that do not conform to the well behaved profile
		 * (RFC 6265, section 4).
		 *
		 * @since 4.4
		 */
		export interface Static extends Http.RFC6265CookieSpecBase.Static {
			new(): Http.RFC6265LaxSpec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.DateParseException
	 * An exception to indicate an error parsing a date string.
	 *
	 * @see DateUtils
	 *
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) no longer used.
	 */
	export interface DateParseException extends Java.Exception {
	}
	export module DateParseException {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.DateParseException
		 * An exception to indicate an error parsing a date string.
		 *
		 * @see DateUtils
		 *
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) no longer used.
		 */
		export interface Static extends Java.Exception.Static {
			new(): Http.DateParseException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultRedirectStrategyAdaptor
	 * @deprecated (4.1) do not use
	 */
	export interface DefaultRedirectStrategyAdaptor extends Java.Object, Http.RedirectStrategy {
	}
	export module DefaultRedirectStrategyAdaptor {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultRedirectStrategyAdaptor
		 * @deprecated (4.1) do not use
		 */
		export interface Static extends Java.Object.Static, Http.RedirectStrategy.Static {
			new(): Http.DefaultRedirectStrategyAdaptor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.AbstractHttpClient
	 * Base class for {@link org.apache.http.client.HttpClient} implementations.
	 * This class acts as a facade to a number of special purpose handler or
	 * strategy implementations responsible for handling of a particular aspect
	 * of the HTTP protocol such as redirect or authentication handling or
	 * making decision about connection persistence and keep alive duration.
	 * This enables the users to selectively replace default implementation
	 * of those aspects with custom, application specific ones. This class
	 * also provides factory methods to instantiate those objects:
	 * 
	 *   {@link HttpRequestExecutor} object used to transmit messages
	 *    over HTTP connections. The {@link #createRequestExecutor()} must be
	 *    implemented by concrete super classes to instantiate this object.
	 *    
	 *   {@link BasicHttpProcessor} object to manage a list of protocol
	 *    interceptors and apply cross-cutting protocol logic to all incoming
	 *    and outgoing HTTP messages. The {@link #createHttpProcessor()} must be
	 *    implemented by concrete super classes to instantiate this object.
	 *    
	 *   {@link HttpRequestRetryHandler} object used to decide whether
	 *    or not a failed HTTP request is safe to retry automatically.
	 *    The {@link #createHttpRequestRetryHandler()} must be
	 *    implemented by concrete super classes to instantiate this object.
	 *    
	 *   {@link ClientConnectionManager} object used to manage
	 *    persistent HTTP connections.
	 *    
	 *   {@link ConnectionReuseStrategy} object used to decide whether
	 *    or not a HTTP connection can be kept alive and re-used for subsequent
	 *    HTTP requests. The {@link #createConnectionReuseStrategy()} must be
	 *    implemented by concrete super classes to instantiate this object.
	 *    
	 *   {@link ConnectionKeepAliveStrategy} object used to decide how
	 *    long a persistent HTTP connection can be kept alive.
	 *    The {@link #createConnectionKeepAliveStrategy()} must be
	 *    implemented by concrete super classes to instantiate this object.
	 *    
	 *   {@link CookieSpecRegistry} object used to maintain a list of
	 *    supported cookie specifications.
	 *    The {@link #createCookieSpecRegistry()} must be implemented by concrete
	 *    super classes to instantiate this object.
	 *    
	 *   {@link CookieStore} object used to maintain a collection of
	 *    cookies. The {@link #createCookieStore()} must be implemented by
	 *    concrete super classes to instantiate this object.
	 *    
	 *   {@link AuthSchemeRegistry} object used to maintain a list of
	 *    supported authentication schemes.
	 *    The {@link #createAuthSchemeRegistry()} must be implemented by concrete
	 *    super classes to instantiate this object.
	 *    
	 *   {@link CredentialsProvider} object used to maintain
	 *    a collection user credentials. The {@link #createCredentialsProvider()}
	 *    must be implemented by concrete super classes to instantiate
	 *    this object.
	 *    
	 *   {@link AuthenticationStrategy} object used to authenticate
	 *    against the target host.
	 *    The {@link #createTargetAuthenticationStrategy()} must be implemented
	 *    by concrete super classes to instantiate this object.
	 *    
	 *   {@link AuthenticationStrategy} object used to authenticate
	 *    against the proxy host.
	 *    The {@link #createProxyAuthenticationStrategy()} must be implemented
	 *    by concrete super classes to instantiate this object.
	 *    
	 *   {@link HttpRoutePlanner} object used to calculate a route
	 *    for establishing a connection to the target host. The route
	 *    may involve multiple intermediate hops.
	 *    The {@link #createHttpRoutePlanner()} must be implemented
	 *    by concrete super classes to instantiate this object.
	 *    
	 *   {@link RedirectStrategy} object used to determine if an HTTP
	 *    request should be redirected to a new location in response to an HTTP
	 *    response received from the target server.
	 *    
	 *   {@link UserTokenHandler} object used to determine if the
	 *    execution context is user identity specific.
	 *    The {@link #createUserTokenHandler()} must be implemented by
	 *    concrete super classes to instantiate this object.
	 *    
	 * 
	 * 
	 *   This class also maintains a list of protocol interceptors intended
	 *   for processing outgoing requests and incoming responses and provides
	 *   methods for managing those interceptors. New protocol interceptors can be
	 *   introduced to the protocol processor chain or removed from it if needed.
	 *   Internally protocol interceptors are stored in a simple
	 *   {@link java.util.ArrayList}. They are executed in the same natural order
	 *   as they are added to the list.
	 * 
	 *   AbstractHttpClient is thread safe. It is recommended that the same
	 *   instance of this class is reused for multiple request executions.
	 *   When an instance of DefaultHttpClient is no longer needed and is about
	 *   to go out of scope the connection manager associated with it must be
	 *   shut down by calling {@link ClientConnectionManager#shutdown()}!
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link HttpClientBuilder}.
	 */
	export interface AbstractHttpClient extends Http.CloseableHttpClient {
	}
	export module AbstractHttpClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.AbstractHttpClient
		 * Base class for {@link org.apache.http.client.HttpClient} implementations.
		 * This class acts as a facade to a number of special purpose handler or
		 * strategy implementations responsible for handling of a particular aspect
		 * of the HTTP protocol such as redirect or authentication handling or
		 * making decision about connection persistence and keep alive duration.
		 * This enables the users to selectively replace default implementation
		 * of those aspects with custom, application specific ones. This class
		 * also provides factory methods to instantiate those objects:
		 * 
		 *   {@link HttpRequestExecutor} object used to transmit messages
		 *    over HTTP connections. The {@link #createRequestExecutor()} must be
		 *    implemented by concrete super classes to instantiate this object.
		 *    
		 *   {@link BasicHttpProcessor} object to manage a list of protocol
		 *    interceptors and apply cross-cutting protocol logic to all incoming
		 *    and outgoing HTTP messages. The {@link #createHttpProcessor()} must be
		 *    implemented by concrete super classes to instantiate this object.
		 *    
		 *   {@link HttpRequestRetryHandler} object used to decide whether
		 *    or not a failed HTTP request is safe to retry automatically.
		 *    The {@link #createHttpRequestRetryHandler()} must be
		 *    implemented by concrete super classes to instantiate this object.
		 *    
		 *   {@link ClientConnectionManager} object used to manage
		 *    persistent HTTP connections.
		 *    
		 *   {@link ConnectionReuseStrategy} object used to decide whether
		 *    or not a HTTP connection can be kept alive and re-used for subsequent
		 *    HTTP requests. The {@link #createConnectionReuseStrategy()} must be
		 *    implemented by concrete super classes to instantiate this object.
		 *    
		 *   {@link ConnectionKeepAliveStrategy} object used to decide how
		 *    long a persistent HTTP connection can be kept alive.
		 *    The {@link #createConnectionKeepAliveStrategy()} must be
		 *    implemented by concrete super classes to instantiate this object.
		 *    
		 *   {@link CookieSpecRegistry} object used to maintain a list of
		 *    supported cookie specifications.
		 *    The {@link #createCookieSpecRegistry()} must be implemented by concrete
		 *    super classes to instantiate this object.
		 *    
		 *   {@link CookieStore} object used to maintain a collection of
		 *    cookies. The {@link #createCookieStore()} must be implemented by
		 *    concrete super classes to instantiate this object.
		 *    
		 *   {@link AuthSchemeRegistry} object used to maintain a list of
		 *    supported authentication schemes.
		 *    The {@link #createAuthSchemeRegistry()} must be implemented by concrete
		 *    super classes to instantiate this object.
		 *    
		 *   {@link CredentialsProvider} object used to maintain
		 *    a collection user credentials. The {@link #createCredentialsProvider()}
		 *    must be implemented by concrete super classes to instantiate
		 *    this object.
		 *    
		 *   {@link AuthenticationStrategy} object used to authenticate
		 *    against the target host.
		 *    The {@link #createTargetAuthenticationStrategy()} must be implemented
		 *    by concrete super classes to instantiate this object.
		 *    
		 *   {@link AuthenticationStrategy} object used to authenticate
		 *    against the proxy host.
		 *    The {@link #createProxyAuthenticationStrategy()} must be implemented
		 *    by concrete super classes to instantiate this object.
		 *    
		 *   {@link HttpRoutePlanner} object used to calculate a route
		 *    for establishing a connection to the target host. The route
		 *    may involve multiple intermediate hops.
		 *    The {@link #createHttpRoutePlanner()} must be implemented
		 *    by concrete super classes to instantiate this object.
		 *    
		 *   {@link RedirectStrategy} object used to determine if an HTTP
		 *    request should be redirected to a new location in response to an HTTP
		 *    response received from the target server.
		 *    
		 *   {@link UserTokenHandler} object used to determine if the
		 *    execution context is user identity specific.
		 *    The {@link #createUserTokenHandler()} must be implemented by
		 *    concrete super classes to instantiate this object.
		 *    
		 * 
		 * 
		 *   This class also maintains a list of protocol interceptors intended
		 *   for processing outgoing requests and incoming responses and provides
		 *   methods for managing those interceptors. New protocol interceptors can be
		 *   introduced to the protocol processor chain or removed from it if needed.
		 *   Internally protocol interceptors are stored in a simple
		 *   {@link java.util.ArrayList}. They are executed in the same natural order
		 *   as they are added to the list.
		 * 
		 *   AbstractHttpClient is thread safe. It is recommended that the same
		 *   instance of this class is reused for multiple request executions.
		 *   When an instance of DefaultHttpClient is no longer needed and is about
		 *   to go out of scope the connection manager associated with it must be
		 *   shut down by calling {@link ClientConnectionManager#shutdown()}!
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link HttpClientBuilder}.
		 */
		export interface Static extends Http.CloseableHttpClient.Static {
			new(): Http.AbstractHttpClient;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.InternalHttpClient
	 * Internal class.
	 *
	 * @since 4.3
	 */
	export interface InternalHttpClient extends Http.CloseableHttpClient, Http.Configurable {
		close(): void;
		getConfig(): Http.RequestConfig;
		getConnectionManager(): Http.ClientConnectionManager;
		getParams(): Http.HttpParams;
	}
	export module InternalHttpClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.InternalHttpClient
		 * Internal class.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.CloseableHttpClient.Static, Http.Configurable.Static {
			new(execChain: Http.ClientExecChain, connManager: Http.HttpClientConnectionManager, routePlanner: Http.HttpRoutePlanner, cookieSpecRegistry: Http.Lookup<Http.CookieSpecProvider>, authSchemeRegistry: Http.Lookup<Http.AuthSchemeProvider>, cookieStore: Http.CookieStore, credentialsProvider: Http.CredentialsProvider, defaultConfig: Http.RequestConfig, closeables: Java.List<Java.Closeable>): Http.InternalHttpClient;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.HttpAuthenticator
	 * @deprecated (4.3) reserved for internal use.
	 *
	 */
	export interface ClientHttpAuthenticator extends Http.HttpAuthenticator {
	}
	export module ClientHttpAuthenticator {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.HttpAuthenticator
		 * @deprecated (4.3) reserved for internal use.
		 *
		 */
		export interface Static extends Http.HttpAuthenticator.Static {
			new(): Http.ClientHttpAuthenticator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.EntityEnclosingRequestWrapper
	 * A wrapper class for {@link HttpEntityEnclosingRequest}s that can
	 * be used to change properties of the current request without
	 * modifying the original object.
	 * 
	 * This class is also capable of resetting the request headers to
	 * the state of the original request.
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) do not use.
	 */
	export interface EntityEnclosingRequestWrapper extends Http.RequestWrapper, Http.HttpEntityEnclosingRequest {
	}
	export module EntityEnclosingRequestWrapper {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.EntityEnclosingRequestWrapper
		 * A wrapper class for {@link HttpEntityEnclosingRequest}s that can
		 * be used to change properties of the current request without
		 * modifying the original object.
		 * 
		 * This class is also capable of resetting the request headers to
		 * the state of the original request.
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) do not use.
		 */
		export interface Static extends Http.RequestWrapper.Static, Http.HttpEntityEnclosingRequest.Static {
			new(): Http.EntityEnclosingRequestWrapper;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.client.EntityEnclosingRequestWrapper.EntityWrapper
	 */
	export interface EntityEnclosingRequestWrapper$EntityWrapper extends Http.HttpEntityWrapper {
		consumeContent(): void;
		getContent(): Java.InputStream;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module EntityEnclosingRequestWrapper$EntityWrapper {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.EntityEnclosingRequestWrapper.EntityWrapper
		 */
		export interface Static extends Http.HttpEntityWrapper.Static {
			new(): Http.EntityEnclosingRequestWrapper$EntityWrapper;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDraftSpec
	 * This {@link org.apache.http.cookie.CookieSpec} implementation conforms to
	 * the original draft specification published by Netscape Communications.
	 * It should be avoided unless absolutely necessary for compatibility with
	 * legacy applications.
	 * 
	 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265LaxSpec}.
	 *
	 * @since 4.0
	 * @see org.apache.http.impl.cookie.RFC6265LaxSpec
	 */
	export interface NetscapeDraftSpec extends Http.CookieSpecBase {
		formatCookies(cookies: Java.List<Http.Cookie>): Java.List<Http.Header>;
		getVersion(): int;
		getVersionHeader(): Http.Header;
		/**
		 * Parses the Set-Cookie value into an array of {@code Cookie}s.
		 *
		 * Syntax of the Set-Cookie HTTP Response Header:
		 *
		 * This is the format a CGI script would use to add to
		 * the HTTP headers a new piece of data which is to be stored by
		 * the client for later retrieval.
		 *
		 * 
		 *  Set-Cookie: NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure
		 * 
		 *
		 * Please note that the Netscape draft specification does not fully conform to the HTTP
		 * header format. Comma character if present in {@code Set-Cookie} will not be treated
		 * as a header element separator
		 *
		 * @see 
		 *  The Cookie Spec.
		 *
		 * @param header the {@code Set-Cookie} received from the server
		 * @return an array of {@code Cookie}s parsed from the Set-Cookie value
		 * @throws MalformedCookieException if an exception occurs during parsing
		 */
		parse(header: Http.Header, origin: Http.CookieOrigin): Java.List<Http.Cookie>;
		toString(): string;
	}
	export module NetscapeDraftSpec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDraftSpec
		 * This {@link org.apache.http.cookie.CookieSpec} implementation conforms to
		 * the original draft specification published by Netscape Communications.
		 * It should be avoided unless absolutely necessary for compatibility with
		 * legacy applications.
		 * 
		 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265LaxSpec}.
		 *
		 * @since 4.0
		 * @see org.apache.http.impl.cookie.RFC6265LaxSpec
		 */
		export interface Static extends Http.CookieSpecBase.Static {
			/**
			 Default constructor
			 */
			new(datepatterns: array<string>): Http.NetscapeDraftSpec;
			new(): Http.NetscapeDraftSpec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultServiceUnavailableRetryStrategy
	 * Default implementation of the {@link ServiceUnavailableRetryStrategy} interface.
	 * that retries {@code 503} (Service Unavailable) responses for a fixed number of times
	 * at a fixed interval.
	 *
	 * @since 4.2
	 */
	export interface DefaultServiceUnavailableRetryStrategy extends Java.Object, Http.ServiceUnavailableRetryStrategy {
		getRetryInterval(): long;
		retryRequest(response: Http.HttpResponse, executionCount: int, context: Http.HttpContext): boolean;
	}
	export module DefaultServiceUnavailableRetryStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultServiceUnavailableRetryStrategy
		 * Default implementation of the {@link ServiceUnavailableRetryStrategy} interface.
		 * that retries {@code 503} (Service Unavailable) responses for a fixed number of times
		 * at a fixed interval.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.ServiceUnavailableRetryStrategy.Static {
			new(maxRetries: int, retryInterval: int): Http.DefaultServiceUnavailableRetryStrategy;
			new(): Http.DefaultServiceUnavailableRetryStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.HttpClients
	 * Factory methods for {@link CloseableHttpClient} instances.
	 * @since 4.3
	 */
	export interface HttpClients extends Java.Object {
	}
	export module HttpClients {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.HttpClients
		 * Factory methods for {@link CloseableHttpClient} instances.
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Creates {@link CloseableHttpClient} instance with default
			 * configuration.
			 */
			createDefault(): Http.CloseableHttpClient;
			/**
			 * Creates {@link CloseableHttpClient} instance that implements
			 * the most basic HTTP protocol support.
			 */
			createMinimal(): Http.CloseableHttpClient;
			/**
			 * Creates {@link CloseableHttpClient} instance that implements
			 * the most basic HTTP protocol support.
			 */
			createMinimal(connManager: Http.HttpClientConnectionManager): Http.CloseableHttpClient;
			/**
			 * Creates {@link CloseableHttpClient} instance with default
			 * configuration based on system properties.
			 */
			createSystem(): Http.CloseableHttpClient;
			/**
			 * Creates builder object for construction of custom
			 * {@link CloseableHttpClient} instances.
			 */
			custom(): Http.HttpClientBuilder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.CloseableHttpClient
	 * Base implementation of {@link HttpClient} that also implements {@link Closeable}.
	 *
	 * @since 4.3
	 */
	export interface CloseableHttpClient extends Java.Object, Http.HttpClient, Java.Closeable {
		/**
		 * {@inheritDoc}
		 */
		execute(target: Http.HttpHost, request: Http.HttpRequest, context: Http.HttpContext): Http.CloseableHttpResponse;
		/**
		 * {@inheritDoc}
		 */
		execute(request: Http.HttpUriRequest, context: Http.HttpContext): Http.CloseableHttpResponse;
		/**
		 * {@inheritDoc}
		 */
		execute(request: Http.HttpUriRequest): Http.CloseableHttpResponse;
		/**
		 * {@inheritDoc}
		 */
		execute(target: Http.HttpHost, request: Http.HttpRequest): Http.CloseableHttpResponse;
		/**
		 * Executes a request using the default context and processes the
		 * response using the given response handler. The content entity associated
		 * with the response is fully consumed and the underlying connection is
		 * released back to the connection manager automatically in all cases
		 * relieving individual {@link ResponseHandler}s from having to manage
		 * resource deallocation internally.
		 *
		 * @param request   the request to execute
		 * @param responseHandler the response handler
		 *
		 * @return  the response object as generated by the response handler.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute<T>(request: Http.HttpUriRequest, responseHandler: Http.ResponseHandler<T>): T;
		/**
		 * Executes a request using the default context and processes the
		 * response using the given response handler. The content entity associated
		 * with the response is fully consumed and the underlying connection is
		 * released back to the connection manager automatically in all cases
		 * relieving individual {@link ResponseHandler}s from having to manage
		 * resource deallocation internally.
		 *
		 * @param request   the request to execute
		 * @param responseHandler the response handler
		 * @param context   the context to use for the execution, or
		 *                  {@code null} to use the default context
		 *
		 * @return  the response object as generated by the response handler.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute<T>(request: Http.HttpUriRequest, responseHandler: Http.ResponseHandler<T>, context: Http.HttpContext): T;
		/**
		 * Executes a request using the default context and processes the
		 * response using the given response handler. The content entity associated
		 * with the response is fully consumed and the underlying connection is
		 * released back to the connection manager automatically in all cases
		 * relieving individual {@link ResponseHandler}s from having to manage
		 * resource deallocation internally.
		 *
		 * @param target    the target host for the request.
		 *                  Implementations may accept {@code null}
		 *                  if they can still determine a route, for example
		 *                  to a default target or by inspecting the request.
		 * @param request   the request to execute
		 * @param responseHandler the response handler
		 *
		 * @return  the response object as generated by the response handler.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute<T>(target: Http.HttpHost, request: Http.HttpRequest, responseHandler: Http.ResponseHandler<T>): T;
		/**
		 * Executes a request using the default context and processes the
		 * response using the given response handler. The content entity associated
		 * with the response is fully consumed and the underlying connection is
		 * released back to the connection manager automatically in all cases
		 * relieving individual {@link ResponseHandler}s from having to manage
		 * resource deallocation internally.
		 *
		 * @param target    the target host for the request.
		 *                  Implementations may accept {@code null}
		 *                  if they can still determine a route, for example
		 *                  to a default target or by inspecting the request.
		 * @param request   the request to execute
		 * @param responseHandler the response handler
		 * @param context   the context to use for the execution, or
		 *                  {@code null} to use the default context
		 *
		 * @return  the response object as generated by the response handler.
		 * @throws IOException in case of a problem or the connection was aborted
		 * @throws ClientProtocolException in case of an http protocol error
		 */
		execute<T>(target: Http.HttpHost, request: Http.HttpRequest, responseHandler: Http.ResponseHandler<T>, context: Http.HttpContext): T;
	}
	export module CloseableHttpClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.CloseableHttpClient
		 * Base implementation of {@link HttpClient} that also implements {@link Closeable}.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpClient.Static, Java.Closeable.Static {
			new(): Http.CloseableHttpClient;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.BasicAuthCache
	 * Default implementation of {@link org.apache.http.client.AuthCache}. This implements
	 * expects {@link org.apache.http.auth.AuthScheme} to be {@link java.io.Serializable}
	 * in order to be cacheable.
	 * 
	 * Instances of this class are thread safe as of version 4.4.
	 * 
	 *
	 * @since 4.1
	 */
	export interface BasicAuthCache extends Java.Object, Http.AuthCache {
		clear(): void;
		get(host: Http.HttpHost): Http.AuthScheme;
		put(host: Http.HttpHost, authScheme: Http.AuthScheme): void;
		remove(host: Http.HttpHost): void;
		toString(): string;
	}
	export module BasicAuthCache {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.BasicAuthCache
		 * Default implementation of {@link org.apache.http.client.AuthCache}. This implements
		 * expects {@link org.apache.http.auth.AuthScheme} to be {@link java.io.Serializable}
		 * in order to be cacheable.
		 * 
		 * Instances of this class are thread safe as of version 4.4.
		 * 
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static, Http.AuthCache.Static {
			/**
			 * Default constructor.
			 *
			 * @since 4.3
			 */
			new(schemePortResolver: Http.SchemePortResolver): Http.BasicAuthCache;
			new(): Http.BasicAuthCache;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultUserTokenHandler
	 * Default implementation of {@link UserTokenHandler}. This class will use
	 * an instance of {@link Principal} as a state object for HTTP connections,
	 * if it can be obtained from the given execution context. This helps ensure
	 * persistent connections created with a particular user identity within
	 * a particular security context can be reused by the same user only.
	 * 
	 * DefaultUserTokenHandler will use the user principal of connection
	 * based authentication schemes such as NTLM or that of the SSL session
	 * with the client authentication turned on. If both are unavailable,
	 * {@code null} token will be returned.
	 *
	 * @since 4.0
	 */
	export interface DefaultUserTokenHandler extends Java.Object, Http.UserTokenHandler {
		getUserToken(context: Http.HttpContext): obj;
	}
	export module DefaultUserTokenHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultUserTokenHandler
		 * Default implementation of {@link UserTokenHandler}. This class will use
		 * an instance of {@link Principal} as a state object for HTTP connections,
		 * if it can be obtained from the given execution context. This helps ensure
		 * persistent connections created with a particular user identity within
		 * a particular security context can be reused by the same user only.
		 * 
		 * DefaultUserTokenHandler will use the user principal of connection
		 * based authentication schemes such as NTLM or that of the SSL session
		 * with the client authentication turned on. If both are unavailable,
		 * {@code null} token will be returned.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.UserTokenHandler.Static {
			new(): Http.DefaultUserTokenHandler;
			INSTANCE?: Http.DefaultUserTokenHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultRequestDirector
	 * Default implementation of {@link RequestDirector}.
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.params.CoreProtocolPNames#PROTOCOL_VERSION}
	 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
	 *  {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET}
	 *  {@link org.apache.http.params.CoreProtocolPNames#USE_EXPECT_CONTINUE}
	 *  {@link org.apache.http.params.CoreProtocolPNames#WAIT_FOR_CONTINUE}
	 *  {@link org.apache.http.params.CoreProtocolPNames#USER_AGENT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SOCKET_BUFFER_SIZE}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_TIMEOUT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_LINGER}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_REUSEADDR}
	 *  {@link org.apache.http.params.CoreConnectionPNames#TCP_NODELAY}
	 *  {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#STALE_CONNECTION_CHECK}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY}
	 *  {@link org.apache.http.cookie.params.CookieSpecPNames#DATE_PATTERNS}
	 *  {@link org.apache.http.cookie.params.CookieSpecPNames#SINGLE_COOKIE_HEADER}
	 *  {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET}
	 *  {@link org.apache.http.client.params.ClientPNames#COOKIE_POLICY}
	 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_AUTHENTICATION}
	 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_REDIRECTS}
	 *  {@link org.apache.http.client.params.ClientPNames#MAX_REDIRECTS}
	 *  {@link org.apache.http.client.params.ClientPNames#ALLOW_CIRCULAR_REDIRECTS}
	 *  {@link org.apache.http.client.params.ClientPNames#VIRTUAL_HOST}
	 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HOST}
	 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HEADERS}
	 *  {@link org.apache.http.client.params.ClientPNames#CONN_MANAGER_TIMEOUT}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3)
	 */
	export interface DefaultRequestDirector extends Java.Object, Http.RequestDirector {
	}
	export module DefaultRequestDirector {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultRequestDirector
		 * Default implementation of {@link RequestDirector}.
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.params.CoreProtocolPNames#PROTOCOL_VERSION}
		 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
		 *  {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET}
		 *  {@link org.apache.http.params.CoreProtocolPNames#USE_EXPECT_CONTINUE}
		 *  {@link org.apache.http.params.CoreProtocolPNames#WAIT_FOR_CONTINUE}
		 *  {@link org.apache.http.params.CoreProtocolPNames#USER_AGENT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SOCKET_BUFFER_SIZE}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_TIMEOUT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_LINGER}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_REUSEADDR}
		 *  {@link org.apache.http.params.CoreConnectionPNames#TCP_NODELAY}
		 *  {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#STALE_CONNECTION_CHECK}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY}
		 *  {@link org.apache.http.cookie.params.CookieSpecPNames#DATE_PATTERNS}
		 *  {@link org.apache.http.cookie.params.CookieSpecPNames#SINGLE_COOKIE_HEADER}
		 *  {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET}
		 *  {@link org.apache.http.client.params.ClientPNames#COOKIE_POLICY}
		 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_AUTHENTICATION}
		 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_REDIRECTS}
		 *  {@link org.apache.http.client.params.ClientPNames#MAX_REDIRECTS}
		 *  {@link org.apache.http.client.params.ClientPNames#ALLOW_CIRCULAR_REDIRECTS}
		 *  {@link org.apache.http.client.params.ClientPNames#VIRTUAL_HOST}
		 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HOST}
		 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HEADERS}
		 *  {@link org.apache.http.client.params.ClientPNames#CONN_MANAGER_TIMEOUT}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3)
		 */
		export interface Static extends Java.Object.Static, Http.RequestDirector.Static {
			new(): Http.DefaultRequestDirector;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.AbstractConnPool
	 * An abstract connection pool.
	 * It is used by the {@link ThreadSafeClientConnManager}.
	 * The abstract pool includes a {@link #poolLock}, which is used to
	 * synchronize access to the internal pool datastructures.
	 * Don't use {@code synchronized} for that purpose!
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2) use {@link org.apache.http.pool.AbstractConnPool}
	 */
	export interface ConnectionAbstractConnPool extends Java.Object {
	}
	export module ConnectionAbstractConnPool {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.AbstractConnPool
		 * An abstract connection pool.
		 * It is used by the {@link ThreadSafeClientConnManager}.
		 * The abstract pool includes a {@link #poolLock}, which is used to
		 * synchronize access to the internal pool datastructures.
		 * Don't use {@code synchronized} for that purpose!
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2) use {@link org.apache.http.pool.AbstractConnPool}
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.ConnectionAbstractConnPool;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.SchemeRegistryFactory
	 * @since 4.1
	 *
	 * @deprecated (4.3) use {@link org.apache.http.impl.client.HttpClientBuilder}.
	 */
	export interface SchemeRegistryFactory extends Java.Object {
	}
	export module SchemeRegistryFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.SchemeRegistryFactory
		 * @since 4.1
		 *
		 * @deprecated (4.3) use {@link org.apache.http.impl.client.HttpClientBuilder}.
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.SchemeRegistryFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.LoggingSessionOutputBuffer
	 * Logs all data written to the wire LOG.
	 * @since 4.0
	 * @deprecated (4.3) no longer used.
	 */
	export interface LoggingSessionOutputBuffer extends Java.Object, Http.SessionOutputBuffer {
	}
	export module LoggingSessionOutputBuffer {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.LoggingSessionOutputBuffer
		 * Logs all data written to the wire LOG.
		 * @since 4.0
		 * @deprecated (4.3) no longer used.
		 */
		export interface Static extends Java.Object.Static, Http.SessionOutputBuffer.Static {
			new(): Http.LoggingSessionOutputBuffer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultProxyRoutePlanner
	 * Implementation of an {@link org.apache.http.conn.routing.HttpRoutePlanner}
	 * that routes requests through a default proxy.
	 *
	 * @since 4.3
	 */
	export interface DefaultProxyRoutePlanner extends Http.DefaultRoutePlanner {
	}
	export module DefaultProxyRoutePlanner {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultProxyRoutePlanner
		 * Implementation of an {@link org.apache.http.conn.routing.HttpRoutePlanner}
		 * that routes requests through a default proxy.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.DefaultRoutePlanner.Static {
			new(proxy: Http.HttpHost, schemePortResolver: Http.SchemePortResolver): Http.DefaultProxyRoutePlanner;
			new(proxy: Http.HttpHost): Http.DefaultProxyRoutePlanner;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.BasicHttpClientConnectionManager
	 * A connection manager for a single connection. This connection manager maintains only one active
	 * connection. Even though this class is fully thread-safe it ought to be used by one execution
	 * thread only, as only one thread a time can lease the connection at a time.
	 * 
	 * This connection manager will make an effort to reuse the connection for subsequent requests
	 * with the same {@link HttpRoute route}. It will, however, close the existing connection and
	 * open it for the given route, if the route of the persistent connection does not match that
	 * of the connection request. If the connection has been already been allocated
	 * {@link IllegalStateException} is thrown.
	 * 
	 * 
	 * This connection manager implementation should be used inside an EJB container instead of
	 * {@link PoolingHttpClientConnectionManager}.
	 * 
	 *
	 * @since 4.3
	 */
	export interface BasicHttpClientConnectionManager extends Java.Object, Http.HttpClientConnectionManager, Java.Closeable {
		close(): void;
		closeExpiredConnections(): void;
		closeIdleConnections(idletime: long, tunit: Java.TimeUnit): void;
		connect(conn: Http.HttpClientConnection, route: Http.HttpRoute, connectTimeout: int, context: Http.HttpContext): void;
		getConnectionConfig(): Http.ConnectionConfig;
		getSocketConfig(): Http.SocketConfig;
		releaseConnection(conn: Http.HttpClientConnection, state: obj, keepalive: long, tunit: Java.TimeUnit): void;
		requestConnection(route: Http.HttpRoute, state: obj): Http.ConnectionRequest;
		routeComplete(conn: Http.HttpClientConnection, route: Http.HttpRoute, context: Http.HttpContext): void;
		setConnectionConfig(connConfig: Http.ConnectionConfig): void;
		setSocketConfig(socketConfig: Http.SocketConfig): void;
		shutdown(): void;
		upgrade(conn: Http.HttpClientConnection, route: Http.HttpRoute, context: Http.HttpContext): void;
	}
	export module BasicHttpClientConnectionManager {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.BasicHttpClientConnectionManager
		 * A connection manager for a single connection. This connection manager maintains only one active
		 * connection. Even though this class is fully thread-safe it ought to be used by one execution
		 * thread only, as only one thread a time can lease the connection at a time.
		 * 
		 * This connection manager will make an effort to reuse the connection for subsequent requests
		 * with the same {@link HttpRoute route}. It will, however, close the existing connection and
		 * open it for the given route, if the route of the persistent connection does not match that
		 * of the connection request. If the connection has been already been allocated
		 * {@link IllegalStateException} is thrown.
		 * 
		 * 
		 * This connection manager implementation should be used inside an EJB container instead of
		 * {@link PoolingHttpClientConnectionManager}.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpClientConnectionManager.Static, Java.Closeable.Static {
			new(socketFactoryRegistry: Http.Lookup<Http.ConnectionSocketFactory>, connFactory: Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>, schemePortResolver: Http.SchemePortResolver, dnsResolver: Http.DnsResolver): Http.BasicHttpClientConnectionManager;
			/**
			 * @since 4.4
			 */
			new(httpClientConnectionOperator: Http.HttpClientConnectionOperator, connFactory: Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>): Http.BasicHttpClientConnectionManager;
			new(socketFactoryRegistry: Http.Lookup<Http.ConnectionSocketFactory>, connFactory: Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>): Http.BasicHttpClientConnectionManager;
			new(socketFactoryRegistry: Http.Lookup<Http.ConnectionSocketFactory>): Http.BasicHttpClientConnectionManager;
			new(): Http.BasicHttpClientConnectionManager;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.InMemoryDnsResolver
	 * In-memory {@link DnsResolver} implementation.
	 *
	 * @since 4.2
	 */
	export interface InMemoryDnsResolver extends Java.Object, Http.DnsResolver {
		/**
		 * Associates the given array of IP addresses to the given host in this DNS overrider.
		 * The IP addresses are assumed to be already resolved.
		 *
		 * @param host
		 *            The host name to be associated with the given IP.
		 * @param ips
		 *            array of IP addresses to be resolved by this DNS overrider to the given
		 *            host name.
		 */
		add(host: string, ...ips: Java.InetAddress[]): void;
		/**
		 * Associates the given array of IP addresses to the given host in this DNS overrider.
		 * The IP addresses are assumed to be already resolved.
		 *
		 * @param host
		 *            The host name to be associated with the given IP.
		 * @param ips
		 *            array of IP addresses to be resolved by this DNS overrider to the given
		 *            host name.
		 */
		add(host: string, ips: array<Java.InetAddress>): void;
		/**
		 * {@inheritDoc}
		 */
		resolve(host: string): array<Java.InetAddress>;
	}
	export module InMemoryDnsResolver {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.InMemoryDnsResolver
		 * In-memory {@link DnsResolver} implementation.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.DnsResolver.Static {
			/**
			 * Builds a DNS resolver that will resolve the host names against a
			 * collection held in-memory.
			 */
			new(): Http.InMemoryDnsResolver;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.HttpConnPool
	 * @since 4.2
	 *
	 * @deprecated (4.3) no longer used.
	 */
	export interface HttpConnPool extends Http.AbstractConnPool<Http.HttpRoute, Http.OperatedClientConnection, Http.HttpPoolEntry> {
	}
	export module HttpConnPool {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.HttpConnPool
		 * @since 4.2
		 *
		 * @deprecated (4.3) no longer used.
		 */
		export interface Static extends Http.AbstractConnPool.Static {
			InternalConnFactory: HttpConnPool$InternalConnFactory.Static;
			new(): Http.HttpConnPool;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.conn.HttpConnPool.InternalConnFactory
	 */
	export interface HttpConnPool$InternalConnFactory extends Java.Object, Http.ConnFactory<Http.HttpRoute, Http.OperatedClientConnection> {
		create(route: Http.HttpRoute): Http.OperatedClientConnection;
	}
	export module HttpConnPool$InternalConnFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.HttpConnPool.InternalConnFactory
		 */
		export interface Static extends Java.Object.Static, Http.ConnFactory.Static {
			new(): Http.HttpConnPool$InternalConnFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.SystemDefaultDnsResolver
	 * DNS resolver that uses the default OS implementation for resolving host names.
	 *
	 * @since 4.2
	 */
	export interface SystemDefaultDnsResolver extends Java.Object, Http.DnsResolver {
		resolve(host: string): array<Java.InetAddress>;
	}
	export module SystemDefaultDnsResolver {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.SystemDefaultDnsResolver
		 * DNS resolver that uses the default OS implementation for resolving host names.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.DnsResolver.Static {
			new(): Http.SystemDefaultDnsResolver;
			INSTANCE?: Http.SystemDefaultDnsResolver;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.NTUserPrincipal
	 * Microsoft Windows specific user principal implementation.
	 *
	 * @since 4.0
	 */
	export interface NTUserPrincipal extends Java.Object, Java.Principal, Java.Serializable {
		equals(o: obj): boolean;
		getDomain(): string;
		getName(): string;
		getUsername(): string;
		hashCode(): int;
		toString(): string;
	}
	export module NTUserPrincipal {
		/**
		 * Corresponding Java class: org.apache.http.auth.NTUserPrincipal
		 * Microsoft Windows specific user principal implementation.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Java.Principal.Static, Java.Serializable.Static {
			new(domain: string, username: string): Http.NTUserPrincipal;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AuthScheme
	 */
	export interface AuthScheme extends Java.Object {
		/**
		 * Returns authentication parameter with the given name, if available.
		 *
		 * @param name The name of the parameter to be returned
		 *
		 * @return the parameter with the given name
		 */
		getParameter(name: string): string;
		/**
		 * Returns authentication realm. If the concept of an authentication
		 * realm is not applicable to the given authentication scheme, returns
		 * {@code null}.
		 *
		 * @return the authentication realm
		 */
		getRealm(): string;
		/**
		 * Returns textual designation of the given authentication scheme.
		 *
		 * @return the name of the given authentication scheme
		 */
		getSchemeName(): string;
		/**
		 * Authentication process may involve a series of challenge-response exchanges.
		 * This method tests if the authorization process has been completed, either
		 * successfully or unsuccessfully, that is, all the required authorization
		 * challenges have been processed in their entirety.
		 *
		 * @return {@code true} if the authentication process has been completed,
		 * {@code false} otherwise.
		 */
		isComplete(): boolean;
		/**
		 * Tests if the authentication scheme is provides authorization on a per
		 * connection basis instead of usual per request basis
		 *
		 * @return {@code true} if the scheme is connection based, {@code false}
		 * if the scheme is request based.
		 */
		isConnectionBased(): boolean;
		/**
		 * Processes the given challenge token. Some authentication schemes
		 * may involve multiple challenge-response exchanges. Such schemes must be able
		 * to maintain the state information when dealing with sequential challenges
		 *
		 * @param header the challenge header
		 */
		processChallenge(header: Http.Header): void;
	}
	export module AuthScheme {
		/**
		 * Corresponding Java class: org.apache.http.auth.AuthScheme
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.CookieSpecRegistries
	 * @since 4.5
	 */
	export interface CookieSpecRegistries extends Java.Object {
	}
	export module CookieSpecRegistries {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.CookieSpecRegistries
		 * @since 4.5
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Creates the default registry, using the default public suffix matcher.
			 */
			createDefault(): Http.Lookup<Http.CookieSpecProvider>;
			/**
			 * Creates the default registry with the provided public suffix matcher
			 */
			createDefault(publicSuffixMatcher: Http.PublicSuffixMatcher): Http.Lookup<Http.CookieSpecProvider>;
			/**
			 * Creates a builder containing the default registry entries, using the provided public suffix matcher.
			 */
			createDefaultBuilder(publicSuffixMatcher: Http.PublicSuffixMatcher): Http.RegistryBuilder<Http.CookieSpecProvider>;
			/**
			 * Creates a builder containing the default registry entries with the default public suffix matcher.
			 */
			createDefaultBuilder(): Http.RegistryBuilder<Http.CookieSpecProvider>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.ContextAwareAuthScheme
	 */
	export interface ContextAwareAuthScheme extends Http.AuthScheme {
		/**
		 * Produces an authorization string for the given set of
		 * {@link Credentials}.
		 *
		 * @param credentials The set of credentials to be used for athentication
		 * @param request The request being authenticated
		 * @param context HTTP context
		 * @throws AuthenticationException if authorization string cannot
		 *   be generated due to an authentication failure
		 *
		 * @return the authorization string
		 */
		authenticate(credentials: Http.Credentials, request: Http.HttpRequest, context: Http.HttpContext): Http.Header;
	}
	export module ContextAwareAuthScheme {
		/**
		 * Corresponding Java class: org.apache.http.auth.ContextAwareAuthScheme
		 */
		export interface Static extends Http.AuthScheme.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AuthProtocolState
	 */
	export interface AuthProtocolState extends Java.Enum<AuthProtocolState> {
	}
	export module AuthProtocolState {
		/**
		 * Corresponding Java class: org.apache.http.auth.AuthProtocolState
		 */
		export interface Static extends Java.Enum.Static {
			UNCHALLENGED?: Http.AuthProtocolState;
			CHALLENGED?: Http.AuthProtocolState;
			HANDSHAKE?: Http.AuthProtocolState;
			FAILURE?: Http.AuthProtocolState;
			SUCCESS?: Http.AuthProtocolState;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.Credentials
	 * This interface represents a set of credentials consisting of a security
	 * principal and a secret (password) that can be used to establish user
	 * identity
	 *
	 * @since 4.0
	 */
	export interface Credentials extends Java.Object {
		getPassword(): string;
		getUserPrincipal(): Java.Principal;
	}
	export module Credentials {
		/**
		 * Corresponding Java class: org.apache.http.auth.Credentials
		 * This interface represents a set of credentials consisting of a security
		 * principal and a secret (password) that can be used to establish user
		 * identity
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.AuthState
	 * This class provides detailed information about the state of the authentication process.
	 *
	 * @since 4.0
	 */
	export interface AuthState extends Java.Object {
		/**
		 * Returns available {@link AuthOption}s. May be null.
		 *
		 * @since 4.2
		 */
		getAuthOptions(): Java.Queue<Http.AuthOption>;
		/**
		 * Returns actual {@link AuthScheme}. May be null.
		 */
		getAuthScheme(): Http.AuthScheme;
		/**
		 * Returns actual {@link Credentials}. May be null.
		 */
		getCredentials(): Http.Credentials;
		/**
		 * @since 4.2
		 */
		getState(): Http.AuthProtocolState;
		/**
		 * Returns {@code true} if {@link AuthOption}s are available, {@code false}
		 * otherwise.
		 *
		 * @since 4.2
		 */
		hasAuthOptions(): boolean;
		/**
		 * Resets the auth state.
		 *
		 * @since 4.2
		 */
		reset(): void;
		/**
		 * @since 4.2
		 */
		setState(state: Http.AuthProtocolState): void;
		toString(): string;
		/**
		 * Updates the auth state with {@link AuthScheme} and {@link Credentials}.
		 *
		 * @param authScheme auth scheme. May not be null.
		 * @param credentials user crednetials. May not be null.
		 *
		 * @since 4.2
		 */
		update(authScheme: Http.AuthScheme, credentials: Http.Credentials): void;
		/**
		 * Updates the auth state with a queue of {@link AuthOption}s.
		 *
		 * @param authOptions a queue of auth options. May not be null or empty.
		 *
		 * @since 4.2
		 */
		update(authOptions: Java.Queue<Http.AuthOption>): void;
	}
	export module AuthState {
		/**
		 * Corresponding Java class: org.apache.http.auth.AuthState
		 * This class provides detailed information about the state of the authentication process.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.AuthState;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.RedirectStrategy
	 * A strategy for determining if an HTTP request should be redirected to
	 * a new location in response to an HTTP response received from the target
	 * server.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 *
	 * @since 4.1
	 */
	export interface RedirectStrategy extends Java.Object {
		/**
		 * Determines the redirect location given the response from the target
		 * server and the current request execution context and generates a new
		 * request to be sent to the location.
		 *
		 * @param request the executed request
		 * @param response the response received from the target server
		 * @param context the context for the request execution
		 *
		 * @return redirected request
		 */
		getRedirect(request: Http.HttpRequest, response: Http.HttpResponse, context: Http.HttpContext): Http.HttpUriRequest;
		/**
		 * Determines if a request should be redirected to a new location
		 * given the response from the target server.
		 *
		 * @param request the executed request
		 * @param response the response received from the target server
		 * @param context the context for the request execution
		 *
		 * @return {@code true} if the request should be redirected, {@code false}
		 * otherwise
		 */
		isRedirected(request: Http.HttpRequest, response: Http.HttpResponse, context: Http.HttpContext): boolean;
	}
	export module RedirectStrategy {
		/**
		 * Corresponding Java class: org.apache.http.client.RedirectStrategy
		 * A strategy for determining if an HTTP request should be redirected to
		 * a new location in response to an HTTP response received from the target
		 * server.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.AbortableHttpRequest
	 * Interface representing an HTTP request that can be aborted by shutting
	 * down the underlying HTTP connection.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link HttpExecutionAware}
	 */
	export interface AbortableHttpRequest extends Java.Object {
	}
	export module AbortableHttpRequest {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.AbortableHttpRequest
		 * Interface representing an HTTP request that can be aborted by shutting
		 * down the underlying HTTP connection.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link HttpExecutionAware}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpGet
	 * HTTP GET method.
	 * 
	 * The HTTP GET method is defined in section 9.3 of
	 * RFC2616:
	 * 
	 * 
	 * The GET method means retrieve whatever information (in the form of an
	 * entity) is identified by the Request-URI. If the Request-URI refers
	 * to a data-producing process, it is the produced data which shall be
	 * returned as the entity in the response and not the source text of the
	 * process, unless that text happens to be the output of the process.
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpGet extends Http.HttpRequestBase {
		getMethod(): string;
	}
	export module HttpGet {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpGet
		 * HTTP GET method.
		 * 
		 * The HTTP GET method is defined in section 9.3 of
		 * RFC2616:
		 * 
		 * 
		 * The GET method means retrieve whatever information (in the form of an
		 * entity) is identified by the Request-URI. If the Request-URI refers
		 * to a data-producing process, it is the produced data which shall be
		 * returned as the entity in the response and not the source text of the
		 * process, unless that text happens to be the output of the process.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpRequestBase.Static {
			new(): Http.HttpGet;
			new(uri: Java.URI): Http.HttpGet;
			/**
			 * @throws IllegalArgumentException if the uri is invalid.
			 */
			new(uri: string): Http.HttpGet;
			METHOD_NAME?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpUriRequest
	 * Extended version of the {@link HttpRequest} interface that provides
	 * convenience methods to access request properties such as request URI
	 * and method type.
	 *
	 * @since 4.0
	 */
	export interface HttpUriRequest extends Http.HttpRequest {
		/**
		 * Aborts execution of the request.
		 *
		 * @throws UnsupportedOperationException if the abort operation
		 *   is not supported / cannot be implemented.
		 */
		abort(): void;
		/**
		 * Returns the HTTP method this request uses, such as {@code GET},
		 * {@code PUT}, {@code POST}, or other.
		 */
		getMethod(): string;
		/**
		 * Returns the URI this request uses, such as
		 * {@code http://example.org/path/to/file}.
		 * 
		 * Note that the URI may be absolute URI (as above) or may be a relative URI.
		 * 
		 * 
		 * Implementations are encouraged to return
		 * the URI that was initially requested.
		 * 
		 * 
		 * To find the final URI after any redirects have been processed,
		 * please see the section entitled
		 * HTTP execution context
		 * in the
		 * HttpClient Tutorial
		 * 
		 */
		getURI(): Java.URI;
		/**
		 * Tests if the request execution has been aborted.
		 *
		 * @return {@code true} if the request execution has been aborted,
		 *   {@code false} otherwise.
		 */
		isAborted(): boolean;
	}
	export module HttpUriRequest {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpUriRequest
		 * Extended version of the {@link HttpRequest} interface that provides
		 * convenience methods to access request properties such as request URI
		 * and method type.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpRequest.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpRequestWrapper
	 * A wrapper class for {@link HttpRequest} that can be used to change properties of the current
	 * request without modifying the original object.
	 *
	 * @since 4.3
	 */
	export interface HttpRequestWrapper extends Http.AbstractHttpMessage, Http.HttpUriRequest {
		abort(): void;
		getMethod(): string;
		getOriginal(): Http.HttpRequest;
		getProtocolVersion(): Http.ProtocolVersion;
		getRequestLine(): Http.RequestLine;
		/**
		 * @since 4.4
		 */
		getTarget(): Http.HttpHost;
		getURI(): Java.URI;
		isAborted(): boolean;
		setProtocolVersion(version: Http.ProtocolVersion): void;
		setURI(uri: Java.URI): void;
		toString(): string;
	}
	export module HttpRequestWrapper {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpRequestWrapper
		 * A wrapper class for {@link HttpRequest} that can be used to change properties of the current
		 * request without modifying the original object.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.AbstractHttpMessage.Static, Http.HttpUriRequest.Static {
			HttpEntityEnclosingRequestWrapper: HttpRequestWrapper$HttpEntityEnclosingRequestWrapper.Static;
			new(): Http.HttpRequestWrapper;
			/**
			 * Creates a mutable wrapper of the original request.
			 *
			 * @param request original request
			 * @return mutable request wrappering the original one
			 */
			wrap(request: Http.HttpRequest): Http.HttpRequestWrapper;
			/**
			 * Creates a mutable wrapper of the original request.
			 *
			 * @param request original request
			 * @param target original target, if explicitly specified
			 * @return mutable request wrappering the original one
			 * @since 4.4
			 */
			wrap(request: Http.HttpRequest, target: Http.HttpHost): Http.HttpRequestWrapper;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpRequestWrapper.HttpEntityEnclosingRequestWrapper
	 */
	export interface HttpRequestWrapper$HttpEntityEnclosingRequestWrapper extends Http.HttpRequestWrapper, Http.HttpEntityEnclosingRequest {
		expectContinue(): boolean;
		getEntity(): Http.HttpEntity;
		setEntity(entity: Http.HttpEntity): void;
	}
	export module HttpRequestWrapper$HttpEntityEnclosingRequestWrapper {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpRequestWrapper.HttpEntityEnclosingRequestWrapper
		 */
		export interface Static extends Http.HttpRequestWrapper.Static, Http.HttpEntityEnclosingRequest.Static {
			new(): Http.HttpRequestWrapper$HttpEntityEnclosingRequestWrapper;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.methods.HttpPut
	 * HTTP PUT method.
	 * 
	 * The HTTP PUT method is defined in section 9.6 of
	 * RFC2616:
	 * 
	 * 
	 * The PUT method requests that the enclosed entity be stored under the
	 * supplied Request-URI. If the Request-URI refers to an already
	 * existing resource, the enclosed entity SHOULD be considered as a
	 * modified version of the one residing on the origin server.
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpPut extends Http.HttpEntityEnclosingRequestBase {
		getMethod(): string;
	}
	export module HttpPut {
		/**
		 * Corresponding Java class: org.apache.http.client.methods.HttpPut
		 * HTTP PUT method.
		 * 
		 * The HTTP PUT method is defined in section 9.6 of
		 * RFC2616:
		 * 
		 * 
		 * The PUT method requests that the enclosed entity be stored under the
		 * supplied Request-URI. If the Request-URI refers to an already
		 * existing resource, the enclosed entity SHOULD be considered as a
		 * modified version of the one residing on the origin server.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpEntityEnclosingRequestBase.Static {
			new(): Http.HttpPut;
			new(uri: Java.URI): Http.HttpPut;
			/**
			 * @throws IllegalArgumentException if the uri is invalid.
			 */
			new(uri: string): Http.HttpPut;
			METHOD_NAME?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.params.HttpClientParams
	 * An adaptor for manipulating HTTP client parameters in {@link HttpParams}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}
	 */
	export interface HttpClientParams extends Java.Object {
	}
	export module HttpClientParams {
		/**
		 * Corresponding Java class: org.apache.http.client.params.HttpClientParams
		 * An adaptor for manipulating HTTP client parameters in {@link HttpParams}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.params.AuthPolicy
	 * Standard authentication schemes supported by HttpClient.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.AuthSchemes}.
	 */
	export interface AuthPolicy extends Java.Object {
	}
	export module AuthPolicy {
		/**
		 * Corresponding Java class: org.apache.http.client.params.AuthPolicy
		 * Standard authentication schemes supported by HttpClient.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.AuthSchemes}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.params.HttpClientParamConfig
	 * @deprecated (4.3) provided for compatibility with {@link HttpParams}. Do not use.
	 *
	 * @since 4.3
	 */
	export interface HttpClientParamConfig extends Java.Object {
	}
	export module HttpClientParamConfig {
		/**
		 * Corresponding Java class: org.apache.http.client.params.HttpClientParamConfig
		 * @deprecated (4.3) provided for compatibility with {@link HttpParams}. Do not use.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.utils.URLEncodedUtils
	 * A collection of utilities for encoding URLs.
	 *
	 * @since 4.0
	 */
	export interface URLEncodedUtils extends Java.Object {
	}
	export module URLEncodedUtils {
		/**
		 * Corresponding Java class: org.apache.http.client.utils.URLEncodedUtils
		 * A collection of utilities for encoding URLs.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.URLEncodedUtils;
			/**
			 * The default HTML form content type.
			 */
			CONTENT_TYPE?: string;
			/**
			 * Returns a String that is suitable for use as an {@code application/x-www-form-urlencoded}
			 * list of parameters in an HTTP PUT or HTTP POST.
			 *
			 * @param parameters  The parameters to include.
			 * @param charset The encoding to use.
			 * @return An {@code application/x-www-form-urlencoded} string
			 */
			format(parameters: Java.List<Http.NameValuePair>, charset: string): string;
			/**
			 * Returns a String that is suitable for use as an {@code application/x-www-form-urlencoded}
			 * list of parameters in an HTTP PUT or HTTP POST.
			 *
			 * @param parameters  The parameters to include.
			 * @param parameterSeparator The parameter separator, by convention, {@code '&'} or {@code ';'}.
			 * @param charset The encoding to use.
			 * @return An {@code application/x-www-form-urlencoded} string
			 *
			 * @since 4.3
			 */
			format(parameters: Java.List<Http.NameValuePair>, parameterSeparator: char, charset: string): string;
			/**
			 * Returns a String that is suitable for use as an {@code application/x-www-form-urlencoded}
			 * list of parameters in an HTTP PUT or HTTP POST.
			 *
			 * @param parameters  The parameters to include.
			 * @param charset The encoding to use.
			 * @return An {@code application/x-www-form-urlencoded} string
			 *
			 * @since 4.2
			 */
			format(parameters: Java.Iterable<Http.NameValuePair>, charset: Java.Charset): string;
			/**
			 * Returns a String that is suitable for use as an {@code application/x-www-form-urlencoded}
			 * list of parameters in an HTTP PUT or HTTP POST.
			 *
			 * @param parameters  The parameters to include.
			 * @param parameterSeparator The parameter separator, by convention, {@code '&'} or {@code ';'}.
			 * @param charset The encoding to use.
			 * @return An {@code application/x-www-form-urlencoded} string
			 *
			 * @since 4.3
			 */
			format(parameters: Java.Iterable<Http.NameValuePair>, parameterSeparator: char, charset: Java.Charset): string;
			/**
			 * Returns true if the entity's Content-Type header is
			 * {@code application/x-www-form-urlencoded}.
			 */
			isEncoded(entity: Http.HttpEntity): boolean;
			/**
			 * Returns a list of {@link NameValuePair NameValuePairs} as built from the URI's query portion. For example, a URI
			 * of {@code http://example.org/path/to/file?a=1&b=2&c=3} would return a list of three NameValuePairs, one for a=1,
			 * one for b=2, and one for c=3. By convention, {@code '&'} and {@code ';'} are accepted as parameter separators.
			 * 
			 * This is typically useful while parsing an HTTP PUT.
			 *
			 * This API is currently only used for testing.
			 *
			 * @param uri
			 *        URI to parse
			 * @param charset
			 *        Charset to use while parsing the query
			 * @return a list of {@link NameValuePair} as built from the URI's query portion.
			 *
			 * @since 4.5
			 */
			parse(uri: Java.URI, charset: Java.Charset): Java.List<Http.NameValuePair>;
			/**
			 * Returns a list of {@link NameValuePair NameValuePairs} as parsed from an {@link HttpEntity}.
			 * The encoding is taken from the entity's Content-Encoding header.
			 * 
			 * This is typically used while parsing an HTTP POST.
			 *
			 * @param entity
			 *            The entity to parse
			 * @return a list of {@link NameValuePair} as built from the URI's query portion.
			 * @throws IOException
			 *             If there was an exception getting the entity's data.
			 */
			parse(entity: Http.HttpEntity): Java.List<Http.NameValuePair>;
			/**
			 * Returns a list of {@link NameValuePair NameValuePairs} as parsed from the given string using the given character
			 * encoding. By convention, {@code '&'} and {@code ';'} are accepted as parameter separators.
			 *
			 * @param s
			 *            text to parse.
			 * @param charset
			 *            Encoding to use when decoding the parameters.
			 * @return a list of {@link NameValuePair} as built from the URI's query portion.
			 *
			 * @since 4.2
			 */
			parse(s: string, charset: Java.Charset): Java.List<Http.NameValuePair>;
			/**
			 * Returns a list of {@link NameValuePair NameValuePairs} as parsed from the given string using the given character
			 * encoding.
			 *
			 * @param s
			 *            text to parse.
			 * @param charset
			 *            Encoding to use when decoding the parameters.
			 * @param separators
			 *            element separators.
			 * @return a list of {@link NameValuePair} as built from the URI's query portion.
			 *
			 * @since 4.3
			 */
			parse(s: string, charset: Java.Charset, ...separators: char[]): Java.List<Http.NameValuePair>;
			/**
			 * Returns a list of {@link NameValuePair NameValuePairs} as parsed from the given string using the given character
			 * encoding.
			 *
			 * @param s
			 *            text to parse.
			 * @param charset
			 *            Encoding to use when decoding the parameters.
			 * @param separators
			 *            element separators.
			 * @return a list of {@link NameValuePair} as built from the URI's query portion.
			 *
			 * @since 4.3
			 */
			parse(s: string, charset: Java.Charset, separators: array<char>): Java.List<Http.NameValuePair>;
			/**
			 * Returns a list of {@link NameValuePair NameValuePairs} as parsed from the given string using
			 * the given character encoding.
			 *
			 * @param buf
			 *            text to parse.
			 * @param charset
			 *            Encoding to use when decoding the parameters.
			 * @param separators
			 *            element separators.
			 * @return a list of {@link NameValuePair} as built from the URI's query portion.
			 *
			 * @since 4.4
			 */
			parse(buf: Http.CharArrayBuffer, charset: Java.Charset, ...separators: char[]): Java.List<Http.NameValuePair>;
			/**
			 * Returns a list of {@link NameValuePair NameValuePairs} as parsed from the given string using
			 * the given character encoding.
			 *
			 * @param buf
			 *            text to parse.
			 * @param charset
			 *            Encoding to use when decoding the parameters.
			 * @param separators
			 *            element separators.
			 * @return a list of {@link NameValuePair} as built from the URI's query portion.
			 *
			 * @since 4.4
			 */
			parse(buf: Http.CharArrayBuffer, charset: Java.Charset, separators: array<char>): Java.List<Http.NameValuePair>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.RequestAcceptEncoding
	 * Class responsible for handling Content Encoding requests in HTTP.
	 * 
	 * Instances of this class are stateless, therefore they're thread-safe and immutable.
	 *
	 * @see "http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5"
	 *
	 * @since 4.1
	 */
	export interface RequestAcceptEncoding extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestAcceptEncoding {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.RequestAcceptEncoding
		 * Class responsible for handling Content Encoding requests in HTTP.
		 * 
		 * Instances of this class are stateless, therefore they're thread-safe and immutable.
		 *
		 * @see "http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5"
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			/**
			 * @since 4.4
			 */
			new(encodings: Java.List<string>): Http.RequestAcceptEncoding;
			new(): Http.RequestAcceptEncoding;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.RequestDefaultHeaders
	 * Request interceptor that adds default request headers.
	 *
	 * @since 4.0
	 */
	export interface RequestDefaultHeaders extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestDefaultHeaders {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.RequestDefaultHeaders
		 * Request interceptor that adds default request headers.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			/**
			 * @since 4.3
			 */
			new(defaultHeaders: Java.Collection<Http.Header>): Http.RequestDefaultHeaders;
			new(): Http.RequestDefaultHeaders;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.protocol.RequestTargetAuthentication
	 * Generates authentication header for the target host, if required,
	 * based on the actual state of the HTTP authentication context.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.impl.auth.HttpAuthenticator}.
	 */
	export interface RequestTargetAuthentication extends Http.RequestAuthenticationBase {
	}
	export module RequestTargetAuthentication {
		/**
		 * Corresponding Java class: org.apache.http.client.protocol.RequestTargetAuthentication
		 * Generates authentication header for the target host, if required,
		 * based on the actual state of the HTTP authentication context.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.impl.auth.HttpAuthenticator}.
		 */
		export interface Static extends Http.RequestAuthenticationBase.Static {
			new(): Http.RequestTargetAuthentication;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.ResponseHandler
	 * Handler that encapsulates the process of generating a response object
	 * from a {@link HttpResponse}.
	 *
	 *
	 * @since 4.0
	 */
	export interface ResponseHandler<T = any> extends Java.Object {
		/**
		 * Processes an {@link HttpResponse} and returns some value
		 * corresponding to that response.
		 *
		 * @param response The response to process
		 * @return A value determined by the response
		 *
		 * @throws ClientProtocolException in case of an http protocol error
		 * @throws IOException in case of a problem or the connection was aborted
		 */
		handleResponse(response: Http.HttpResponse): T;
	}
	export module ResponseHandler {
		/**
		 * Corresponding Java class: org.apache.http.client.ResponseHandler
		 * Handler that encapsulates the process of generating a response object
		 * from a {@link HttpResponse}.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.NonRepeatableRequestException
	 * Signals failure to retry the request due to non-repeatable request
	 * entity.
	 *
	 *
	 * @since 4.0
	 */
	export interface NonRepeatableRequestException extends Http.ProtocolException {
	}
	export module NonRepeatableRequestException {
		/**
		 * Corresponding Java class: org.apache.http.client.NonRepeatableRequestException
		 * Signals failure to retry the request due to non-repeatable request
		 * entity.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.ProtocolException.Static {
			/**
			 * Creates a new NonRepeatableEntityException with a {@code null} detail message.
			 */
			new(): Http.NonRepeatableRequestException;
			/**
			 * Creates a new NonRepeatableEntityException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.NonRepeatableRequestException;
			/**
			 * Creates a new NonRepeatableEntityException with the specified detail message.
			 *
			 * @param message The exception detail message
			 * @param cause the cause
			 */
			new(message: string, cause: Java.Throwable): Http.NonRepeatableRequestException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.UrlEncodedFormEntity
	 * An entity composed of a list of url-encoded pairs.
	 * This is typically useful while sending an HTTP POST request.
	 *
	 * @since 4.0
	 */
	export interface UrlEncodedFormEntity extends Http.StringEntity {
	}
	export module UrlEncodedFormEntity {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.UrlEncodedFormEntity
		 * An entity composed of a list of url-encoded pairs.
		 * This is typically useful while sending an HTTP POST request.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.StringEntity.Static {
			/**
			 * Constructs a new {@link UrlEncodedFormEntity} with the list
			 * of parameters in the specified encoding.
			 *
			 * @param parameters list of name/value pairs
			 * @param charset encoding the name/value pairs be encoded with
			 * @throws UnsupportedEncodingException if the encoding isn't supported
			 */
			new(parameters: Java.List<Http.NameValuePair>, charset: string): Http.UrlEncodedFormEntity;
			/**
			 * Constructs a new {@link UrlEncodedFormEntity} with the list
			 * of parameters in the specified encoding.
			 *
			 * @param parameters iterable collection of name/value pairs
			 * @param charset encoding the name/value pairs be encoded with
			 *
			 * @since 4.2
			 */
			new(parameters: Java.Iterable<Http.NameValuePair>, charset: Java.Charset): Http.UrlEncodedFormEntity;
			/**
			 * Constructs a new {@link UrlEncodedFormEntity} with the list
			 * of parameters with the default encoding of {@link HTTP#DEFAULT_CONTENT_CHARSET}
			 *
			 * @param parameters list of name/value pairs
			 * @throws UnsupportedEncodingException if the default encoding isn't supported
			 */
			new(parameters: Java.List<Http.NameValuePair>): Http.UrlEncodedFormEntity;
			/**
			 * Constructs a new {@link UrlEncodedFormEntity} with the list
			 * of parameters with the default encoding of {@link HTTP#DEFAULT_CONTENT_CHARSET}
			 *
			 * @param parameters iterable collection of name/value pairs
			 *
			 * @since 4.2
			 */
			new(parameters: Java.Iterable<Http.NameValuePair>): Http.UrlEncodedFormEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.LazyDecompressingInputStream
	 * Lazy init InputStream wrapper.
	 */
	export interface LazyDecompressingInputStream extends Java.InputStream {
		available(): int;
		close(): void;
		markSupported(): boolean;
		read(): int;
		read(b: array<byte>): int;
		read(b: array<byte>, off: int, len: int): int;
		skip(n: long): long;
	}
	export module LazyDecompressingInputStream {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.LazyDecompressingInputStream
		 * Lazy init InputStream wrapper.
		 */
		export interface Static extends Java.InputStream.Static {
			new(wrappedStream: Java.InputStream, inputStreamFactory: Http.InputStreamFactory): Http.LazyDecompressingInputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.GzipDecompressingEntity
	 * {@link org.apache.http.entity.HttpEntityWrapper} for handling gzip
	 * Content Coded responses.
	 *
	 * @since 4.1
	 */
	export interface GzipDecompressingEntity extends Http.DecompressingEntity {
	}
	export module GzipDecompressingEntity {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.GzipDecompressingEntity
		 * {@link org.apache.http.entity.HttpEntityWrapper} for handling gzip
		 * Content Coded responses.
		 *
		 * @since 4.1
		 */
		export interface Static extends Http.DecompressingEntity.Static {
			/**
			 * Creates a new {@link GzipDecompressingEntity} which will wrap the specified
			 * {@link HttpEntity}.
			 *
			 * @param entity
			 *            the non-null {@link HttpEntity} to be wrapped
			 */
			new(entity: Http.HttpEntity): Http.GzipDecompressingEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.entity.DeflateInputStreamFactory
	 * {@link InputStreamFactory} for handling Deflate Content Coded responses.
	 *
	 * @since 4.5.4
	 */
	export interface DeflateInputStreamFactory extends Java.Object, Http.InputStreamFactory {
		create(inputStream: Java.InputStream): Java.InputStream;
	}
	export module DeflateInputStreamFactory {
		/**
		 * Corresponding Java class: org.apache.http.client.entity.DeflateInputStreamFactory
		 * {@link InputStreamFactory} for handling Deflate Content Coded responses.
		 *
		 * @since 4.5.4
		 */
		export interface Static extends Java.Object.Static, Http.InputStreamFactory.Static {
			new(): Http.DeflateInputStreamFactory;
			/**
			 * Gets the singleton instance.
			 *
			 * @return the singleton instance.
			 */
			getInstance(): Http.DeflateInputStreamFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.client.ServiceUnavailableRetryStrategy
	 * Strategy interface that allows API users to plug in their own logic to
	 * control whether or not a retry should automatically be done, how many times
	 * it should be retried and so on.
	 *
	 * @since 4.2
	 */
	export interface ServiceUnavailableRetryStrategy extends Java.Object {
		/**
		 * @return The interval between the subsequent auto-retries.
		 */
		getRetryInterval(): long;
		/**
		 * Determines if a method should be retried given the response from the target server.
		 *
		 * @param response the response from the target server
		 * @param executionCount the number of times this method has been
		 * unsuccessfully executed
		 * @param context the context for the request execution
		 * @return {@code true} if the method should be retried, {@code false}
		 * otherwise
		 */
		retryRequest(response: Http.HttpResponse, executionCount: int, context: Http.HttpContext): boolean;
	}
	export module ServiceUnavailableRetryStrategy {
		/**
		 * Corresponding Java class: org.apache.http.client.ServiceUnavailableRetryStrategy
		 * Strategy interface that allows API users to plug in their own logic to
		 * control whether or not a retry should automatically be done, how many times
		 * it should be retried and so on.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ConnectionRequest
	 * Represents a request for a {@link HttpClientConnection} whose life cycle
	 * is managed by a connection manager.
	 *
	 * @since 4.3
	 */
	export interface ConnectionRequest extends Http.Cancellable {
		/**
		 * Obtains a connection within a given time.
		 * This method will block until a connection becomes available,
		 * the timeout expires, or the connection manager is shut down.
		 * Timeouts are handled with millisecond precision.
		 *
		 * If {@link #cancel()} is called while this is blocking or
		 * before this began, an {@link InterruptedException} will
		 * be thrown.
		 *
		 * @param timeout   the timeout, 0 or negative for no timeout
		 * @param tunit     the unit for the {@code timeout},
		 *                  may be {@code null} only if there is no timeout
		 *
		 * @return  a connection that can be used to communicate
		 *          along the given route
		 *
		 * @throws ConnectionPoolTimeoutException
		 *         in case of a timeout
		 * @throws InterruptedException
		 *         if the calling thread is interrupted while waiting
		 */
		get(timeout: long, tunit: Java.TimeUnit): Http.HttpClientConnection;
	}
	export module ConnectionRequest {
		/**
		 * Corresponding Java class: org.apache.http.conn.ConnectionRequest
		 * Represents a request for a {@link HttpClientConnection} whose life cycle
		 * is managed by a connection manager.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.Cancellable.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnManagerParams
	 * An adaptor for manipulating HTTP connection management
	 * parameters in {@link HttpParams}.
	 *
	 * @since 4.0
	 *
	 * @see ConnManagerPNames
	 *
	 * @deprecated (4.1) use configuration methods of the specific connection manager implementation.
	 */
	export interface ConnManagerParams extends Java.Object, Http.ConnManagerPNames {
	}
	export module ConnManagerParams {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnManagerParams
		 * An adaptor for manipulating HTTP connection management
		 * parameters in {@link HttpParams}.
		 *
		 * @since 4.0
		 *
		 * @see ConnManagerPNames
		 *
		 * @deprecated (4.1) use configuration methods of the specific connection manager implementation.
		 */
		export interface Static extends Java.Object.Static, Http.ConnManagerPNames.Static {
			new(): Http.ConnManagerParams;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnConnectionPNames
	 * Parameter names for HTTP client connections.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1) use custom {@link
	 *   org.apache.http.impl.conn.DefaultHttpResponseParser} implementation.
	 */
	export interface ConnConnectionPNames extends Java.Object {
	}
	export module ConnConnectionPNames {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnConnectionPNames
		 * Parameter names for HTTP client connections.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1) use custom {@link
		 *   org.apache.http.impl.conn.DefaultHttpResponseParser} implementation.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.params.ConnRoutePNames
	 * Parameter names for connection routing.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
	 */
	export interface ConnRoutePNames extends Java.Object {
	}
	export module ConnRoutePNames {
		/**
		 * Corresponding Java class: org.apache.http.conn.params.ConnRoutePNames
		 * Parameter names for connection routing.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.socket.PlainConnectionSocketFactory
	 * The default class for creating plain (unencrypted) sockets.
	 *
	 * @since 4.3
	 */
	export interface PlainConnectionSocketFactory extends Java.Object, Http.ConnectionSocketFactory {
		connectSocket(connectTimeout: int, socket: Java.Socket, host: Http.HttpHost, remoteAddress: Java.InetSocketAddress, localAddress: Java.InetSocketAddress, context: Http.HttpContext): Java.Socket;
		createSocket(context: Http.HttpContext): Java.Socket;
	}
	export module PlainConnectionSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.socket.PlainConnectionSocketFactory
		 * The default class for creating plain (unencrypted) sockets.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionSocketFactory.Static {
			new(): Http.PlainConnectionSocketFactory;
			INSTANCE?: Http.PlainConnectionSocketFactory;
			getSocketFactory(): Http.PlainConnectionSocketFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ClientConnectionRequest
	 * Encapsulates a request for a {@link ManagedClientConnection}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) replaced by {@link ConnectionRequest}.
	 */
	export interface ClientConnectionRequest extends Java.Object {
	}
	export module ClientConnectionRequest {
		/**
		 * Corresponding Java class: org.apache.http.conn.ClientConnectionRequest
		 * Encapsulates a request for a {@link ManagedClientConnection}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) replaced by {@link ConnectionRequest}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.TrustAllStrategy
	 * A trust strategy that accepts all certificates as trusted. Verification of
	 * all other certificates is done by the trust manager configured in the SSL
	 * context.
	 *
	 * @since 4.5.4
	 */
	export interface TrustAllStrategy extends Java.Object, Http.ConnectionTrustStrategy {
		isTrusted(chain: array<Java.X509Certificate>, authType: string): boolean;
	}
	export module TrustAllStrategy {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.TrustAllStrategy
		 * A trust strategy that accepts all certificates as trusted. Verification of
		 * all other certificates is done by the trust manager configured in the SSL
		 * context.
		 *
		 * @since 4.5.4
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionTrustStrategy.Static {
			new(): Http.TrustAllStrategy;
			INSTANCE?: Http.TrustAllStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.ssl.BrowserCompatHostnameVerifier
	 * The HostnameVerifier that works the same way as Curl and Firefox.
	 * 
	 * The hostname must match either the first CN, or any of the subject-alts.
	 * A wildcard can occur in the CN, and in any of the subject-alts.
	 * 
	 * 
	 * The only difference between BROWSER_COMPATIBLE and STRICT is that a wildcard
	 * (such as "*.foo.com") with BROWSER_COMPATIBLE matches all subdomains,
	 * including "a.b.foo.com".
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.4) Use {@link org.apache.http.conn.ssl.DefaultHostnameVerifier}
	 */
	export interface BrowserCompatHostnameVerifier extends Http.AbstractVerifier {
	}
	export module BrowserCompatHostnameVerifier {
		/**
		 * Corresponding Java class: org.apache.http.conn.ssl.BrowserCompatHostnameVerifier
		 * The HostnameVerifier that works the same way as Curl and Firefox.
		 * 
		 * The hostname must match either the first CN, or any of the subject-alts.
		 * A wildcard can occur in the CN, and in any of the subject-alts.
		 * 
		 * 
		 * The only difference between BROWSER_COMPATIBLE and STRICT is that a wildcard
		 * (such as "*.foo.com") with BROWSER_COMPATIBLE matches all subdomains,
		 * including "a.b.foo.com".
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.4) Use {@link org.apache.http.conn.ssl.DefaultHostnameVerifier}
		 */
		export interface Static extends Http.AbstractVerifier.Static {
			new(): Http.BrowserCompatHostnameVerifier;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.SchemeLayeredSocketFactory
	 * Extended {@link SchemeSocketFactory} interface for layered sockets such as SSL/TLS.
	 *
	 * @since 4.2
	 *
	 * @deprecated (4.3) use {@link
	 *   org.apache.http.conn.socket.LayeredConnectionSocketFactory}
	 */
	export interface SchemeLayeredSocketFactory extends Http.SchemeSocketFactory {
	}
	export module SchemeLayeredSocketFactory {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.SchemeLayeredSocketFactory
		 * Extended {@link SchemeSocketFactory} interface for layered sockets such as SSL/TLS.
		 *
		 * @since 4.2
		 *
		 * @deprecated (4.3) use {@link
		 *   org.apache.http.conn.socket.LayeredConnectionSocketFactory}
		 */
		export interface Static extends Http.SchemeSocketFactory.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.conn.scheme.HostNameResolver
	 * Hostname to IP address resolver.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.1)  Do not use
	 */
	export interface HostNameResolver extends Java.Object {
	}
	export module HostNameResolver {
		/**
		 * Corresponding Java class: org.apache.http.conn.scheme.HostNameResolver
		 * Hostname to IP address resolver.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.1)  Do not use
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * @deprecated
	 * Corresponding Java class: org.apache.http.conn.scheme.SocketFactoryAdaptor
	 */
	export interface SocketFactoryAdaptor extends Java.Object, Http.SocketFactory {
	}
	export module SocketFactoryAdaptor {
		/**
		 * @deprecated
		 * Corresponding Java class: org.apache.http.conn.scheme.SocketFactoryAdaptor
		 */
		export interface Static extends Java.Object.Static, Http.SocketFactory.Static {
			new(): Http.SocketFactoryAdaptor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngine
	 * Abstract NTLM authentication engine. The engine can be used to
	 * generate Type1 messages and Type3 messages in response to a
	 * Type2 challenge.
	 *
	 * @since 4.0
	 */
	export interface NTLMEngine extends Java.Object {
		/**
		 * Generates a Type1 message given the domain and workstation.
		 *
		 * @param domain Optional Windows domain name. Can be {@code null}.
		 * @param workstation Optional Windows workstation name. Can be
		 *  {@code null}.
		 * @return Type1 message
		 * @throws NTLMEngineException
		 */
		generateType1Msg(domain: string, workstation: string): string;
		/**
		 * Generates a Type3 message given the user credentials and the
		 * authentication challenge.
		 *
		 * @param username Windows user name
		 * @param password Password
		 * @param domain Windows domain name
		 * @param workstation Windows workstation name
		 * @param challenge Type2 challenge.
		 * @return Type3 response.
		 * @throws NTLMEngineException
		 */
		generateType3Msg(username: string, password: string, domain: string, workstation: string, challenge: string): string;
	}
	export module NTLMEngine {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.NTLMEngine
		 * Abstract NTLM authentication engine. The engine can be used to
		 * generate Type1 messages and Type3 messages in response to a
		 * Type2 challenge.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.DigestScheme
	 * Digest authentication scheme as defined in RFC 2617.
	 * Both MD5 (default) and MD5-sess are supported.
	 * Currently only qop=auth or no qop is supported. qop=auth-int
	 * is unsupported. If auth and auth-int are provided, auth is
	 * used.
	 * 
	 * Since the digest username is included as clear text in the generated
	 * Authentication header, the charset of the username must be compatible
	 * with the HTTP element charset used by the connection.
	 * 
	 *
	 * @since 4.0
	 */
	export interface DigestScheme extends Http.RFC2617Scheme {
		/**
		 * Produces a digest authorization string for the given set of
		 * {@link Credentials}, method name and URI.
		 *
		 * @param credentials A set of credentials to be used for athentication
		 * @param request    The request being authenticated
		 *
		 * @throws org.apache.http.auth.InvalidCredentialsException if authentication credentials
		 *         are not valid or not applicable for this authentication scheme
		 * @throws AuthenticationException if authorization string cannot
		 *   be generated due to an authentication failure
		 *
		 * @return a digest authorization string
		 */
		authenticate(credentials: Http.Credentials, request: Http.HttpRequest, context: Http.HttpContext): Http.Header;
		/**
		 * Returns textual designation of the digest authentication scheme.
		 *
		 * @return {@code digest}
		 */
		getSchemeName(): string;
		/**
		 * Tests if the Digest authentication process has been completed.
		 *
		 * @return {@code true} if Digest authorization has been processed,
		 *   {@code false} otherwise.
		 */
		isComplete(): boolean;
		/**
		 * Returns {@code false}. Digest authentication scheme is request based.
		 *
		 * @return {@code false}.
		 */
		isConnectionBased(): boolean;
		overrideParamter(name: string, value: string): void;
		/**
		 * Processes the Digest challenge.
		 *
		 * @param header the challenge header
		 *
		 * @throws MalformedChallengeException is thrown if the authentication challenge
		 * is malformed
		 */
		processChallenge(header: Http.Header): void;
		toString(): string;
	}
	export module DigestScheme {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.DigestScheme
		 * Digest authentication scheme as defined in RFC 2617.
		 * Both MD5 (default) and MD5-sess are supported.
		 * Currently only qop=auth or no qop is supported. qop=auth-int
		 * is unsupported. If auth and auth-int are provided, auth is
		 * used.
		 * 
		 * Since the digest username is included as clear text in the generated
		 * Authentication header, the charset of the username must be compatible
		 * with the HTTP element charset used by the connection.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.RFC2617Scheme.Static {
			/**
			 * @since 4.3
			 */
			new(credentialsCharset: Java.Charset): Http.DigestScheme;
			new(): Http.DigestScheme;
			/**
			 * Creates a random cnonce value based on the current time.
			 *
			 * @return The cnonce value as String.
			 */
			createCnonce(): string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.AuthSchemeBase
	 * Abstract authentication scheme class that serves as a basis
	 * for all authentication schemes supported by HttpClient. This class
	 * defines the generic way of parsing an authentication challenge. It
	 * does not make any assumptions regarding the format of the challenge
	 * nor does it impose any specific way of responding to that challenge.
	 *
	 *
	 * @since 4.0
	 */
	export interface AuthSchemeBase extends Java.Object, Http.ContextAwareAuthScheme {
		authenticate(credentials: Http.Credentials, request: Http.HttpRequest, context: Http.HttpContext): Http.Header;
		/**
		 * Returns {@link ChallengeState} value or {@code null} if unchallenged.
		 *
		 * @since 4.2
		 */
		getChallengeState(): Http.ChallengeState;
		/**
		 * Returns {@code true} if authenticating against a proxy, {@code false}
		 * otherwise.
		 */
		isProxy(): boolean;
		/**
		 * Processes the given challenge token. Some authentication schemes
		 * may involve multiple challenge-response exchanges. Such schemes must be able
		 * to maintain the state information when dealing with sequential challenges
		 *
		 * @param header the challenge header
		 *
		 * @throws MalformedChallengeException is thrown if the authentication challenge
		 * is malformed
		 */
		processChallenge(header: Http.Header): void;
		toString(): string;
	}
	export module AuthSchemeBase {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.AuthSchemeBase
		 * Abstract authentication scheme class that serves as a basis
		 * for all authentication schemes supported by HttpClient. This class
		 * defines the generic way of parsing an authentication challenge. It
		 * does not make any assumptions regarding the format of the challenge
		 * nor does it impose any specific way of responding to that challenge.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.ContextAwareAuthScheme.Static {
			new(): Http.AuthSchemeBase;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.DigestSchemeFactory
	 * {@link AuthSchemeProvider} implementation that creates and initializes
	 * {@link DigestScheme} instances.
	 *
	 * @since 4.0
	 */
	export interface DigestSchemeFactory extends Java.Object, Http.AuthSchemeFactory, Http.AuthSchemeProvider {
		create(context: Http.HttpContext): Http.AuthScheme;
		newInstance(params: Http.HttpParams): Http.AuthScheme;
	}
	export module DigestSchemeFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.DigestSchemeFactory
		 * {@link AuthSchemeProvider} implementation that creates and initializes
		 * {@link DigestScheme} instances.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.AuthSchemeFactory.Static, Http.AuthSchemeProvider.Static {
			/**
			 * @since 4.3
			 */
			new(charset: Java.Charset): Http.DigestSchemeFactory;
			new(): Http.DigestSchemeFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.auth.BasicScheme
	 * Basic authentication scheme as defined in RFC 2617.
	 *
	 * @since 4.0
	 */
	export interface BasicScheme extends Http.RFC2617Scheme {
		/**
		 * Produces basic authorization header for the given set of {@link Credentials}.
		 *
		 * @param credentials The set of credentials to be used for authentication
		 * @param request The request being authenticated
		 * @throws org.apache.http.auth.InvalidCredentialsException if authentication
		 *   credentials are not valid or not applicable for this authentication scheme
		 * @throws AuthenticationException if authorization string cannot
		 *   be generated due to an authentication failure
		 *
		 * @return a basic authorization string
		 */
		authenticate(credentials: Http.Credentials, request: Http.HttpRequest, context: Http.HttpContext): Http.Header;
		/**
		 * Returns textual designation of the basic authentication scheme.
		 *
		 * @return {@code basic}
		 */
		getSchemeName(): string;
		/**
		 * Tests if the Basic authentication process has been completed.
		 *
		 * @return {@code true} if Basic authorization has been processed,
		 *   {@code false} otherwise.
		 */
		isComplete(): boolean;
		/**
		 * Returns {@code false}. Basic authentication scheme is request based.
		 *
		 * @return {@code false}.
		 */
		isConnectionBased(): boolean;
		/**
		 * Processes the Basic challenge.
		 *
		 * @param header the challenge header
		 *
		 * @throws MalformedChallengeException is thrown if the authentication challenge
		 * is malformed
		 */
		processChallenge(header: Http.Header): void;
		toString(): string;
	}
	export module BasicScheme {
		/**
		 * Corresponding Java class: org.apache.http.impl.auth.BasicScheme
		 * Basic authentication scheme as defined in RFC 2617.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.RFC2617Scheme.Static {
			/**
			 * @since 4.3
			 */
			new(credentialsCharset: Java.Charset): Http.BasicScheme;
			new(): Http.BasicScheme;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BestMatchSpec
	 * 'Meta' cookie specification that picks up a cookie policy based on
	 * the format of cookies sent with the HTTP response.
	 *
	 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.DefaultCookieSpec}.
	 *
	 * @since 4.0
	 */
	export interface BestMatchSpec extends Http.DefaultCookieSpec {
	}
	export module BestMatchSpec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BestMatchSpec
		 * 'Meta' cookie specification that picks up a cookie policy based on
		 * the format of cookies sent with the HTTP response.
		 *
		 * @deprecated (4.4) use {@link org.apache.http.impl.cookie.DefaultCookieSpec}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.DefaultCookieSpec.Static {
			new(): Http.BestMatchSpec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.BasicSecureHandler
	 *
	 * @since 4.0
	 */
	export interface BasicSecureHandler extends Http.AbstractCookieAttributeHandler, Http.CommonCookieAttributeHandler {
		getAttributeName(): string;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(cookie: Http.SetCookie, value: string): void;
	}
	export module BasicSecureHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.BasicSecureHandler
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractCookieAttributeHandler.Static, Http.CommonCookieAttributeHandler.Static {
			new(): Http.BasicSecureHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965Spec
	 * RFC 2965 compliant {@link org.apache.http.cookie.CookieSpec} implementation.
	 * 
	 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265StrictSpec}.
	 *
	 * @since 4.0
	 * @see org.apache.http.impl.cookie.RFC6265StrictSpec
	 */
	export interface RFC2965Spec extends Http.RFC2109Spec {
		getVersion(): int;
		getVersionHeader(): Http.Header;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(header: Http.Header, origin: Http.CookieOrigin): Java.List<Http.Cookie>;
		toString(): string;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC2965Spec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC2965Spec
		 * RFC 2965 compliant {@link org.apache.http.cookie.CookieSpec} implementation.
		 * 
		 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265StrictSpec}.
		 *
		 * @since 4.0
		 * @see org.apache.http.impl.cookie.RFC6265StrictSpec
		 */
		export interface Static extends Http.RFC2109Spec.Static {
			/**
			 * Default constructor
			 *
			 */
			new(): Http.RFC2965Spec;
			new(datepatterns: array<string>, oneHeader: boolean): Http.RFC2965Spec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.DefaultCookieSpecProvider
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * {@link org.apache.http.impl.cookie.DefaultCookieSpec}. The instance returned by this factory can
	 * be shared by multiple threads.
	 *
	 * @since 4.4
	 */
	export interface DefaultCookieSpecProvider extends Java.Object, Http.CookieSpecProvider {
		create(context: Http.HttpContext): Http.CookieSpec;
	}
	export module DefaultCookieSpecProvider {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.DefaultCookieSpecProvider
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * {@link org.apache.http.impl.cookie.DefaultCookieSpec}. The instance returned by this factory can
		 * be shared by multiple threads.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecProvider.Static {
			new(compatibilityLevel: Http.DefaultCookieSpecProvider$CompatibilityLevel, publicSuffixMatcher: Http.PublicSuffixMatcher, datepatterns: array<string>, oneHeader: boolean): Http.DefaultCookieSpecProvider;
			new(compatibilityLevel: Http.DefaultCookieSpecProvider$CompatibilityLevel, publicSuffixMatcher: Http.PublicSuffixMatcher): Http.DefaultCookieSpecProvider;
			new(publicSuffixMatcher: Http.PublicSuffixMatcher): Http.DefaultCookieSpecProvider;
			new(): Http.DefaultCookieSpecProvider;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.DefaultCookieSpecProvider.CompatibilityLevel
	 */
	export interface DefaultCookieSpecProvider$CompatibilityLevel extends Java.Enum<DefaultCookieSpecProvider$CompatibilityLevel> {
	}
	export module DefaultCookieSpecProvider$CompatibilityLevel {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.DefaultCookieSpecProvider.CompatibilityLevel
		 */
		export interface Static extends Java.Enum.Static {
			DEFAULT?: Http.DefaultCookieSpecProvider$CompatibilityLevel;
			IE_MEDIUM_SECURITY?: Http.DefaultCookieSpecProvider$CompatibilityLevel;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265CookieSpec
	 * Cookie management functions shared by RFC C6265 compliant specification.
	 *
	 * @since 4.5
	 */
	export interface RFC6265CookieSpec extends Java.Object, Http.CookieSpec {
		formatCookies(cookies: Java.List<Http.Cookie>): Java.List<Http.Header>;
		getVersion(): int;
		getVersionHeader(): Http.Header;
		match(cookie: Http.Cookie, origin: Http.CookieOrigin): boolean;
		parse(header: Http.Header, origin: Http.CookieOrigin): Java.List<Http.Cookie>;
		validate(cookie: Http.Cookie, origin: Http.CookieOrigin): void;
	}
	export module RFC6265CookieSpec {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.RFC6265CookieSpec
		 * Cookie management functions shared by RFC C6265 compliant specification.
		 *
		 * @since 4.5
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpec.Static {
			new(): Http.RFC6265CookieSpec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.DateUtils
	 * A utility class for parsing and formatting HTTP dates as used in cookies and
	 * other headers.  This class handles dates as defined by RFC 2616 section
	 * 3.3.1 as well as some other common non-standard formats.
	 *
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) Use {@link org.apache.http.client.utils.DateUtils}.
	 */
	export interface CookieDateUtils extends Java.Object {
	}
	export module CookieDateUtils {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.DateUtils
		 * A utility class for parsing and formatting HTTP dates as used in cookies and
		 * other headers.  This class handles dates as defined by RFC 2616 section
		 * 3.3.1 as well as some other common non-standard formats.
		 *
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) Use {@link org.apache.http.client.utils.DateUtils}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDraftSpecProvider
	 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
	 * {@link NetscapeDraftSpec}. The instance returned by this factory
	 * can be shared by multiple threads.
	 * 
	 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265CookieSpecProvider}
	 *
	 * @since 4.4
	 * @see org.apache.http.impl.cookie.RFC6265CookieSpecProvider
	 */
	export interface NetscapeDraftSpecProvider extends Java.Object, Http.CookieSpecProvider {
		create(context: Http.HttpContext): Http.CookieSpec;
	}
	export module NetscapeDraftSpecProvider {
		/**
		 * Corresponding Java class: org.apache.http.impl.cookie.NetscapeDraftSpecProvider
		 * {@link org.apache.http.cookie.CookieSpecProvider} implementation that provides an instance of
		 * {@link NetscapeDraftSpec}. The instance returned by this factory
		 * can be shared by multiple threads.
		 * 
		 * Rendered obsolete by {@link org.apache.http.impl.cookie.RFC6265CookieSpecProvider}
		 *
		 * @since 4.4
		 * @see org.apache.http.impl.cookie.RFC6265CookieSpecProvider
		 */
		export interface Static extends Java.Object.Static, Http.CookieSpecProvider.Static {
			new(datepatterns: array<string>): Http.NetscapeDraftSpecProvider;
			new(): Http.NetscapeDraftSpecProvider;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.LaxRedirectStrategy
	 * Lax {@link org.apache.http.client.RedirectStrategy} implementation
	 * that automatically redirects all HEAD, GET, POST, and DELETE requests.
	 * This strategy relaxes restrictions on automatic redirection of
	 * POST methods imposed by the HTTP specification.
	 *
	 * @since 4.2
	 */
	export interface LaxRedirectStrategy extends Http.DefaultRedirectStrategy {
	}
	export module LaxRedirectStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.LaxRedirectStrategy
		 * Lax {@link org.apache.http.client.RedirectStrategy} implementation
		 * that automatically redirects all HEAD, GET, POST, and DELETE requests.
		 * This strategy relaxes restrictions on automatic redirection of
		 * POST methods imposed by the HTTP specification.
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.DefaultRedirectStrategy.Static {
			new(): Http.LaxRedirectStrategy;
			INSTANCE?: Http.LaxRedirectStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.RoutedRequest
	 * A request with the route along which it should be sent.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) do not use.
	 */
	export interface RoutedRequest extends Java.Object {
	}
	export module RoutedRequest {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.RoutedRequest
		 * A request with the route along which it should be sent.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) do not use.
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.RoutedRequest;
		}
	}

	/**
	 * @deprecated
	 * Corresponding Java class: org.apache.http.impl.client.CloseableHttpResponseProxy
	 * @since 4.3
	 */
	export interface CloseableHttpResponseProxy extends Java.Object, Java.InvocationHandler {
	}
	export module CloseableHttpResponseProxy {
		/**
		 * @deprecated
		 * Corresponding Java class: org.apache.http.impl.client.CloseableHttpResponseProxy
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Java.InvocationHandler.Static {
			new(): Http.CloseableHttpResponseProxy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DefaultProxyAuthenticationHandler
	 * Default {@link org.apache.http.client.AuthenticationHandler} implementation
	 * for proxy host authentication.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link ProxyAuthenticationStrategy}
	 */
	export interface DefaultProxyAuthenticationHandler extends Http.AbstractAuthenticationHandler {
	}
	export module DefaultProxyAuthenticationHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DefaultProxyAuthenticationHandler
		 * Default {@link org.apache.http.client.AuthenticationHandler} implementation
		 * for proxy host authentication.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link ProxyAuthenticationStrategy}
		 */
		export interface Static extends Http.AbstractAuthenticationHandler.Static {
			new(): Http.DefaultProxyAuthenticationHandler;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.FutureRequestExecutionService
	 * HttpAsyncClientWithFuture wraps calls to execute with a {@link HttpRequestFutureTask}
	 * and schedules them using the provided executor service. Scheduled calls may be cancelled.
	 */
	export interface FutureRequestExecutionService extends Java.Object, Java.Closeable {
		close(): void;
		/**
		 * Schedule a request for execution.
		 *
		 * @param 
		 *
		 * @param request
		 *            request to execute
		 * @param responseHandler
		 *            handler that will process the response.
		 * @return HttpAsyncClientFutureTask for the scheduled request.
		 */
		execute<T>(request: Http.HttpUriRequest, context: Http.HttpContext, responseHandler: Http.ResponseHandler<T>): Http.HttpRequestFutureTask<T>;
		/**
		 * Schedule a request for execution.
		 *
		 * @param 
		 *
		 * @param request
		 *            request to execute
		 * @param context
		 *            optional context; use null if not needed.
		 * @param responseHandler
		 *            handler that will process the response.
		 * @param callback
		 *            callback handler that will be called when the request is scheduled,
		 *            started, completed, failed, or cancelled.
		 * @return HttpAsyncClientFutureTask for the scheduled request.
		 */
		execute<T>(request: Http.HttpUriRequest, context: Http.HttpContext, responseHandler: Http.ResponseHandler<T>, callback: Http.FutureCallback<T>): Http.HttpRequestFutureTask<T>;
		/**
		 * @return metrics gathered for this instance.
		 * @see FutureRequestExecutionMetrics
		 */
		metrics(): Http.FutureRequestExecutionMetrics;
	}
	export module FutureRequestExecutionService {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.FutureRequestExecutionService
		 * HttpAsyncClientWithFuture wraps calls to execute with a {@link HttpRequestFutureTask}
		 * and schedules them using the provided executor service. Scheduled calls may be cancelled.
		 */
		export interface Static extends Java.Object.Static, Java.Closeable.Static {
			/**
			 * Create a new FutureRequestExecutionService.
			 *
			 * @param httpclient
			 *            you should tune your httpclient instance to match your needs. You should
			 *            align the max number of connections in the pool and the number of threads
			 *            in the executor; it doesn't make sense to have more threads than connections
			 *            and if you have less connections than threads, the threads will just end up
			 *            blocking on getting a connection from the pool.
			 * @param executorService
			 *            any executorService will do here. E.g.
			 *            {@link java.util.concurrent.Executors#newFixedThreadPool(int)}
			 */
			new(httpclient: Http.HttpClient, executorService: Java.ExecutorService): Http.FutureRequestExecutionService;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.BasicCredentialsProvider
	 * Default implementation of {@link CredentialsProvider}.
	 *
	 * @since 4.0
	 */
	export interface BasicCredentialsProvider extends Java.Object, Http.CredentialsProvider {
		clear(): void;
		getCredentials(authscope: Http.AuthScope): Http.Credentials;
		setCredentials(authscope: Http.AuthScope, credentials: Http.Credentials): void;
		toString(): string;
	}
	export module BasicCredentialsProvider {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.BasicCredentialsProvider
		 * Default implementation of {@link CredentialsProvider}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.CredentialsProvider.Static {
			/**
			 * Default constructor.
			 */
			new(): Http.BasicCredentialsProvider;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.AbstractResponseHandler
	 * A generic {@link ResponseHandler} that works with the response entity
	 * for successful (2xx) responses. If the response code was &gt;= 300, the response
	 * body is consumed and an {@link HttpResponseException} is thrown.
	 * 
	 * If this is used with
	 * {@link org.apache.http.client.HttpClient#execute(
	 *  org.apache.http.client.methods.HttpUriRequest, ResponseHandler)},
	 * HttpClient may handle redirects (3xx responses) internally.
	 * 
	 *
	 * @since 4.4
	 */
	export interface AbstractResponseHandler<T = any> extends Java.Object, Http.ResponseHandler<T> {
		/**
		 * Handle the response entity and transform it into the actual response
		 * object.
		 */
		handleEntity(entity: Http.HttpEntity): T;
		/**
		 * Read the entity from the response body and pass it to the entity handler
		 * method if the response was successful (a 2xx status code). If no response
		 * body exists, this returns null. If the response was unsuccessful (&gt;= 300
		 * status code), throws an {@link HttpResponseException}.
		 */
		handleResponse(response: Http.HttpResponse): T;
	}
	export module AbstractResponseHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.AbstractResponseHandler
		 * A generic {@link ResponseHandler} that works with the response entity
		 * for successful (2xx) responses. If the response code was &gt;= 300, the response
		 * body is consumed and an {@link HttpResponseException} is thrown.
		 * 
		 * If this is used with
		 * {@link org.apache.http.client.HttpClient#execute(
		 *  org.apache.http.client.methods.HttpUriRequest, ResponseHandler)},
		 * HttpClient may handle redirects (3xx responses) internally.
		 * 
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Http.ResponseHandler.Static {
			new <T>(): Http.AbstractResponseHandler<T>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.HttpRequestFutureTask
	 * FutureTask implementation that wraps a HttpAsyncClientCallable and exposes various task
	 * specific metrics.
	 *
	 * @param 
	 */
	export interface HttpRequestFutureTask<V = any> extends Java.FutureTask<V> {
		cancel(mayInterruptIfRunning: boolean): boolean;
		/**
		 * @return the time in millis the task was finished/cancelled.
		 */
		endedTime(): long;
		/**
		 * @return the time in millis it took to make the request (excluding the time it was
		 * scheduled to be executed).
		 */
		requestDuration(): long;
		/**
		 * @return the time in millis the task was scheduled.
		 */
		scheduledTime(): long;
		/**
		 * @return the time in millis the task was started.
		 */
		startedTime(): long;
		/**
		 * @return the time in millis it took to execute the task from the moment it was scheduled.
		 */
		taskDuration(): long;
		toString(): string;
	}
	export module HttpRequestFutureTask {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.HttpRequestFutureTask
		 * FutureTask implementation that wraps a HttpAsyncClientCallable and exposes various task
		 * specific metrics.
		 *
		 * @param 
		 */
		export interface Static extends Java.FutureTask.Static {
			new <V>(request: Http.HttpUriRequest, httpCallable: Http.HttpRequestTaskCallable<V>): Http.HttpRequestFutureTask<V>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.ProxyClient
	 * ProxyClient can be used to establish a tunnel via an HTTP proxy.
	 */
	export interface ProxyClient extends Java.Object {
		tunnel(proxy: Http.HttpHost, target: Http.HttpHost, credentials: Http.Credentials): Java.Socket;
	}
	export module ProxyClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.ProxyClient
		 * ProxyClient can be used to establish a tunnel via an HTTP proxy.
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * @since 4.3
			 */
			new(connFactory: Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>, connectionConfig: Http.ConnectionConfig, requestConfig: Http.RequestConfig): Http.ProxyClient;
			/**
			 * @since 4.3
			 */
			new(requestConfig: Http.RequestConfig): Http.ProxyClient;
			new(): Http.ProxyClient;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.HttpRequestTaskCallable
	 */
	export interface HttpRequestTaskCallable<V = any> extends Java.Object, Java.Callable<V> {
		call(): V;
		cancel(): void;
		getEnded(): long;
		getScheduled(): long;
		getStarted(): long;
	}
	export module HttpRequestTaskCallable {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.HttpRequestTaskCallable
		 */
		export interface Static extends Java.Object.Static, Java.Callable.Static {
			new <V>(): Http.HttpRequestTaskCallable<V>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.AIMDBackoffManager
	 * The {@code AIMDBackoffManager} applies an additive increase,
	 * multiplicative decrease (AIMD) to managing a dynamic limit to
	 * the number of connections allowed to a given host. You may want
	 * to experiment with the settings for the cooldown periods and the
	 * backoff factor to get the adaptive behavior you want.
	 *
	 * Generally speaking, shorter cooldowns will lead to more steady-state
	 * variability but faster reaction times, while longer cooldowns
	 * will lead to more stable equilibrium behavior but slower reaction
	 * times.
	 *
	 * Similarly, higher backoff factors promote greater
	 * utilization of available capacity at the expense of fairness
	 * among clients. Lower backoff factors allow equal distribution of
	 * capacity among clients (fairness) to happen faster, at the
	 * expense of having more server capacity unused in the short term.
	 *
	 * @since 4.2
	 */
	export interface AIMDBackoffManager extends Java.Object, Http.BackoffManager {
		backOff(route: Http.HttpRoute): void;
		probe(route: Http.HttpRoute): void;
		/**
		 * Sets the factor to use when backing off; the new
		 * per-host limit will be roughly the current max times
		 * this factor. {@code Math.floor} is applied in the
		 * case of non-integer outcomes to ensure we actually
		 * decrease the pool size. Pool sizes are never decreased
		 * below 1, however. Defaults to 0.5.
		 * @param d must be between 0.0 and 1.0, exclusive.
		 */
		setBackoffFactor(d: double): void;
		/**
		 * Sets the amount of time, in milliseconds, to wait between
		 * adjustments in pool sizes for a given host, to allow
		 * enough time for the adjustments to take effect. Defaults
		 * to 5000L (5 seconds).
		 * @param l must be positive
		 */
		setCooldownMillis(l: long): void;
		/**
		 * Sets the absolute maximum per-host connection pool size to
		 * probe up to; defaults to 2 (the default per-host max).
		 * @param cap must be &gt;= 1
		 */
		setPerHostConnectionCap(cap: int): void;
	}
	export module AIMDBackoffManager {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.AIMDBackoffManager
		 * The {@code AIMDBackoffManager} applies an additive increase,
		 * multiplicative decrease (AIMD) to managing a dynamic limit to
		 * the number of connections allowed to a given host. You may want
		 * to experiment with the settings for the cooldown periods and the
		 * backoff factor to get the adaptive behavior you want.
		 *
		 * Generally speaking, shorter cooldowns will lead to more steady-state
		 * variability but faster reaction times, while longer cooldowns
		 * will lead to more stable equilibrium behavior but slower reaction
		 * times.
		 *
		 * Similarly, higher backoff factors promote greater
		 * utilization of available capacity at the expense of fairness
		 * among clients. Lower backoff factors allow equal distribution of
		 * capacity among clients (fairness) to happen faster, at the
		 * expense of having more server capacity unused in the short term.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.BackoffManager.Static {
			/**
			 * Creates an {@code AIMDBackoffManager} to manage
			 * per-host connection pool sizes represented by the
			 * given {@link ConnPoolControl}.
			 * @param connPerRoute per-host routing maximums to
			 *   be managed
			 */
			new(connPerRoute: Http.ConnPoolControl<Http.HttpRoute>): Http.AIMDBackoffManager;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.DecompressingHttpClient
	 * Decorator adding support for compressed responses. This class sets
	 * the {@code Accept-Encoding} header on requests to indicate
	 * support for the {@code gzip} and {@code deflate}
	 * compression schemes; it then checks the {@code Content-Encoding}
	 * header on the response to uncompress any compressed response bodies.
	 * The {@link java.io.InputStream} of the entity will contain the uncompressed
	 * content.
	 *
	 * N.B. Any upstream clients of this class need to be aware that
	 * this effectively obscures visibility into the length of a server
	 * response body, since the {@code Content-Length} header will
	 * correspond to the compressed entity length received from the server,
	 * but the content length experienced by reading the response body may
	 * be different (hopefully higher!).
	 *
	 * That said, this decorator is compatible with the
	 * {@code CachingHttpClient} in that the two decorators can be added
	 * in either order and still have cacheable responses be cached.
	 *
	 * @since 4.2
	 *
	 * @deprecated (4.3) use {@link HttpClientBuilder}
	 */
	export interface DecompressingHttpClient extends Java.Object, Http.HttpClient {
	}
	export module DecompressingHttpClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.DecompressingHttpClient
		 * Decorator adding support for compressed responses. This class sets
		 * the {@code Accept-Encoding} header on requests to indicate
		 * support for the {@code gzip} and {@code deflate}
		 * compression schemes; it then checks the {@code Content-Encoding}
		 * header on the response to uncompress any compressed response bodies.
		 * The {@link java.io.InputStream} of the entity will contain the uncompressed
		 * content.
		 *
		 * N.B. Any upstream clients of this class need to be aware that
		 * this effectively obscures visibility into the length of a server
		 * response body, since the {@code Content-Length} header will
		 * correspond to the compressed entity length received from the server,
		 * but the content length experienced by reading the response body may
		 * be different (hopefully higher!).
		 *
		 * That said, this decorator is compatible with the
		 * {@code CachingHttpClient} in that the two decorators can be added
		 * in either order and still have cacheable responses be cached.
		 *
		 * @since 4.2
		 *
		 * @deprecated (4.3) use {@link HttpClientBuilder}
		 */
		export interface Static extends Java.Object.Static, Http.HttpClient.Static {
			new(): Http.DecompressingHttpClient;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.client.SystemDefaultHttpClient
	 * An extension of {@link DefaultHttpClient} pre-configured using system properties.
	 * 
	 * The following system properties are taken into account by this class:
	 * 
	 *  ssl.TrustManagerFactory.algorithm
	 *  javax.net.ssl.trustStoreType
	 *  javax.net.ssl.trustStore
	 *  javax.net.ssl.trustStoreProvider
	 *  javax.net.ssl.trustStorePassword
	 *  java.home
	 *  ssl.KeyManagerFactory.algorithm
	 *  javax.net.ssl.keyStoreType
	 *  javax.net.ssl.keyStore
	 *  javax.net.ssl.keyStoreProvider
	 *  javax.net.ssl.keyStorePassword
	 *  http.proxyHost
	 *  http.proxyPort
	 *  https.proxyHost
	 *  https.proxyPort
	 *  http.nonProxyHosts
	 *  http.keepAlive
	 *  http.maxConnections
	 * 
	 * 
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 * 
	 *  {@link org.apache.http.params.CoreProtocolPNames#PROTOCOL_VERSION}
	 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
	 *  {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET}
	 *  {@link org.apache.http.params.CoreProtocolPNames#USE_EXPECT_CONTINUE}
	 *  {@link org.apache.http.params.CoreProtocolPNames#WAIT_FOR_CONTINUE}
	 *  {@link org.apache.http.params.CoreProtocolPNames#USER_AGENT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#TCP_NODELAY}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_TIMEOUT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_LINGER}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SO_REUSEADDR}
	 *  {@link org.apache.http.params.CoreConnectionPNames#SOCKET_BUFFER_SIZE}
	 *  {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#STALE_CONNECTION_CHECK}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
	 *  {@link org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY}
	 *  {@link org.apache.http.cookie.params.CookieSpecPNames#DATE_PATTERNS}
	 *  {@link org.apache.http.cookie.params.CookieSpecPNames#SINGLE_COOKIE_HEADER}
	 *  {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET}
	 *  {@link org.apache.http.client.params.ClientPNames#COOKIE_POLICY}
	 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_AUTHENTICATION}
	 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_REDIRECTS}
	 *  {@link org.apache.http.client.params.ClientPNames#MAX_REDIRECTS}
	 *  {@link org.apache.http.client.params.ClientPNames#ALLOW_CIRCULAR_REDIRECTS}
	 *  {@link org.apache.http.client.params.ClientPNames#VIRTUAL_HOST}
	 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HOST}
	 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HEADERS}
	 *  {@link org.apache.http.client.params.ClientPNames#CONN_MANAGER_TIMEOUT}
	 * 
	 *
	 * @since 4.2
	 *
	 * @deprecated (4.3) use {@link HttpClientBuilder}
	 */
	export interface SystemDefaultHttpClient extends Http.DefaultHttpClient {
	}
	export module SystemDefaultHttpClient {
		/**
		 * Corresponding Java class: org.apache.http.impl.client.SystemDefaultHttpClient
		 * An extension of {@link DefaultHttpClient} pre-configured using system properties.
		 * 
		 * The following system properties are taken into account by this class:
		 * 
		 *  ssl.TrustManagerFactory.algorithm
		 *  javax.net.ssl.trustStoreType
		 *  javax.net.ssl.trustStore
		 *  javax.net.ssl.trustStoreProvider
		 *  javax.net.ssl.trustStorePassword
		 *  java.home
		 *  ssl.KeyManagerFactory.algorithm
		 *  javax.net.ssl.keyStoreType
		 *  javax.net.ssl.keyStore
		 *  javax.net.ssl.keyStoreProvider
		 *  javax.net.ssl.keyStorePassword
		 *  http.proxyHost
		 *  http.proxyPort
		 *  https.proxyHost
		 *  https.proxyPort
		 *  http.nonProxyHosts
		 *  http.keepAlive
		 *  http.maxConnections
		 * 
		 * 
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 * 
		 *  {@link org.apache.http.params.CoreProtocolPNames#PROTOCOL_VERSION}
		 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
		 *  {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET}
		 *  {@link org.apache.http.params.CoreProtocolPNames#USE_EXPECT_CONTINUE}
		 *  {@link org.apache.http.params.CoreProtocolPNames#WAIT_FOR_CONTINUE}
		 *  {@link org.apache.http.params.CoreProtocolPNames#USER_AGENT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#TCP_NODELAY}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_TIMEOUT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_LINGER}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SO_REUSEADDR}
		 *  {@link org.apache.http.params.CoreConnectionPNames#SOCKET_BUFFER_SIZE}
		 *  {@link org.apache.http.params.CoreConnectionPNames#CONNECTION_TIMEOUT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#STALE_CONNECTION_CHECK}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#FORCED_ROUTE}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#LOCAL_ADDRESS}
		 *  {@link org.apache.http.conn.params.ConnRoutePNames#DEFAULT_PROXY}
		 *  {@link org.apache.http.cookie.params.CookieSpecPNames#DATE_PATTERNS}
		 *  {@link org.apache.http.cookie.params.CookieSpecPNames#SINGLE_COOKIE_HEADER}
		 *  {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET}
		 *  {@link org.apache.http.client.params.ClientPNames#COOKIE_POLICY}
		 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_AUTHENTICATION}
		 *  {@link org.apache.http.client.params.ClientPNames#HANDLE_REDIRECTS}
		 *  {@link org.apache.http.client.params.ClientPNames#MAX_REDIRECTS}
		 *  {@link org.apache.http.client.params.ClientPNames#ALLOW_CIRCULAR_REDIRECTS}
		 *  {@link org.apache.http.client.params.ClientPNames#VIRTUAL_HOST}
		 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HOST}
		 *  {@link org.apache.http.client.params.ClientPNames#DEFAULT_HEADERS}
		 *  {@link org.apache.http.client.params.ClientPNames#CONN_MANAGER_TIMEOUT}
		 * 
		 *
		 * @since 4.2
		 *
		 * @deprecated (4.3) use {@link HttpClientBuilder}
		 */
		export interface Static extends Http.DefaultHttpClient.Static {
			new(): Http.SystemDefaultHttpClient;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.ServiceUnavailableRetryExec
	 * Request executor in the request execution chain that is responsible
	 * for making a decision whether a request that received a non-2xx response
	 * from the target server should be re-executed.
	 * 
	 * Further responsibilities such as communication with the opposite
	 * endpoint is delegated to the next executor in the request execution
	 * chain.
	 * 
	 *
	 * @since 4.3
	 */
	export interface ServiceUnavailableRetryExec extends Java.Object, Http.ClientExecChain {
		execute(route: Http.HttpRoute, request: Http.HttpRequestWrapper, context: Http.HttpClientContext, execAware: Http.HttpExecutionAware): Http.CloseableHttpResponse;
	}
	export module ServiceUnavailableRetryExec {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.ServiceUnavailableRetryExec
		 * Request executor in the request execution chain that is responsible
		 * for making a decision whether a request that received a non-2xx response
		 * from the target server should be re-executed.
		 * 
		 * Further responsibilities such as communication with the opposite
		 * endpoint is delegated to the next executor in the request execution
		 * chain.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ClientExecChain.Static {
			new(requestExecutor: Http.ClientExecChain, retryStrategy: Http.ServiceUnavailableRetryStrategy): Http.ServiceUnavailableRetryExec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.MinimalClientExec
	 * Request executor that implements the most fundamental aspects of
	 * the HTTP specification and the most straight-forward request / response
	 * exchange with the target server. This executor does not support
	 * execution via proxy and will make no attempts to retry the request
	 * in case of a redirect, authentication challenge or I/O error.
	 *
	 * @since 4.3
	 */
	export interface MinimalClientExec extends Java.Object, Http.ClientExecChain {
		execute(route: Http.HttpRoute, request: Http.HttpRequestWrapper, context: Http.HttpClientContext, execAware: Http.HttpExecutionAware): Http.CloseableHttpResponse;
	}
	export module MinimalClientExec {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.MinimalClientExec
		 * Request executor that implements the most fundamental aspects of
		 * the HTTP specification and the most straight-forward request / response
		 * exchange with the target server. This executor does not support
		 * execution via proxy and will make no attempts to retry the request
		 * in case of a redirect, authentication challenge or I/O error.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ClientExecChain.Static {
			new(requestExecutor: Http.HttpRequestExecutor, connManager: Http.HttpClientConnectionManager, reuseStrategy: Http.ConnectionReuseStrategy, keepAliveStrategy: Http.ConnectionKeepAliveStrategy): Http.MinimalClientExec;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.ClientExecChain
	 * This interface represents an element in the HTTP request execution chain. Each element can
	 * either be a decorator around another element that implements a cross cutting aspect or
	 * a self-contained executor capable of producing a response for the given request.
	 * 
	 * Important: please note it is required for decorators that implement post execution aspects
	 * or response post-processing of any sort to release resources associated with the response
	 * by calling {@link CloseableHttpResponse#close()} methods in case of an I/O, protocol or
	 * runtime exception, or in case the response is not propagated to the caller.
	 * 
	 *
	 * @since 4.3
	 */
	export interface ClientExecChain extends Java.Object {
		/**
		 * Executes th request either by transmitting it to the target server or
		 * by passing it onto the next executor in the request execution chain.
		 *
		 * @param route connection route.
		 * @param request current request.
		 * @param clientContext current HTTP context.
		 * @param execAware receiver of notifications of blocking I/O operations.
		 * @return HTTP response either received from the opposite endpoint
		 *   or generated locally.
		 * @throws IOException in case of a I/O error.
		 *   (this type of exceptions are potentially recoverable).
		 * @throws HttpException in case of an HTTP protocol error
		 *   (usually this type of exceptions are non-recoverable).
		 */
		execute(route: Http.HttpRoute, request: Http.HttpRequestWrapper, clientContext: Http.HttpClientContext, execAware: Http.HttpExecutionAware): Http.CloseableHttpResponse;
	}
	export module ClientExecChain {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.ClientExecChain
		 * This interface represents an element in the HTTP request execution chain. Each element can
		 * either be a decorator around another element that implements a cross cutting aspect or
		 * a self-contained executor capable of producing a response for the given request.
		 * 
		 * Important: please note it is required for decorators that implement post execution aspects
		 * or response post-processing of any sort to release resources associated with the response
		 * by calling {@link CloseableHttpResponse#close()} methods in case of an I/O, protocol or
		 * runtime exception, or in case the response is not propagated to the caller.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.HttpResponseProxy
	 * A proxy class for {@link org.apache.http.HttpResponse} that can be used to release client connection
	 * associated with the original response.
	 *
	 * @since 4.3
	 */
	export interface HttpResponseProxy extends Java.Object, Http.CloseableHttpResponse {
		addHeader(header: Http.Header): void;
		addHeader(name: string, value: string): void;
		close(): void;
		containsHeader(name: string): boolean;
		getAllHeaders(): array<Http.Header>;
		getEntity(): Http.HttpEntity;
		getFirstHeader(name: string): Http.Header;
		getHeaders(name: string): array<Http.Header>;
		getLastHeader(name: string): Http.Header;
		getLocale(): Java.Locale;
		getProtocolVersion(): Http.ProtocolVersion;
		getStatusLine(): Http.StatusLine;
		headerIterator(): Http.HeaderIterator;
		headerIterator(name: string): Http.HeaderIterator;
		removeHeader(header: Http.Header): void;
		removeHeaders(name: string): void;
		setEntity(entity: Http.HttpEntity): void;
		setHeader(header: Http.Header): void;
		setHeader(name: string, value: string): void;
		setHeaders(headers: array<Http.Header>): void;
		setLocale(loc: Java.Locale): void;
		setReasonPhrase(reason: string): void;
		setStatusCode(code: int): void;
		setStatusLine(statusline: Http.StatusLine): void;
		setStatusLine(ver: Http.ProtocolVersion, code: int): void;
		setStatusLine(ver: Http.ProtocolVersion, code: int, reason: string): void;
		toString(): string;
	}
	export module HttpResponseProxy {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.HttpResponseProxy
		 * A proxy class for {@link org.apache.http.HttpResponse} that can be used to release client connection
		 * associated with the original response.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.CloseableHttpResponse.Static {
			new(original: Http.HttpResponse, connHolder: Http.ConnectionHolder): Http.HttpResponseProxy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.TunnelRefusedException
	 * Signals that the tunnel request was rejected by the proxy host.
	 *
	 * @since 4.0
	 */
	export interface TunnelRefusedException extends Http.HttpException {
		getResponse(): Http.HttpResponse;
	}
	export module TunnelRefusedException {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.TunnelRefusedException
		 * Signals that the tunnel request was rejected by the proxy host.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpException.Static {
			new(message: string, response: Http.HttpResponse): Http.TunnelRefusedException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.execchain.RequestAbortedException
	 * Signals that the request has been aborted.
	 *
	 * @since 4.3
	 */
	export interface RequestAbortedException extends Java.InterruptedIOException {
	}
	export module RequestAbortedException {
		/**
		 * Corresponding Java class: org.apache.http.impl.execchain.RequestAbortedException
		 * Signals that the request has been aborted.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.InterruptedIOException.Static {
			new(message: string): Http.RequestAbortedException;
			new(message: string, cause: Java.Throwable): Http.RequestAbortedException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.HttpPoolEntry
	 * @since 4.2
	 *
	 * @deprecated (4.3) no longer used.
	 */
	export interface HttpPoolEntry extends Http.PoolEntry<Http.HttpRoute, Http.OperatedClientConnection> {
	}
	export module HttpPoolEntry {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.HttpPoolEntry
		 * @since 4.2
		 *
		 * @deprecated (4.3) no longer used.
		 */
		export interface Static extends Http.PoolEntry.Static {
			new(): Http.HttpPoolEntry;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.PoolingHttpClientConnectionManager
	 * {@code ClientConnectionPoolManager} maintains a pool of
	 * {@link HttpClientConnection}s and is able to service connection requests
	 * from multiple execution threads. Connections are pooled on a per route
	 * basis. A request for a route which already the manager has persistent
	 * connections for available in the pool will be services by leasing
	 * a connection from the pool rather than creating a brand new connection.
	 * 
	 * {@code ClientConnectionPoolManager} maintains a maximum limit of connection
	 * on a per route basis and in total. Per default this implementation will
	 * create no more than than 2 concurrent connections per given route
	 * and no more 20 connections in total. For many real-world applications
	 * these limits may prove too constraining, especially if they use HTTP
	 * as a transport protocol for their services. Connection limits, however,
	 * can be adjusted using {@link ConnPoolControl} methods.
	 * 
	 * 
	 * Total time to live (TTL) set at construction time defines maximum life span
	 * of persistent connections regardless of their expiration setting. No persistent
	 * connection will be re-used past its TTL value.
	 * 
	 * 
	 * The handling of stale connections was changed in version 4.4.
	 * Previously, the code would check every connection by default before re-using it.
	 * The code now only checks the connection if the elapsed time since
	 * the last use of the connection exceeds the timeout that has been set.
	 * The default timeout is set to 2000ms
	 * 
	 *
	 * @since 4.3
	 */
	export interface PoolingHttpClientConnectionManager extends Java.Object, Http.HttpClientConnectionManager, Http.ConnPoolControl<Http.HttpRoute>, Java.Closeable {
		close(): void;
		closeExpiredConnections(): void;
		closeIdleConnections(idleTimeout: long, tunit: Java.TimeUnit): void;
		connect(managedConn: Http.HttpClientConnection, route: Http.HttpRoute, connectTimeout: int, context: Http.HttpContext): void;
		getConnectionConfig(host: Http.HttpHost): Http.ConnectionConfig;
		getDefaultConnectionConfig(): Http.ConnectionConfig;
		getDefaultMaxPerRoute(): int;
		getDefaultSocketConfig(): Http.SocketConfig;
		getMaxPerRoute(route: Http.HttpRoute): int;
		getMaxTotal(): int;
		/**
		 * @since 4.4
		 */
		getRoutes(): Java.Set<Http.HttpRoute>;
		getSocketConfig(host: Http.HttpHost): Http.SocketConfig;
		getStats(route: Http.HttpRoute): Http.PoolStats;
		getTotalStats(): Http.PoolStats;
		/**
		 * @see #setValidateAfterInactivity(int)
		 *
		 * @since 4.4
		 */
		getValidateAfterInactivity(): int;
		releaseConnection(managedConn: Http.HttpClientConnection, state: obj, keepalive: long, tunit: Java.TimeUnit): void;
		requestConnection(route: Http.HttpRoute, state: obj): Http.ConnectionRequest;
		routeComplete(managedConn: Http.HttpClientConnection, route: Http.HttpRoute, context: Http.HttpContext): void;
		setConnectionConfig(host: Http.HttpHost, connectionConfig: Http.ConnectionConfig): void;
		setDefaultConnectionConfig(defaultConnectionConfig: Http.ConnectionConfig): void;
		setDefaultMaxPerRoute(max: int): void;
		setDefaultSocketConfig(defaultSocketConfig: Http.SocketConfig): void;
		setMaxPerRoute(route: Http.HttpRoute, max: int): void;
		setMaxTotal(max: int): void;
		setSocketConfig(host: Http.HttpHost, socketConfig: Http.SocketConfig): void;
		/**
		 * Defines period of inactivity in milliseconds after which persistent connections must
		 * be re-validated prior to being {@link #leaseConnection(java.util.concurrent.Future,
		 *   long, java.util.concurrent.TimeUnit) leased} to the consumer. Non-positive value passed
		 * to this method disables connection validation. This check helps detect connections
		 * that have become stale (half-closed) while kept inactive in the pool.
		 *
		 * @see #leaseConnection(java.util.concurrent.Future, long, java.util.concurrent.TimeUnit)
		 *
		 * @since 4.4
		 */
		setValidateAfterInactivity(ms: int): void;
		shutdown(): void;
		upgrade(managedConn: Http.HttpClientConnection, route: Http.HttpRoute, context: Http.HttpContext): void;
	}
	export module PoolingHttpClientConnectionManager {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.PoolingHttpClientConnectionManager
		 * {@code ClientConnectionPoolManager} maintains a pool of
		 * {@link HttpClientConnection}s and is able to service connection requests
		 * from multiple execution threads. Connections are pooled on a per route
		 * basis. A request for a route which already the manager has persistent
		 * connections for available in the pool will be services by leasing
		 * a connection from the pool rather than creating a brand new connection.
		 * 
		 * {@code ClientConnectionPoolManager} maintains a maximum limit of connection
		 * on a per route basis and in total. Per default this implementation will
		 * create no more than than 2 concurrent connections per given route
		 * and no more 20 connections in total. For many real-world applications
		 * these limits may prove too constraining, especially if they use HTTP
		 * as a transport protocol for their services. Connection limits, however,
		 * can be adjusted using {@link ConnPoolControl} methods.
		 * 
		 * 
		 * Total time to live (TTL) set at construction time defines maximum life span
		 * of persistent connections regardless of their expiration setting. No persistent
		 * connection will be re-used past its TTL value.
		 * 
		 * 
		 * The handling of stale connections was changed in version 4.4.
		 * Previously, the code would check every connection by default before re-using it.
		 * The code now only checks the connection if the elapsed time since
		 * the last use of the connection exceeds the timeout that has been set.
		 * The default timeout is set to 2000ms
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpClientConnectionManager.Static, Http.ConnPoolControl.Static, Java.Closeable.Static {
			ConfigData: PoolingHttpClientConnectionManager$ConfigData.Static;
			InternalConnectionFactory: PoolingHttpClientConnectionManager$InternalConnectionFactory.Static;
			new(): Http.PoolingHttpClientConnectionManager;
			new(timeToLive: long, tunit: Java.TimeUnit): Http.PoolingHttpClientConnectionManager;
			new(socketFactoryRegistry: Http.Registry<Http.ConnectionSocketFactory>): Http.PoolingHttpClientConnectionManager;
			new(socketFactoryRegistry: Http.Registry<Http.ConnectionSocketFactory>, dnsResolver: Http.DnsResolver): Http.PoolingHttpClientConnectionManager;
			new(socketFactoryRegistry: Http.Registry<Http.ConnectionSocketFactory>, connFactory: Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>): Http.PoolingHttpClientConnectionManager;
			new(connFactory: Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>): Http.PoolingHttpClientConnectionManager;
			new(socketFactoryRegistry: Http.Registry<Http.ConnectionSocketFactory>, connFactory: Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>, dnsResolver: Http.DnsResolver): Http.PoolingHttpClientConnectionManager;
			new(socketFactoryRegistry: Http.Registry<Http.ConnectionSocketFactory>, connFactory: Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>, schemePortResolver: Http.SchemePortResolver, dnsResolver: Http.DnsResolver, timeToLive: long, tunit: Java.TimeUnit): Http.PoolingHttpClientConnectionManager;
			/**
			 * @since 4.4
			 */
			new(httpClientConnectionOperator: Http.HttpClientConnectionOperator, connFactory: Http.ConnectionHttpConnectionFactory<Http.HttpRoute, Http.ManagedHttpClientConnection>, timeToLive: long, tunit: Java.TimeUnit): Http.PoolingHttpClientConnectionManager;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.conn.PoolingHttpClientConnectionManager.ConfigData
	 */
	export interface PoolingHttpClientConnectionManager$ConfigData extends Java.Object {
		getConnectionConfig(host: Http.HttpHost): Http.ConnectionConfig;
		getDefaultConnectionConfig(): Http.ConnectionConfig;
		getDefaultSocketConfig(): Http.SocketConfig;
		getSocketConfig(host: Http.HttpHost): Http.SocketConfig;
		setConnectionConfig(host: Http.HttpHost, connectionConfig: Http.ConnectionConfig): void;
		setDefaultConnectionConfig(defaultConnectionConfig: Http.ConnectionConfig): void;
		setDefaultSocketConfig(defaultSocketConfig: Http.SocketConfig): void;
		setSocketConfig(host: Http.HttpHost, socketConfig: Http.SocketConfig): void;
	}
	export module PoolingHttpClientConnectionManager$ConfigData {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.PoolingHttpClientConnectionManager.ConfigData
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.PoolingHttpClientConnectionManager$ConfigData;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.conn.PoolingHttpClientConnectionManager.InternalConnectionFactory
	 */
	export interface PoolingHttpClientConnectionManager$InternalConnectionFactory extends Java.Object, Http.ConnFactory<Http.HttpRoute, Http.ManagedHttpClientConnection> {
		create(route: Http.HttpRoute): Http.ManagedHttpClientConnection;
	}
	export module PoolingHttpClientConnectionManager$InternalConnectionFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.PoolingHttpClientConnectionManager.InternalConnectionFactory
		 */
		export interface Static extends Java.Object.Static, Http.ConnFactory.Static {
			new(): Http.PoolingHttpClientConnectionManager$InternalConnectionFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.CPoolProxy
	 * @since 4.3
	 */
	export interface CPoolProxy extends Java.Object, Http.ManagedHttpClientConnection, Http.HttpContext {
		bind(socket: Java.Socket): void;
		close(): void;
		flush(): void;
		getAttribute(id: string): obj;
		getId(): string;
		getLocalAddress(): Java.InetAddress;
		getLocalPort(): int;
		getMetrics(): Http.HttpConnectionMetrics;
		getRemoteAddress(): Java.InetAddress;
		getRemotePort(): int;
		getSSLSession(): Java.SSLSession;
		getSocket(): Java.Socket;
		getSocketTimeout(): int;
		isOpen(): boolean;
		isResponseAvailable(timeout: int): boolean;
		isStale(): boolean;
		receiveResponseEntity(response: Http.HttpResponse): void;
		receiveResponseHeader(): Http.HttpResponse;
		removeAttribute(id: string): obj;
		sendRequestEntity(request: Http.HttpEntityEnclosingRequest): void;
		sendRequestHeader(request: Http.HttpRequest): void;
		setAttribute(id: string, obj: obj): void;
		setSocketTimeout(timeout: int): void;
		shutdown(): void;
		toString(): string;
	}
	export module CPoolProxy {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.CPoolProxy
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.ManagedHttpClientConnection.Static, Http.HttpContext.Static {
			new(): Http.CPoolProxy;
			detach(conn: Http.HttpClientConnection): Http.CPoolEntry;
			getPoolEntry(proxy: Http.HttpClientConnection): Http.CPoolEntry;
			newProxy(poolEntry: Http.CPoolEntry): Http.HttpClientConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.LoggingSessionInputBuffer
	 * Logs all data read to the wire LOG.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) no longer used.
	 */
	export interface LoggingSessionInputBuffer extends Java.Object, Http.SessionInputBuffer, Http.EofSensor {
	}
	export module LoggingSessionInputBuffer {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.LoggingSessionInputBuffer
		 * Logs all data read to the wire LOG.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) no longer used.
		 */
		export interface Static extends Java.Object.Static, Http.SessionInputBuffer.Static, Http.EofSensor.Static {
			new(): Http.LoggingSessionInputBuffer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.LoggingOutputStream
	 * Internal class.
	 *
	 * @since 4.3
	 */
	export interface LoggingOutputStream extends Java.OutputStream {
		close(): void;
		flush(): void;
		write(b: int): void;
		write(b: array<byte>): void;
		write(b: array<byte>, off: int, len: int): void;
	}
	export module LoggingOutputStream {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.LoggingOutputStream
		 * Internal class.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.OutputStream.Static {
			new(out: Java.OutputStream, wire: Http.Wire): Http.LoggingOutputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.DefaultResponseParser
	 * Default HTTP response parser implementation.
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
	 *  {@link org.apache.http.conn.params.ConnConnectionPNames#MAX_STATUS_LINE_GARBAGE}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2) use {@link DefaultHttpResponseParser}
	 */
	export interface DefaultResponseParser extends Http.AbstractMessageParser<Http.HttpMessage> {
	}
	export module DefaultResponseParser {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.DefaultResponseParser
		 * Default HTTP response parser implementation.
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
		 *  {@link org.apache.http.conn.params.ConnConnectionPNames#MAX_STATUS_LINE_GARBAGE}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2) use {@link DefaultHttpResponseParser}
		 */
		export interface Static extends Http.AbstractMessageParser.Static {
			new(): Http.DefaultResponseParser;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.AbstractClientConnAdapter
	 * Abstract adapter from {@link OperatedClientConnection operated} to
	 * {@link ManagedClientConnection managed} client connections.
	 * Read and write methods are delegated to the wrapped connection.
	 * Operations affecting the connection state have to be implemented
	 * by derived classes. Operations for querying the connection state
	 * are delegated to the wrapped connection if there is one, or
	 * return a default value if there is none.
	 * 
	 * This adapter tracks the checkpoints for reusable communication states,
	 * as indicated by {@link #markReusable markReusable} and queried by
	 * {@link #isMarkedReusable isMarkedReusable}.
	 * All send and receive operations will automatically clear the mark.
	 * 
	 * Connection release calls are delegated to the connection manager,
	 * if there is one. {@link #abortConnection abortConnection} will
	 * clear the reusability mark first. The connection manager is
	 * expected to tolerate multiple calls to the release method.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  do not use
	 */
	export interface AbstractClientConnAdapter extends Java.Object, Http.ManagedClientConnection, Http.HttpContext {
	}
	export module AbstractClientConnAdapter {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.AbstractClientConnAdapter
		 * Abstract adapter from {@link OperatedClientConnection operated} to
		 * {@link ManagedClientConnection managed} client connections.
		 * Read and write methods are delegated to the wrapped connection.
		 * Operations affecting the connection state have to be implemented
		 * by derived classes. Operations for querying the connection state
		 * are delegated to the wrapped connection if there is one, or
		 * return a default value if there is none.
		 * 
		 * This adapter tracks the checkpoints for reusable communication states,
		 * as indicated by {@link #markReusable markReusable} and queried by
		 * {@link #isMarkedReusable isMarkedReusable}.
		 * All send and receive operations will automatically clear the mark.
		 * 
		 * Connection release calls are delegated to the connection manager,
		 * if there is one. {@link #abortConnection abortConnection} will
		 * clear the reusability mark first. The connection manager is
		 * expected to tolerate multiple calls to the release method.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  do not use
		 */
		export interface Static extends Java.Object.Static, Http.ManagedClientConnection.Static, Http.HttpContext.Static {
			new(): Http.AbstractClientConnAdapter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.conn.tsccm.RouteSpecificPool
	 * A connection sub-pool for a specific route, used by {@link ConnPoolByRoute}.
	 * The methods in this class are unsynchronized. It is expected that the
	 * containing pool takes care of synchronization.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2)  use {@link org.apache.http.pool.AbstractConnPool}
	 */
	export interface ConnectionRouteSpecificPool extends Java.Object {
	}
	export module ConnectionRouteSpecificPool {
		/**
		 * Corresponding Java class: org.apache.http.impl.conn.tsccm.RouteSpecificPool
		 * A connection sub-pool for a specific route, used by {@link ConnPoolByRoute}.
		 * The methods in this class are unsynchronized. It is expected that the
		 * containing pool takes care of synchronization.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2)  use {@link org.apache.http.pool.AbstractConnPool}
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.ConnectionRouteSpecificPool;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.annotation.ThreadingBehavior
	 Defines types of threading behavior enforced at runtime.
	 */
	export interface ThreadingBehavior extends Java.Enum<ThreadingBehavior> {
	}
	export module ThreadingBehavior {
		/**
		 * Corresponding Java class: org.apache.http.annotation.ThreadingBehavior
		 Defines types of threading behavior enforced at runtime.
		 */
		export interface Static extends Java.Enum.Static {
			/**
			 * Instances of classes with the given contract are expected to be fully immutable
			 * and thread-safe.
			 */
			IMMUTABLE?: Http.ThreadingBehavior;
			/**
			 * Instances of classes with the given contract are expected to be immutable if their
			 * dependencies injected at construction time are immutable and are expected to be thread-safe
			 * if their dependencies are thread-safe.
			 */
			IMMUTABLE_CONDITIONAL?: Http.ThreadingBehavior;
			/**
			 * Instances of classes with the given contract are expected to be fully thread-safe.
			 */
			SAFE?: Http.ThreadingBehavior;
			/**
			 * Instances of classes with the given contract are expected to be thread-safe if their
			 * dependencies injected at construction time are thread-safe.
			 */
			SAFE_CONDITIONAL?: Http.ThreadingBehavior;
			/**
			 * Instances of classes with the given contract are expected to be non thread-safe.
			 */
			UNSAFE?: Http.ThreadingBehavior;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.concurrent.BasicFuture
	 * Basic implementation of the {@link Future} interface. {@code BasicFuture}
	 * can be put into a completed state by invoking any of the following methods:
	 * {@link #cancel()}, {@link #failed(Exception)}, or {@link #completed(Object)}.
	 *
	 * @param  the future result type of an asynchronous operation.
	 * @since 4.2
	 */
	export interface BasicFuture<T = any> extends Java.Object, Java.Future<T>, Http.Cancellable {
		cancel(mayInterruptIfRunning: boolean): boolean;
		cancel(): boolean;
		completed(result: T): boolean;
		failed(exception: Java.Exception): boolean;
		get(): T;
		get(timeout: long, unit: Java.TimeUnit): T;
		isCancelled(): boolean;
		isDone(): boolean;
	}
	export module BasicFuture {
		/**
		 * Corresponding Java class: org.apache.http.concurrent.BasicFuture
		 * Basic implementation of the {@link Future} interface. {@code BasicFuture}
		 * can be put into a completed state by invoking any of the following methods:
		 * {@link #cancel()}, {@link #failed(Exception)}, or {@link #completed(Object)}.
		 *
		 * @param  the future result type of an asynchronous operation.
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Java.Future.Static, Http.Cancellable.Static {
			new <T>(callback: Http.FutureCallback<T>): Http.BasicFuture<T>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.concurrent.Cancellable
	 * A {@code Cancellable} represents a process or an operation that can be
	 * canceled.
	 *
	 * @since 4.2
	 */
	export interface Cancellable extends Java.Object {
		cancel(): boolean;
	}
	export module Cancellable {
		/**
		 * Corresponding Java class: org.apache.http.concurrent.Cancellable
		 * A {@code Cancellable} represents a process or an operation that can be
		 * canceled.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.concurrent.FutureCallback
	 * A callback interface that gets invoked upon completion of
	 * a {@link java.util.concurrent.Future}.
	 *
	 * @param  the future result type returned by this callback.
	 * @since 4.2
	 */
	export interface FutureCallback<T = any> extends Java.Object {
		cancelled(): void;
		completed(result: T): void;
		failed(ex: Java.Exception): void;
	}
	export module FutureCallback {
		/**
		 * Corresponding Java class: org.apache.http.concurrent.FutureCallback
		 * A callback interface that gets invoked upon completion of
		 * a {@link java.util.concurrent.Future}.
		 *
		 * @param  the future result type returned by this callback.
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.config.ConnectionConfig
	 * HTTP connection configuration.
	 *
	 * @since 4.3
	 */
	export interface ConnectionConfig extends Java.Object, Java.Cloneable {
		getBufferSize(): int;
		getCharset(): Java.Charset;
		getFragmentSizeHint(): int;
		getMalformedInputAction(): Java.CodingErrorAction;
		getMessageConstraints(): Http.MessageConstraints;
		getUnmappableInputAction(): Java.CodingErrorAction;
		toString(): string;
	}
	export module ConnectionConfig {
		/**
		 * Corresponding Java class: org.apache.http.config.ConnectionConfig
		 * HTTP connection configuration.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Java.Cloneable.Static {
			Builder: ConnectionConfig$Builder.Static;
			new(): Http.ConnectionConfig;
			DEFAULT?: Http.ConnectionConfig;
			copy(config: Http.ConnectionConfig): Http.ConnectionConfig$Builder;
			custom(): Http.ConnectionConfig$Builder;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.config.ConnectionConfig.Builder
	 */
	export interface ConnectionConfig$Builder extends Java.Object {
		build(): Http.ConnectionConfig;
		setBufferSize(bufferSize: int): Http.ConnectionConfig$Builder;
		setCharset(charset: Java.Charset): Http.ConnectionConfig$Builder;
		setFragmentSizeHint(fragmentSizeHint: int): Http.ConnectionConfig$Builder;
		setMalformedInputAction(malformedInputAction: Java.CodingErrorAction): Http.ConnectionConfig$Builder;
		setMessageConstraints(messageConstraints: Http.MessageConstraints): Http.ConnectionConfig$Builder;
		setUnmappableInputAction(unmappableInputAction: Java.CodingErrorAction): Http.ConnectionConfig$Builder;
	}
	export module ConnectionConfig$Builder {
		/**
		 * Corresponding Java class: org.apache.http.config.ConnectionConfig.Builder
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.ConnectionConfig$Builder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.config.Lookup
	 * Generic lookup by low-case string ID.
	 *
	 * @since 4.3
	 */
	export interface Lookup<I = any> extends Java.Object {
		lookup(name: string): I;
	}
	export module Lookup {
		/**
		 * Corresponding Java class: org.apache.http.config.Lookup
		 * Generic lookup by low-case string ID.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.config.MessageConstraints
	 * HTTP Message constraints: line length and header count.
	 * 
	 * Please note that line length is defined in bytes and not characters.
	 * This is only relevant however when using non-standard HTTP charsets
	 * for protocol elements such as UTF-8.
	 * 
	 *
	 * @since 4.3
	 */
	export interface MessageConstraints extends Java.Object, Java.Cloneable {
		getMaxHeaderCount(): int;
		getMaxLineLength(): int;
		toString(): string;
	}
	export module MessageConstraints {
		/**
		 * Corresponding Java class: org.apache.http.config.MessageConstraints
		 * HTTP Message constraints: line length and header count.
		 * 
		 * Please note that line length is defined in bytes and not characters.
		 * This is only relevant however when using non-standard HTTP charsets
		 * for protocol elements such as UTF-8.
		 * 
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Java.Cloneable.Static {
			Builder: MessageConstraints$Builder.Static;
			new(): Http.MessageConstraints;
			DEFAULT?: Http.MessageConstraints;
			copy(config: Http.MessageConstraints): Http.MessageConstraints$Builder;
			custom(): Http.MessageConstraints$Builder;
			lineLen(max: int): Http.MessageConstraints;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.config.MessageConstraints.Builder
	 */
	export interface MessageConstraints$Builder extends Java.Object {
		build(): Http.MessageConstraints;
		setMaxHeaderCount(maxHeaderCount: int): Http.MessageConstraints$Builder;
		setMaxLineLength(maxLineLength: int): Http.MessageConstraints$Builder;
	}
	export module MessageConstraints$Builder {
		/**
		 * Corresponding Java class: org.apache.http.config.MessageConstraints.Builder
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.MessageConstraints$Builder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.config.Registry
	 * Generic registry of items keyed by low-case string ID.
	 *
	 * @since 4.3
	 */
	export interface Registry<I = any> extends Java.Object, Http.Lookup<I> {
		lookup(key: string): I;
		toString(): string;
	}
	export module Registry {
		/**
		 * Corresponding Java class: org.apache.http.config.Registry
		 * Generic registry of items keyed by low-case string ID.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.Lookup.Static {
			new <I>(): Http.Registry<I>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.config.RegistryBuilder
	 * Builder for {@link Registry} instances.
	 *
	 * @since 4.3
	 */
	export interface RegistryBuilder<I = any> extends Java.Object {
		build(): Http.Registry<I>;
		register(id: string, item: I): Http.RegistryBuilder<I>;
		toString(): string;
	}
	export module RegistryBuilder {
		/**
		 * Corresponding Java class: org.apache.http.config.RegistryBuilder
		 * Builder for {@link Registry} instances.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			new <I>(): Http.RegistryBuilder<I>;
			create<I>(): Http.RegistryBuilder<I>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.config.SocketConfig
	 * Socket configuration.
	 *
	 * @since 4.3
	 */
	export interface SocketConfig extends Java.Object, Java.Cloneable {
		/**
		 * Determines the maximum queue length for incoming connection indications
		 * (a request to connect) also known as server socket backlog.
		 * 
		 * Default: {@code 0} (system default)
		 * 
		 * @return the maximum queue length for incoming connection indications
		 * @since 4.4
		 */
		getBacklogSize(): int;
		/**
		 * Determines the default value of the {@link java.net.SocketOptions#SO_RCVBUF} parameter
		 * for newly created sockets.
		 * 
		 * Default: {@code 0} (system default)
		 * 
		 *
		 * @return the default value of the {@link java.net.SocketOptions#SO_RCVBUF} parameter.
		 * @see java.net.SocketOptions#SO_RCVBUF
		 * @since 4.4
		 */
		getRcvBufSize(): int;
		/**
		 * Determines the default value of the {@link java.net.SocketOptions#SO_SNDBUF} parameter
		 * for newly created sockets.
		 * 
		 * Default: {@code 0} (system default)
		 * 
		 *
		 * @return the default value of the {@link java.net.SocketOptions#SO_SNDBUF} parameter.
		 * @see java.net.SocketOptions#SO_SNDBUF
		 * @since 4.4
		 */
		getSndBufSize(): int;
		/**
		 * Determines the default value of the {@link java.net.SocketOptions#SO_LINGER} parameter
		 * for newly created sockets.
		 * 
		 * Default: {@code -1}
		 * 
		 *
		 * @return the default value of the {@link java.net.SocketOptions#SO_LINGER} parameter.
		 * @see java.net.SocketOptions#SO_LINGER
		 */
		getSoLinger(): int;
		/**
		 * Determines the default socket timeout value for non-blocking I/O operations.
		 * 
		 * Default: {@code 0} (no timeout)
		 * 
		 *
		 * @return the default socket timeout value for non-blocking I/O operations.
		 * @see java.net.SocketOptions#SO_TIMEOUT
		 */
		getSoTimeout(): int;
		/**
		 * Determines the default value of the {@link java.net.SocketOptions#SO_KEEPALIVE} parameter
		 * for newly created sockets.
		 * 
		 * Default: {@code -1}
		 * 
		 *
		 * @return the default value of the {@link java.net.SocketOptions#SO_KEEPALIVE} parameter.
		 * @see java.net.SocketOptions#SO_KEEPALIVE
		 */
		isSoKeepAlive(): boolean;
		/**
		 * Determines the default value of the {@link java.net.SocketOptions#SO_REUSEADDR} parameter
		 * for newly created sockets.
		 * 
		 * Default: {@code false}
		 * 
		 *
		 * @return the default value of the {@link java.net.SocketOptions#SO_REUSEADDR} parameter.
		 * @see java.net.SocketOptions#SO_REUSEADDR
		 */
		isSoReuseAddress(): boolean;
		/**
		 * Determines the default value of the {@link java.net.SocketOptions#TCP_NODELAY} parameter
		 * for newly created sockets.
		 * 
		 * Default: {@code false}
		 * 
		 *
		 * @return the default value of the {@link java.net.SocketOptions#TCP_NODELAY} parameter.
		 * @see java.net.SocketOptions#TCP_NODELAY
		 */
		isTcpNoDelay(): boolean;
		toString(): string;
	}
	export module SocketConfig {
		/**
		 * Corresponding Java class: org.apache.http.config.SocketConfig
		 * Socket configuration.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Java.Cloneable.Static {
			Builder: SocketConfig$Builder.Static;
			new(): Http.SocketConfig;
			DEFAULT?: Http.SocketConfig;
			copy(config: Http.SocketConfig): Http.SocketConfig$Builder;
			custom(): Http.SocketConfig$Builder;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.config.SocketConfig.Builder
	 */
	export interface SocketConfig$Builder extends Java.Object {
		build(): Http.SocketConfig;
		/**
		 * @since 4.4
		 */
		setBacklogSize(backlogSize: int): Http.SocketConfig$Builder;
		/**
		 * @since 4.4
		 */
		setRcvBufSize(rcvBufSize: int): Http.SocketConfig$Builder;
		/**
		 * @since 4.4
		 */
		setSndBufSize(sndBufSize: int): Http.SocketConfig$Builder;
		setSoKeepAlive(soKeepAlive: boolean): Http.SocketConfig$Builder;
		setSoLinger(soLinger: int): Http.SocketConfig$Builder;
		setSoReuseAddress(soReuseAddress: boolean): Http.SocketConfig$Builder;
		setSoTimeout(soTimeout: int): Http.SocketConfig$Builder;
		setTcpNoDelay(tcpNoDelay: boolean): Http.SocketConfig$Builder;
	}
	export module SocketConfig$Builder {
		/**
		 * Corresponding Java class: org.apache.http.config.SocketConfig.Builder
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.SocketConfig$Builder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ConnectionClosedException
	 * Signals that the connection has been closed unexpectedly.
	 *
	 * @since 4.0
	 */
	export interface ConnectionClosedException extends Java.IOException {
	}
	export module ConnectionClosedException {
		/**
		 * Corresponding Java class: org.apache.http.ConnectionClosedException
		 * Signals that the connection has been closed unexpectedly.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.IOException.Static {
			/**
			 * Creates a new ConnectionClosedException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.ConnectionClosedException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ConnectionReuseStrategy
	 * Interface for deciding whether a connection can be re-used for
	 * subsequent requests and should be kept alive.
	 * 
	 * Implementations of this interface must be thread-safe. Access to shared
	 * data must be synchronized as methods of this interface may be executed
	 * from multiple threads.
	 *
	 * @since 4.0
	 */
	export interface ConnectionReuseStrategy extends Java.Object {
		/**
		 * Decides whether a connection can be kept open after a request.
		 * If this method returns {@code false}, the caller MUST
		 * close the connection to correctly comply with the HTTP protocol.
		 * If it returns {@code true}, the caller SHOULD attempt to
		 * keep the connection open for reuse with another request.
		 * 
		 * One can use the HTTP context to retrieve additional objects that
		 * may be relevant for the keep-alive strategy: the actual HTTP
		 * connection, the original HTTP request, target host if known,
		 * number of times the connection has been reused already and so on.
		 * 
		 * 
		 * If the connection is already closed, {@code false} is returned.
		 * The stale connection check MUST NOT be triggered by a
		 * connection reuse strategy.
		 * 
		 *
		 * @param response
		 *          The last response received over that connection.
		 * @param context   the context in which the connection is being
		 *          used.
		 *
		 * @return {@code true} if the connection is allowed to be reused, or
		 *         {@code false} if it MUST NOT be reused
		 */
		keepAlive(response: Http.HttpResponse, context: Http.HttpContext): boolean;
	}
	export module ConnectionReuseStrategy {
		/**
		 * Corresponding Java class: org.apache.http.ConnectionReuseStrategy
		 * Interface for deciding whether a connection can be re-used for
		 * subsequent requests and should be kept alive.
		 * 
		 * Implementations of this interface must be thread-safe. Access to shared
		 * data must be synchronized as methods of this interface may be executed
		 * from multiple threads.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.Consts
	 * Commons constants.
	 *
	 * @since 4.2
	 */
	export interface Consts extends Java.Object {
	}
	export module Consts {
		/**
		 * Corresponding Java class: org.apache.http.Consts
		 * Commons constants.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
			CR?: int;
			LF?: int;
			SP?: int;
			HT?: int;
			UTF_8?: Java.Charset;
			ASCII?: Java.Charset;
			ISO_8859_1?: Java.Charset;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ContentTooLongException
	 * Signals that HTTP entity content is too long.
	 *
	 * @since 4.2
	 */
	export interface ContentTooLongException extends Java.IOException {
	}
	export module ContentTooLongException {
		/**
		 * Corresponding Java class: org.apache.http.ContentTooLongException
		 * Signals that HTTP entity content is too long.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.IOException.Static {
			/**
			 * Creates a new ContentTooLongException with the specified detail message.
			 *
			 * @param message exception message
			 */
			new(message: string): Http.ContentTooLongException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.AbstractHttpEntity
	 * Abstract base class for entities.
	 * Provides the commonly used attributes for streamed and self-contained
	 * implementations of {@link HttpEntity HttpEntity}.
	 *
	 * @since 4.0
	 */
	export interface AbstractHttpEntity extends Java.Object, Http.HttpEntity {
		/**
		 * Obtains the Content-Encoding header.
		 * The default implementation returns the value of the
		 * {@link #contentEncoding contentEncoding} attribute.
		 *
		 * @return  the Content-Encoding header, or {@code null}
		 */
		getContentEncoding(): Http.Header;
		/**
		 * Obtains the Content-Type header.
		 * The default implementation returns the value of the
		 * {@link #contentType contentType} attribute.
		 *
		 * @return  the Content-Type header, or {@code null}
		 */
		getContentType(): Http.Header;
		/**
		 * Obtains the 'chunked' flag.
		 * The default implementation returns the value of the
		 * {@link #chunked chunked} attribute.
		 *
		 * @return  the 'chunked' flag
		 */
		isChunked(): boolean;
		/**
		 * Specifies the 'chunked' flag.
		 * 
		 * Note that the chunked setting is a hint only.
		 * If using HTTP/1.0, chunking is never performed.
		 * Otherwise, even if chunked is false, HttpClient must
		 * use chunk coding if the entity content length is
		 * unknown (-1).
		 * 
		 * The default implementation sets the value of the
		 * {@link #chunked chunked} attribute.
		 *
		 * @param b         the new 'chunked' flag
		 */
		setChunked(b: boolean): void;
		/**
		 * Specifies the Content-Encoding header.
		 * The default implementation sets the value of the
		 * {@link #contentEncoding contentEncoding} attribute.
		 *
		 * @param contentEncoding   the new Content-Encoding header, or
		 *                          {@code null} to unset
		 */
		setContentEncoding(contentEncoding: Http.Header): void;
		/**
		 * Specifies the Content-Encoding header, as a string.
		 * The default implementation calls
		 * {@link #setContentEncoding(Header) setContentEncoding(Header)}.
		 *
		 * @param ceString     the new Content-Encoding header, or
		 *                     {@code null} to unset
		 */
		setContentEncoding(ceString: string): void;
		/**
		 * Specifies the Content-Type header.
		 * The default implementation sets the value of the
		 * {@link #contentType contentType} attribute.
		 *
		 * @param contentType       the new Content-Type header, or
		 *                          {@code null} to unset
		 */
		setContentType(contentType: Http.Header): void;
		/**
		 * Specifies the Content-Type header, as a string.
		 * The default implementation calls
		 * {@link #setContentType(Header) setContentType(Header)}.
		 *
		 * @param ctString     the new Content-Type header, or
		 *                     {@code null} to unset
		 */
		setContentType(ctString: string): void;
		toString(): string;
	}
	export module AbstractHttpEntity {
		/**
		 * Corresponding Java class: org.apache.http.entity.AbstractHttpEntity
		 * Abstract base class for entities.
		 * Provides the commonly used attributes for streamed and self-contained
		 * implementations of {@link HttpEntity HttpEntity}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpEntity.Static {
			new(): Http.AbstractHttpEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.BasicHttpEntity
	 * A generic streamed, non-repeatable entity that obtains its content
	 * from an {@link InputStream}.
	 *
	 * @since 4.0
	 */
	export interface BasicHttpEntity extends Http.AbstractHttpEntity {
		/**
		 * Obtains the content, once only.
		 *
		 * @return  the content, if this is the first call to this method
		 *          since {@link #setContent setContent} has been called
		 *
		 * @throws IllegalStateException
		 *          if the content has not been provided
		 */
		getContent(): Java.InputStream;
		getContentLength(): long;
		/**
		 * Tells that this entity is not repeatable.
		 *
		 * @return {@code false}
		 */
		isRepeatable(): boolean;
		isStreaming(): boolean;
		/**
		 * Specifies the content.
		 *
		 * @param instream          the stream to return with the next call to
		 *                          {@link #getContent getContent}
		 */
		setContent(instream: Java.InputStream): void;
		/**
		 * Specifies the length of the content.
		 *
		 * @param len       the number of bytes in the content, or
		 *                  a negative number to indicate an unknown length
		 */
		setContentLength(len: long): void;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module BasicHttpEntity {
		/**
		 * Corresponding Java class: org.apache.http.entity.BasicHttpEntity
		 * A generic streamed, non-repeatable entity that obtains its content
		 * from an {@link InputStream}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractHttpEntity.Static {
			/**
			 * Creates a new basic entity.
			 * The content is initially missing, the content length
			 * is set to a negative number.
			 */
			new(): Http.BasicHttpEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.BufferedHttpEntity
	 * A wrapping entity that buffers it content if necessary.
	 * The buffered entity is always repeatable.
	 * If the wrapped entity is repeatable itself, calls are passed through.
	 * If the wrapped entity is not repeatable, the content is read into a
	 * buffer once and provided from there as often as required.
	 *
	 * @since 4.0
	 */
	export interface BufferedHttpEntity extends Http.HttpEntityWrapper {
		getContent(): Java.InputStream;
		getContentLength(): long;
		/**
		 * Tells that this entity does not have to be chunked.
		 *
		 * @return  {@code false}
		 */
		isChunked(): boolean;
		/**
		 * Tells that this entity is repeatable.
		 *
		 * @return  {@code true}
		 */
		isRepeatable(): boolean;
		isStreaming(): boolean;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module BufferedHttpEntity {
		/**
		 * Corresponding Java class: org.apache.http.entity.BufferedHttpEntity
		 * A wrapping entity that buffers it content if necessary.
		 * The buffered entity is always repeatable.
		 * If the wrapped entity is repeatable itself, calls are passed through.
		 * If the wrapped entity is not repeatable, the content is read into a
		 * buffer once and provided from there as often as required.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpEntityWrapper.Static {
			/**
			 * Creates a new buffered entity wrapper.
			 *
			 * @param entity   the entity to wrap, not null
			 * @throws IllegalArgumentException if wrapped is null
			 */
			new(entity: Http.HttpEntity): Http.BufferedHttpEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.ByteArrayEntity
	 * A self contained, repeatable entity that obtains its content from a byte array.
	 *
	 * @since 4.0
	 */
	export interface ByteArrayEntity extends Http.AbstractHttpEntity, Java.Cloneable {
		clone(): obj;
		getContent(): Java.InputStream;
		getContentLength(): long;
		isRepeatable(): boolean;
		/**
		 * Tells that this entity is not streaming.
		 *
		 * @return {@code false}
		 */
		isStreaming(): boolean;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module ByteArrayEntity {
		/**
		 * Corresponding Java class: org.apache.http.entity.ByteArrayEntity
		 * A self contained, repeatable entity that obtains its content from a byte array.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractHttpEntity.Static, Java.Cloneable.Static {
			/**
			 * @since 4.2
			 */
			new(b: array<byte>, contentType: Http.ContentType): Http.ByteArrayEntity;
			/**
			 * @since 4.2
			 */
			new(b: array<byte>, off: int, len: int, contentType: Http.ContentType): Http.ByteArrayEntity;
			new(b: array<byte>): Http.ByteArrayEntity;
			new(b: array<byte>, off: int, len: int): Http.ByteArrayEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.ContentLengthStrategy
	 * Represents a strategy to determine length of the enclosed content entity
	 * based on properties of the HTTP message.
	 *
	 * @since 4.0
	 */
	export interface ContentLengthStrategy extends Java.Object {
		/**
		 * Returns length of the given message in bytes. The returned value
		 * must be a non-negative number, {@link #IDENTITY} if the end of the
		 * message will be delimited by the end of connection, or {@link #CHUNKED}
		 * if the message is chunk coded
		 *
		 * @param message HTTP message
		 * @return content length, {@link #IDENTITY}, or {@link #CHUNKED}
		 *
		 * @throws HttpException in case of HTTP protocol violation
		 */
		determineLength(message: Http.HttpMessage): long;
	}
	export module ContentLengthStrategy {
		/**
		 * Corresponding Java class: org.apache.http.entity.ContentLengthStrategy
		 * Represents a strategy to determine length of the enclosed content entity
		 * based on properties of the HTTP message.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			IDENTITY?: int;
			CHUNKED?: int;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.ContentProducer
	 * An abstract entity content producer.
	 *Content producers are expected to be able to produce their
	 * content multiple times
	 *
	 * @since 4.0
	 */
	export interface ContentProducer extends Java.Object {
		writeTo(outstream: Java.OutputStream): void;
	}
	export module ContentProducer {
		/**
		 * Corresponding Java class: org.apache.http.entity.ContentProducer
		 * An abstract entity content producer.
		 *Content producers are expected to be able to produce their
		 * content multiple times
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.ContentType
	 * Content type information consisting of a MIME type and an optional charset.
	 * 
	 * This class makes no attempts to verify validity of the MIME type.
	 * The input parameters of the {@link #create(String, String)} method, however, may not
	 * contain characters {@code , , } reserved by the HTTP specification.
	 *
	 * @since 4.2
	 */
	export interface ContentType extends Java.Object, Java.Serializable {
		getCharset(): Java.Charset;
		getMimeType(): string;
		/**
		 * @since 4.3
		 */
		getParameter(name: string): string;
		/**
		 * Generates textual representation of this content type which can be used as the value
		 * of a {@code Content-Type} header.
		 */
		toString(): string;
		/**
		 * Creates a new instance with this MIME type and the given Charset.
		 *
		 * @param charset charset
		 * @return a new instance with this MIME type and the given Charset.
		 * @since 4.3
		 */
		withCharset(charset: Java.Charset): Http.ContentType;
		/**
		 * Creates a new instance with this MIME type and the given Charset name.
		 *
		 * @param charset name
		 * @return a new instance with this MIME type and the given Charset name.
		 * @throws UnsupportedCharsetException Thrown when the named charset is not available in
		 * this instance of the Java virtual machine
		 * @since 4.3
		 */
		withCharset(charset: string): Http.ContentType;
		/**
		 * Creates a new instance with this MIME type and the given parameters.
		 *
		 * @param params
		 * @return a new instance with this MIME type and the given parameters.
		 * @since 4.4
		 */
		withParameters(...params: Http.NameValuePair[]): Http.ContentType;
		/**
		 * Creates a new instance with this MIME type and the given parameters.
		 *
		 * @param params
		 * @return a new instance with this MIME type and the given parameters.
		 * @since 4.4
		 */
		withParameters(params: array<Http.NameValuePair>): Http.ContentType;
	}
	export module ContentType {
		/**
		 * Corresponding Java class: org.apache.http.entity.ContentType
		 * Content type information consisting of a MIME type and an optional charset.
		 * 
		 * This class makes no attempts to verify validity of the MIME type.
		 * The input parameters of the {@link #create(String, String)} method, however, may not
		 * contain characters {@code , , } reserved by the HTTP specification.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Java.Serializable.Static {
			new(): Http.ContentType;
			APPLICATION_ATOM_XML?: Http.ContentType;
			APPLICATION_FORM_URLENCODED?: Http.ContentType;
			APPLICATION_JSON?: Http.ContentType;
			APPLICATION_OCTET_STREAM?: Http.ContentType;
			APPLICATION_SVG_XML?: Http.ContentType;
			APPLICATION_XHTML_XML?: Http.ContentType;
			APPLICATION_XML?: Http.ContentType;
			MULTIPART_FORM_DATA?: Http.ContentType;
			TEXT_HTML?: Http.ContentType;
			TEXT_PLAIN?: Http.ContentType;
			TEXT_XML?: Http.ContentType;
			WILDCARD?: Http.ContentType;
			DEFAULT_TEXT?: Http.ContentType;
			DEFAULT_BINARY?: Http.ContentType;
			/**
			 * Creates a new instance of {@link ContentType}.
			 *
			 * @param mimeType MIME type. It may not be {@code null} or empty. It may not contain
			 *        characters {@code , , } reserved by the HTTP specification.
			 * @param charset charset.
			 * @return content type
			 */
			create(mimeType: string, charset: Java.Charset): Http.ContentType;
			/**
			 * Creates a new instance of {@link ContentType} without a charset.
			 *
			 * @param mimeType MIME type. It may not be {@code null} or empty. It may not contain
			 *        characters {@code , , } reserved by the HTTP specification.
			 * @return content type
			 */
			create(mimeType: string): Http.ContentType;
			/**
			 * Creates a new instance of {@link ContentType}.
			 *
			 * @param mimeType MIME type. It may not be {@code null} or empty. It may not contain
			 *        characters {@code , , } reserved by the HTTP specification.
			 * @param charset charset. It may not contain characters {@code , , } reserved by the HTTP
			 *        specification. This parameter is optional.
			 * @return content type
			 * @throws UnsupportedCharsetException Thrown when the named charset is not available in
			 * this instance of the Java virtual machine
			 */
			create(mimeType: string, charset: string): Http.ContentType;
			/**
			 * Creates a new instance of {@link ContentType} with the given parameters.
			 *
			 * @param mimeType MIME type. It may not be {@code null} or empty. It may not contain
			 *        characters {@code , , } reserved by the HTTP specification.
			 * @param params parameters.
			 * @return content type
			 *
			 * @since 4.4
			 */
			create(mimeType: string, ...params: Http.NameValuePair[]): Http.ContentType;
			/**
			 * Creates a new instance of {@link ContentType} with the given parameters.
			 *
			 * @param mimeType MIME type. It may not be {@code null} or empty. It may not contain
			 *        characters {@code , , } reserved by the HTTP specification.
			 * @param params parameters.
			 * @return content type
			 *
			 * @since 4.4
			 */
			create(mimeType: string, params: array<Http.NameValuePair>): Http.ContentType;
			/**
			 * Extracts {@code Content-Type} value from {@link HttpEntity} exactly as
			 * specified by the {@code Content-Type} header of the entity. Returns {@code null}
			 * if not specified.
			 *
			 * @param entity HTTP entity
			 * @return content type
			 * @throws ParseException if the given text does not represent a valid
			 * {@code Content-Type} value.
			 * @throws UnsupportedCharsetException Thrown when the named charset is not available in
			 * this instance of the Java virtual machine
			 */
			get(entity: Http.HttpEntity): Http.ContentType;
			/**
			 * Returns {@code Content-Type} for the given MIME type.
			 *
			 * @param mimeType MIME type
			 * @return content type or {@code null} if not known.
			 *
			 * @since 4.5
			 */
			getByMimeType(mimeType: string): Http.ContentType;
			/**
			 * Extracts {@code Content-Type} value from {@link HttpEntity}. Returns {@code null}
			 * if not specified or incorrect (could not be parsed)..
			 *
			 * @param entity HTTP entity
			 * @return content type
			 *
			 * @since 4.4
			 *
			 */
			getLenient(entity: Http.HttpEntity): Http.ContentType;
			/**
			 * Extracts {@code Content-Type} value from {@link HttpEntity} or returns the default value
			 * {@link #DEFAULT_TEXT} if not explicitly specified or incorrect (could not be parsed).
			 *
			 * @param entity HTTP entity
			 * @return content type
			 *
			 * @since 4.4
			 */
			getLenientOrDefault(entity: Http.HttpEntity): Http.ContentType;
			/**
			 * Extracts {@code Content-Type} value from {@link HttpEntity} or returns the default value
			 * {@link #DEFAULT_TEXT} if not explicitly specified.
			 *
			 * @param entity HTTP entity
			 * @return content type
			 * @throws ParseException if the given text does not represent a valid
			 * {@code Content-Type} value.
			 * @throws UnsupportedCharsetException Thrown when the named charset is not available in
			 * this instance of the Java virtual machine
			 */
			getOrDefault(entity: Http.HttpEntity): Http.ContentType;
			/**
			 * Parses textual representation of {@code Content-Type} value.
			 *
			 * @param s text
			 * @return content type
			 * @throws ParseException if the given text does not represent a valid
			 * {@code Content-Type} value.
			 * @throws UnsupportedCharsetException Thrown when the named charset is not available in
			 * this instance of the Java virtual machine
			 */
			parse(s: string): Http.ContentType;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.EntityTemplate
	 * Entity that delegates the process of content generation
	 * to a {@link ContentProducer}.
	 *
	 * @since 4.0
	 */
	export interface EntityTemplate extends Http.AbstractHttpEntity {
		getContent(): Java.InputStream;
		getContentLength(): long;
		isRepeatable(): boolean;
		isStreaming(): boolean;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module EntityTemplate {
		/**
		 * Corresponding Java class: org.apache.http.entity.EntityTemplate
		 * Entity that delegates the process of content generation
		 * to a {@link ContentProducer}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractHttpEntity.Static {
			new(contentproducer: Http.ContentProducer): Http.EntityTemplate;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.FileEntity
	 * A self contained, repeatable entity that obtains its content from a file.
	 *
	 * @since 4.0
	 */
	export interface FileEntity extends Http.AbstractHttpEntity, Java.Cloneable {
		clone(): obj;
		getContent(): Java.InputStream;
		getContentLength(): long;
		isRepeatable(): boolean;
		/**
		 * Tells that this entity is not streaming.
		 *
		 * @return {@code false}
		 */
		isStreaming(): boolean;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module FileEntity {
		/**
		 * Corresponding Java class: org.apache.http.entity.FileEntity
		 * A self contained, repeatable entity that obtains its content from a file.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractHttpEntity.Static, Java.Cloneable.Static {
			/**
			 * @since 4.2
			 */
			new(file: Java.File, contentType: Http.ContentType): Http.FileEntity;
			/**
			 * @since 4.2
			 */
			new(file: Java.File): Http.FileEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.HttpEntityWrapper
	 * Base class for wrapping entities.
	 * Keeps a {@link #wrappedEntity wrappedEntity} and delegates all
	 * calls to it. Implementations of wrapping entities can derive
	 * from this class and need to override only those methods that
	 * should not be delegated to the wrapped entity.
	 *
	 * @since 4.0
	 */
	export interface HttpEntityWrapper extends Java.Object, Http.HttpEntity {
		getContent(): Java.InputStream;
		getContentEncoding(): Http.Header;
		getContentLength(): long;
		getContentType(): Http.Header;
		isChunked(): boolean;
		isRepeatable(): boolean;
		isStreaming(): boolean;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module HttpEntityWrapper {
		/**
		 * Corresponding Java class: org.apache.http.entity.HttpEntityWrapper
		 * Base class for wrapping entities.
		 * Keeps a {@link #wrappedEntity wrappedEntity} and delegates all
		 * calls to it. Implementations of wrapping entities can derive
		 * from this class and need to override only those methods that
		 * should not be delegated to the wrapped entity.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpEntity.Static {
			/**
			 * Creates a new entity wrapper.
			 */
			new(wrappedEntity: Http.HttpEntity): Http.HttpEntityWrapper;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.InputStreamEntity
	 * A streamed, non-repeatable entity that obtains its content from
	 * an {@link InputStream}.
	 *
	 * @since 4.0
	 */
	export interface InputStreamEntity extends Http.AbstractHttpEntity {
		getContent(): Java.InputStream;
		/**
		 * @return the content length or {@code -1} if unknown
		 */
		getContentLength(): long;
		isRepeatable(): boolean;
		isStreaming(): boolean;
		/**
		 * Writes bytes from the {@code InputStream} this entity was constructed
		 * with to an {@code OutputStream}.  The content length
		 * determines how many bytes are written.  If the length is unknown ({@code -1}), the
		 * stream will be completely consumed (to the end of the stream).
		 *
		 */
		writeTo(outstream: Java.OutputStream): void;
	}
	export module InputStreamEntity {
		/**
		 * Corresponding Java class: org.apache.http.entity.InputStreamEntity
		 * A streamed, non-repeatable entity that obtains its content from
		 * an {@link InputStream}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractHttpEntity.Static {
			/**
			 * Creates an entity with an unknown length.
			 * Equivalent to {@code new InputStreamEntity(instream, -1)}.
			 *
			 * @param instream input stream
			 * @throws IllegalArgumentException if {@code instream} is {@code null}
			 * @since 4.3
			 */
			new(instream: Java.InputStream): Http.InputStreamEntity;
			/**
			 * Creates an entity with a specified content length.
			 *
			 * @param instream input stream
			 * @param length of the input stream, {@code -1} if unknown
			 * @throws IllegalArgumentException if {@code instream} is {@code null}
			 */
			new(instream: Java.InputStream, length: long): Http.InputStreamEntity;
			/**
			 * Creates an entity with a content type and unknown length.
			 * Equivalent to {@code new InputStreamEntity(instream, -1, contentType)}.
			 *
			 * @param instream input stream
			 * @param contentType content type
			 * @throws IllegalArgumentException if {@code instream} is {@code null}
			 * @since 4.3
			 */
			new(instream: Java.InputStream, contentType: Http.ContentType): Http.InputStreamEntity;
			/**
			 * @param instream input stream
			 * @param length of the input stream, {@code -1} if unknown
			 * @param contentType for specifying the {@code Content-Type} header, may be {@code null}
			 * @throws IllegalArgumentException if {@code instream} is {@code null}
			 * @since 4.2
			 */
			new(instream: Java.InputStream, length: long, contentType: Http.ContentType): Http.InputStreamEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.SerializableEntity
	 * A streamed entity that obtains its content from a {@link Serializable}.
	 * The content obtained from the {@link Serializable} instance can
	 * optionally be buffered in a byte array in order to make the
	 * entity self-contained and repeatable.
	 *
	 * @since 4.0
	 */
	export interface SerializableEntity extends Http.AbstractHttpEntity {
		getContent(): Java.InputStream;
		getContentLength(): long;
		isRepeatable(): boolean;
		isStreaming(): boolean;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module SerializableEntity {
		/**
		 * Corresponding Java class: org.apache.http.entity.SerializableEntity
		 * A streamed entity that obtains its content from a {@link Serializable}.
		 * The content obtained from the {@link Serializable} instance can
		 * optionally be buffered in a byte array in order to make the
		 * entity self-contained and repeatable.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractHttpEntity.Static {
			/**
			 * Creates new instance of this class.
			 *
			 * @param ser input
			 * @param bufferize tells whether the content should be
			 *        stored in an internal buffer
			 * @throws IOException in case of an I/O error
			 */
			new(ser: Java.Serializable, bufferize: boolean): Http.SerializableEntity;
			/**
			 * @since 4.3
			 */
			new(ser: Java.Serializable): Http.SerializableEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.entity.StringEntity
	 * A self contained, repeatable entity that obtains its content from
	 * a {@link String}.
	 *
	 * @since 4.0
	 */
	export interface StringEntity extends Http.AbstractHttpEntity, Java.Cloneable {
		clone(): obj;
		getContent(): Java.InputStream;
		getContentLength(): long;
		isRepeatable(): boolean;
		/**
		 * Tells that this entity is not streaming.
		 *
		 * @return {@code false}
		 */
		isStreaming(): boolean;
		writeTo(outstream: Java.OutputStream): void;
	}
	export module StringEntity {
		/**
		 * Corresponding Java class: org.apache.http.entity.StringEntity
		 * A self contained, repeatable entity that obtains its content from
		 * a {@link String}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractHttpEntity.Static, Java.Cloneable.Static {
			/**
			 * Creates a StringEntity with the specified content and content type.
			 *
			 * @param string content to be used. Not {@code null}.
			 * @param contentType content type to be used. May be {@code null}, in which case the default
			 *   MIME type {@link ContentType#TEXT_PLAIN} is assumed.
			 *
			 * @throws IllegalArgumentException if the string parameter is null
			 * @throws UnsupportedCharsetException Thrown when the named charset is not available in
			 * this instance of the Java virtual machine
			 * @since 4.2
			 */
			new(string: string, contentType: Http.ContentType): Http.StringEntity;
			/**
			 * Creates a StringEntity with the specified content and charset. The MIME type defaults
			 * to "text/plain".
			 *
			 * @param string content to be used. Not {@code null}.
			 * @param charset character set to be used. May be {@code null}, in which case the default
			 *   is {@link HTTP#DEF_CONTENT_CHARSET} is assumed
			 *
			 * @throws IllegalArgumentException if the string parameter is null
			 * @throws UnsupportedCharsetException Thrown when the named charset is not available in
			 * this instance of the Java virtual machine
			 */
			new(string: string, charset: string): Http.StringEntity;
			/**
			 * Creates a StringEntity with the specified content and charset. The MIME type defaults
			 * to "text/plain".
			 *
			 * @param string content to be used. Not {@code null}.
			 * @param charset character set to be used. May be {@code null}, in which case the default
			 *   is {@link HTTP#DEF_CONTENT_CHARSET} is assumed
			 *
			 * @throws IllegalArgumentException if the string parameter is null
			 *
			 * @since 4.2
			 */
			new(string: string, charset: Java.Charset): Http.StringEntity;
			/**
			 * Creates a StringEntity with the specified content. The content type defaults to
			 * {@link ContentType#TEXT_PLAIN}.
			 *
			 * @param string content to be used. Not {@code null}.
			 *
			 * @throws IllegalArgumentException if the string parameter is null
			 * @throws UnsupportedEncodingException if the default HTTP charset is not supported.
			 */
			new(string: string): Http.StringEntity;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ExceptionLogger
	 * @since 4.4
	 */
	export interface ExceptionLogger extends Java.Object {
		log(ex: Java.Exception): void;
	}
	export module ExceptionLogger {
		/**
		 * Corresponding Java class: org.apache.http.ExceptionLogger
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			NO_OP?: Http.ExceptionLogger;
			STD_ERR?: Http.ExceptionLogger;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.FormattedHeader
	 * An HTTP header which is already formatted.
	 * For example when headers are received, the original formatting
	 * can be preserved. This allows for the header to be sent without
	 * another formatting step.
	 *
	 * @since 4.0
	 */
	export interface FormattedHeader extends Http.Header {
		/**
		 * Obtains the buffer with the formatted header.
		 * The returned buffer MUST NOT be modified.
		 *
		 * @return  the formatted header, in a buffer that must not be modified
		 */
		getBuffer(): Http.CharArrayBuffer;
		/**
		 * Obtains the start of the header value in the {@link #getBuffer buffer}.
		 * By accessing the value in the buffer, creation of a temporary string
		 * can be avoided.
		 *
		 * @return  index of the first character of the header value
		 *          in the buffer returned by {@link #getBuffer getBuffer}.
		 */
		getValuePos(): int;
	}
	export module FormattedHeader {
		/**
		 * Corresponding Java class: org.apache.http.FormattedHeader
		 * An HTTP header which is already formatted.
		 * For example when headers are received, the original formatting
		 * can be preserved. This allows for the header to be sent without
		 * another formatting step.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.Header.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.Header
	 * Represents an HTTP header field.
	 *
	 * The HTTP header fields follow the same generic format as
	 * that given in Section 3.1 of RFC 822. Each header field consists
	 * of a name followed by a colon (":") and the field value. Field names
	 * are case-insensitive. The field value MAY be preceded by any amount
	 * of LWS, though a single SP is preferred.
	 *
	 *
	 *     message-header = field-name ":" [ field-value ]
	 *     field-name     = token
	 *     field-value    = *( field-content | LWS )
	 *     field-content  = &lt;the OCTETs making up the field-value
	 *                      and consisting of either *TEXT or combinations
	 *                      of token, separators, and quoted-string&gt;
	 *
	 *
	 * @since 4.0
	 */
	export interface Header extends Java.Object {
		/**
		 * Parses the value.
		 *
		 * @return an array of {@link HeaderElement} entries, may be empty, but is never {@code null}
		 * @throws ParseException in case of a parsing error
		 */
		getElements(): array<Http.HeaderElement>;
		/**
		 * Get the name of the Header.
		 *
		 * @return the name of the Header,  never {@code null}
		 */
		getName(): string;
		/**
		 * Get the value of the Header.
		 *
		 * @return the value of the Header,  may be {@code null}
		 */
		getValue(): string;
	}
	export module Header {
		/**
		 * Corresponding Java class: org.apache.http.Header
		 * Represents an HTTP header field.
		 *
		 * The HTTP header fields follow the same generic format as
		 * that given in Section 3.1 of RFC 822. Each header field consists
		 * of a name followed by a colon (":") and the field value. Field names
		 * are case-insensitive. The field value MAY be preceded by any amount
		 * of LWS, though a single SP is preferred.
		 *
		 *
		 *     message-header = field-name ":" [ field-value ]
		 *     field-name     = token
		 *     field-value    = *( field-content | LWS )
		 *     field-content  = &lt;the OCTETs making up the field-value
		 *                      and consisting of either *TEXT or combinations
		 *                      of token, separators, and quoted-string&gt;
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HeaderElement
	 * One element of an HTTP {@link Header header} value consisting of
	 * a name / value pair and a number of optional name / value parameters.
	 * 
	 * Some HTTP headers (such as the set-cookie header) have values that
	 * can be decomposed into multiple elements.  Such headers must be in the
	 * following form:
	 * 
	 * 
	 * header  = [ element ] *( "," [ element ] )
	 * element = name [ "=" [ value ] ] *( ";" [ param ] )
	 * param   = name [ "=" [ value ] ]
	 *
	 * name    = token
	 * value   = ( token | quoted-string )
	 *
	 * token         = 1*&lt;any char except "=", ",", ";", &lt;"&gt; and
	 *                       white space&gt;
	 * quoted-string = &lt;"&gt; *( text | quoted-char ) &lt;"&gt;
	 * text          = any char except &lt;"&gt;
	 * quoted-char   = "\" char
	 * 
	 * 
	 * Any amount of white space is allowed between any part of the
	 * header, element or param and is ignored. A missing value in any
	 * element or param will be stored as the empty {@link String};
	 * if the "=" is also missing null will be stored instead.
	 *
	 * @since 4.0
	 */
	export interface HeaderElement extends Java.Object {
		/**
		 * Returns header element name.
		 *
		 * @return header element name
		 */
		getName(): string;
		/**
		 * Returns parameter with the given index.
		 *
		 * @param index index
		 * @return name / value pair
		 */
		getParameter(index: int): Http.NameValuePair;
		/**
		 * Returns the first parameter with the given name.
		 *
		 * @param name parameter name
		 *
		 * @return name / value pair
		 */
		getParameterByName(name: string): Http.NameValuePair;
		/**
		 * Returns the total count of parameters.
		 *
		 * @return parameter count
		 */
		getParameterCount(): int;
		/**
		 * Returns an array of name / value pairs.
		 *
		 * @return array of name / value pairs
		 */
		getParameters(): array<Http.NameValuePair>;
		/**
		 * Returns header element value.
		 *
		 * @return header element value
		 */
		getValue(): string;
	}
	export module HeaderElement {
		/**
		 * Corresponding Java class: org.apache.http.HeaderElement
		 * One element of an HTTP {@link Header header} value consisting of
		 * a name / value pair and a number of optional name / value parameters.
		 * 
		 * Some HTTP headers (such as the set-cookie header) have values that
		 * can be decomposed into multiple elements.  Such headers must be in the
		 * following form:
		 * 
		 * 
		 * header  = [ element ] *( "," [ element ] )
		 * element = name [ "=" [ value ] ] *( ";" [ param ] )
		 * param   = name [ "=" [ value ] ]
		 *
		 * name    = token
		 * value   = ( token | quoted-string )
		 *
		 * token         = 1*&lt;any char except "=", ",", ";", &lt;"&gt; and
		 *                       white space&gt;
		 * quoted-string = &lt;"&gt; *( text | quoted-char ) &lt;"&gt;
		 * text          = any char except &lt;"&gt;
		 * quoted-char   = "\" char
		 * 
		 * 
		 * Any amount of white space is allowed between any part of the
		 * header, element or param and is ignored. A missing value in any
		 * element or param will be stored as the empty {@link String};
		 * if the "=" is also missing null will be stored instead.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HeaderElementIterator
	 * A type-safe iterator for {@link HeaderElement} objects.
	 *
	 * @since 4.0
	 */
	export interface HeaderElementIterator extends Java.Iterator<obj> {
		/**
		 * Indicates whether there is another header element in this
		 * iteration.
		 *
		 * @return  {@code true} if there is another header element,
		 *          {@code false} otherwise
		 */
		hasNext(): boolean;
		/**
		 * Obtains the next header element from this iteration.
		 * This method should only be called while {@link #hasNext hasNext}
		 * is true.
		 *
		 * @return  the next header element in this iteration
		 */
		nextElement(): Http.HeaderElement;
	}
	export module HeaderElementIterator {
		/**
		 * Corresponding Java class: org.apache.http.HeaderElementIterator
		 * A type-safe iterator for {@link HeaderElement} objects.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Iterator.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HeaderIterator
	 * A type-safe iterator for {@link Header} objects.
	 *
	 * @since 4.0
	 */
	export interface HeaderIterator extends Java.Iterator<obj> {
		/**
		 * Indicates whether there is another header in this iteration.
		 *
		 * @return  {@code true} if there is another header,
		 *          {@code false} otherwise
		 */
		hasNext(): boolean;
		/**
		 * Obtains the next header from this iteration.
		 * This method should only be called while {@link #hasNext hasNext}
		 * is true.
		 *
		 * @return  the next header in this iteration
		 */
		nextHeader(): Http.Header;
	}
	export module HeaderIterator {
		/**
		 * Corresponding Java class: org.apache.http.HeaderIterator
		 * A type-safe iterator for {@link Header} objects.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Iterator.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpClientConnection
	 * A client-side HTTP connection, which can be used for sending
	 * requests and receiving responses.
	 *
	 * @since 4.0
	 */
	export interface HttpClientConnection extends Http.HttpConnection {
		/**
		 * Writes out all pending buffered data over the open connection.
		 *
		 * @throws IOException in case of an I/O error
		 */
		flush(): void;
		/**
		 * Checks if response data is available from the connection. May wait for
		 * the specified time until some data becomes available. Note that some
		 * implementations may completely ignore the timeout parameter.
		 *
		 * @param timeout the maximum time in milliseconds to wait for data
		 * @return true if data is available; false if there was no data available
		 *         even after waiting for {@code timeout} milliseconds.
		 * @throws IOException if an error happens on the connection
		 */
		isResponseAvailable(timeout: int): boolean;
		/**
		 * Receives the next response entity available from this connection and
		 * attaches it to an existing HttpResponse object.
		 *
		 * @param response the response to attach the entity to
		 * @throws HttpException in case of HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		receiveResponseEntity(response: Http.HttpResponse): void;
		/**
		 * Receives the request line and headers of the next response available from
		 * this connection. The caller should examine the HttpResponse object to
		 * find out if it should try to receive a response entity as well.
		 *
		 * @return a new HttpResponse object with status line and headers
		 *         initialized.
		 * @throws HttpException in case of HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		receiveResponseHeader(): Http.HttpResponse;
		/**
		 * Sends the request entity over the connection.
		 * @param request the request whose entity to send.
		 * @throws HttpException in case of HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		sendRequestEntity(request: Http.HttpEntityEnclosingRequest): void;
		/**
		 * Sends the request line and all headers over the connection.
		 * @param request the request whose headers to send.
		 * @throws HttpException in case of HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		sendRequestHeader(request: Http.HttpRequest): void;
	}
	export module HttpClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.HttpClientConnection
		 * A client-side HTTP connection, which can be used for sending
		 * requests and receiving responses.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpConnection.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpConnection
	 * A generic HTTP connection, useful on client and server side.
	 *
	 * @since 4.0
	 */
	export interface HttpConnection extends Java.Closeable {
		/**
		 * Closes this connection gracefully.
		 * This method will attempt to flush the internal output
		 * buffer prior to closing the underlying socket.
		 * This method MUST NOT be called from a different thread to force
		 * shutdown of the connection. Use {@link #shutdown shutdown} instead.
		 */
		close(): void;
		/**
		 * Returns a collection of connection metrics.
		 *
		 * @return HttpConnectionMetrics
		 */
		getMetrics(): Http.HttpConnectionMetrics;
		/**
		 * Returns the socket timeout value.
		 *
		 * @return positive value in milliseconds if a timeout is set,
		 * {@code 0} if timeout is disabled or {@code -1} if
		 * timeout is undefined.
		 */
		getSocketTimeout(): int;
		/**
		 * Checks if this connection is open.
		 * @return true if it is open, false if it is closed.
		 */
		isOpen(): boolean;
		/**
		 * Checks whether this connection has gone down.
		 * Network connections may get closed during some time of inactivity
		 * for several reasons. The next time a read is attempted on such a
		 * connection it will throw an IOException.
		 * This method tries to alleviate this inconvenience by trying to
		 * find out if a connection is still usable. Implementations may do
		 * that by attempting a read with a very small timeout. Thus this
		 * method may block for a small amount of time before returning a result.
		 * It is therefore an expensive operation.
		 *
		 * @return  {@code true} if attempts to use this connection are
		 *          likely to succeed, or {@code false} if they are likely
		 *          to fail and this connection should be closed
		 */
		isStale(): boolean;
		/**
		 * Sets the socket timeout value.
		 *
		 * @param timeout timeout value in milliseconds
		 */
		setSocketTimeout(timeout: int): void;
		/**
		 * Force-closes this connection.
		 * This is the only method of a connection which may be called
		 * from a different thread to terminate the connection.
		 * This method will not attempt to flush the transmitter's
		 * internal buffer prior to closing the underlying socket.
		 */
		shutdown(): void;
	}
	export module HttpConnection {
		/**
		 * Corresponding Java class: org.apache.http.HttpConnection
		 * A generic HTTP connection, useful on client and server side.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Closeable.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpConnectionFactory
	 * Factory for {@link HttpConnection} instances.
	 *
	 * @since 4.3
	 */
	export interface HttpConnectionFactory<T extends HttpConnection = any> extends Java.Object {
		createConnection(socket: Java.Socket): T;
	}
	export module HttpConnectionFactory {
		/**
		 * Corresponding Java class: org.apache.http.HttpConnectionFactory
		 * Factory for {@link HttpConnection} instances.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpConnectionMetrics
	 * The point of access to the statistics of an {@link HttpConnection}.
	 *
	 * @since 4.0
	 */
	export interface HttpConnectionMetrics extends Java.Object {
		/**
		 * Return the value for the specified metric.
		 *
		 *@param metricName the name of the metric to query.
		 *
		 *@return the object representing the metric requested,
		 *        {@code null} if the metric cannot not found.
		 */
		getMetric(metricName: string): obj;
		/**
		 * Returns the number of bytes transferred over the connection,
		 * 0 if not available.
		 */
		getReceivedBytesCount(): long;
		/**
		 * Returns the number of requests transferred over the connection,
		 * 0 if not available.
		 */
		getRequestCount(): long;
		/**
		 * Returns the number of responses transferred over the connection,
		 * 0 if not available.
		 */
		getResponseCount(): long;
		/**
		 * Returns the number of bytes transferred over the connection,
		 * 0 if not available.
		 */
		getSentBytesCount(): long;
		/**
		 * Resets the counts
		 *
		 */
		reset(): void;
	}
	export module HttpConnectionMetrics {
		/**
		 * Corresponding Java class: org.apache.http.HttpConnectionMetrics
		 * The point of access to the statistics of an {@link HttpConnection}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpEntity
	 * An entity that can be sent or received with an HTTP message.
	 * Entities can be found in some
	 * {@link HttpEntityEnclosingRequest requests} and in
	 * {@link HttpResponse responses}, where they are optional.
	 * 
	 * There are three distinct types of entities in HttpCore,
	 * depending on where their {@link #getContent content} originates:
	 * 
	 * streamed: The content is received from a stream, or
	 *     generated on the fly. In particular, this category includes
	 *     entities being received from a {@link HttpConnection connection}.
	 *     {@link #isStreaming Streamed} entities are generally not
	 *      {@link #isRepeatable repeatable}.
	 *     
	 * self-contained: The content is in memory or obtained by
	 *     means that are independent from a connection or other entity.
	 *     Self-contained entities are generally {@link #isRepeatable repeatable}.
	 *     
	 * wrapping: The content is obtained from another entity.
	 *     
	 * 
	 * This distinction is important for connection management with incoming
	 * entities. For entities that are created by an application and only sent
	 * using the HTTP components framework, the difference between streamed
	 * and self-contained is of little importance. In that case, it is suggested
	 * to consider non-repeatable entities as streamed, and those that are
	 * repeatable (without a huge effort) as self-contained.
	 *
	 * @since 4.0
	 */
	export interface HttpEntity extends Java.Object {
		/**
		 * Returns a content stream of the entity.
		 * {@link #isRepeatable Repeatable} entities are expected
		 * to create a new instance of {@link InputStream} for each invocation
		 * of this method and therefore can be consumed multiple times.
		 * Entities that are not {@link #isRepeatable repeatable} are expected
		 * to return the same {@link InputStream} instance and therefore
		 * may not be consumed more than once.
		 * 
		 * IMPORTANT: Please note all entity implementations must ensure that
		 * all allocated resources are properly deallocated after
		 * the {@link InputStream#close()} method is invoked.
		 *
		 * @return content stream of the entity.
		 *
		 * @throws IOException if the stream could not be created
		 * @throws UnsupportedOperationException
		 *  if entity content cannot be represented as {@link java.io.InputStream}.
		 *
		 * @see #isRepeatable()
		 */
		getContent(): Java.InputStream;
		/**
		 * Obtains the Content-Encoding header, if known.
		 * This is the header that should be used when sending the entity,
		 * or the one that was received with the entity.
		 * Wrapping entities that modify the content encoding should
		 * adjust this header accordingly.
		 *
		 * @return  the Content-Encoding header for this entity, or
		 *          {@code null} if the content encoding is unknown
		 */
		getContentEncoding(): Http.Header;
		/**
		 * Tells the length of the content, if known.
		 *
		 * @return  the number of bytes of the content, or
		 *          a negative number if unknown. If the content length is known
		 *          but exceeds {@link java.lang.Long#MAX_VALUE Long.MAX_VALUE},
		 *          a negative number is returned.
		 */
		getContentLength(): long;
		/**
		 * Obtains the Content-Type header, if known.
		 * This is the header that should be used when sending the entity,
		 * or the one that was received with the entity. It can include a
		 * charset attribute.
		 *
		 * @return  the Content-Type header for this entity, or
		 *          {@code null} if the content type is unknown
		 */
		getContentType(): Http.Header;
		/**
		 * Tells about chunked encoding for this entity.
		 * The primary purpose of this method is to indicate whether
		 * chunked encoding should be used when the entity is sent.
		 * For entities that are received, it can also indicate whether
		 * the entity was received with chunked encoding.
		 * 
		 * The behavior of wrapping entities is implementation dependent,
		 * but should respect the primary purpose.
		 * 
		 *
		 * @return  {@code true} if chunked encoding is preferred for this
		 *          entity, or {@code false} if it is not
		 */
		isChunked(): boolean;
		/**
		 * Tells if the entity is capable of producing its data more than once.
		 * A repeatable entity's getContent() and writeTo(OutputStream) methods
		 * can be called more than once whereas a non-repeatable entity's can not.
		 * @return true if the entity is repeatable, false otherwise.
		 */
		isRepeatable(): boolean;
		isStreaming(): boolean;
		/**
		 * Writes the entity content out to the output stream.
		 * 
		 * IMPORTANT: Please note all entity implementations must ensure that
		 * all allocated resources are properly deallocated when this method
		 * returns.
		 *
		 * @param outstream the output stream to write entity content to
		 *
		 * @throws IOException if an I/O error occurs
		 */
		writeTo(outstream: Java.OutputStream): void;
	}
	export module HttpEntity {
		/**
		 * Corresponding Java class: org.apache.http.HttpEntity
		 * An entity that can be sent or received with an HTTP message.
		 * Entities can be found in some
		 * {@link HttpEntityEnclosingRequest requests} and in
		 * {@link HttpResponse responses}, where they are optional.
		 * 
		 * There are three distinct types of entities in HttpCore,
		 * depending on where their {@link #getContent content} originates:
		 * 
		 * streamed: The content is received from a stream, or
		 *     generated on the fly. In particular, this category includes
		 *     entities being received from a {@link HttpConnection connection}.
		 *     {@link #isStreaming Streamed} entities are generally not
		 *      {@link #isRepeatable repeatable}.
		 *     
		 * self-contained: The content is in memory or obtained by
		 *     means that are independent from a connection or other entity.
		 *     Self-contained entities are generally {@link #isRepeatable repeatable}.
		 *     
		 * wrapping: The content is obtained from another entity.
		 *     
		 * 
		 * This distinction is important for connection management with incoming
		 * entities. For entities that are created by an application and only sent
		 * using the HTTP components framework, the difference between streamed
		 * and self-contained is of little importance. In that case, it is suggested
		 * to consider non-repeatable entities as streamed, and those that are
		 * repeatable (without a huge effort) as self-contained.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpEntityEnclosingRequest
	 * A request with an entity.
	 *
	 * @since 4.0
	 */
	export interface HttpEntityEnclosingRequest extends Http.HttpRequest {
		/**
		 * Tells if this request should use the expect-continue handshake.
		 * The expect continue handshake gives the server a chance to decide
		 * whether to accept the entity enclosing request before the possibly
		 * lengthy entity is sent across the wire.
		 * @return true if the expect continue handshake should be used, false if
		 * not.
		 */
		expectContinue(): boolean;
		/**
		 * Returns the entity associated with this request.
		 *
		 * @return entity
		 */
		getEntity(): Http.HttpEntity;
		/**
		 * Associates the entity with this request.
		 *
		 * @param entity the entity to send.
		 */
		setEntity(entity: Http.HttpEntity): void;
	}
	export module HttpEntityEnclosingRequest {
		/**
		 * Corresponding Java class: org.apache.http.HttpEntityEnclosingRequest
		 * A request with an entity.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpRequest.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpException
	 * Signals that an HTTP exception has occurred.
	 *
	 * @since 4.0
	 */
	export interface HttpException extends Java.Exception {
	}
	export module HttpException {
		/**
		 * Corresponding Java class: org.apache.http.HttpException
		 * Signals that an HTTP exception has occurred.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Exception.Static {
			/**
			 * Creates a new HttpException with a {@code null} detail message.
			 */
			new(): Http.HttpException;
			/**
			 * Creates a new HttpException with the specified detail message.
			 *
			 * @param message the exception detail message
			 */
			new(message: string): Http.HttpException;
			/**
			 * Creates a new HttpException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.HttpException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpHeaders
	 * Constants enumerating the HTTP headers. All headers defined in RFC1945 (HTTP/1.0), RFC2616 (HTTP/1.1), and RFC2518
	 * (WebDAV) are listed.
	 *
	 * @since 4.1
	 */
	export interface HttpHeaders extends Java.Object {
	}
	export module HttpHeaders {
		/**
		 * Corresponding Java class: org.apache.http.HttpHeaders
		 * Constants enumerating the HTTP headers. All headers defined in RFC1945 (HTTP/1.0), RFC2616 (HTTP/1.1), and RFC2518
		 * (WebDAV) are listed.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static {
			/**
			 RFC 2616 (HTTP/1.1) Section 14.1
			 */
			ACCEPT?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.2
			 */
			ACCEPT_CHARSET?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.3
			 */
			ACCEPT_ENCODING?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.4
			 */
			ACCEPT_LANGUAGE?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.5
			 */
			ACCEPT_RANGES?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.6
			 */
			AGE?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.1, RFC 2616 (HTTP/1.1) Section 14.7
			 */
			ALLOW?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.2, RFC 2616 (HTTP/1.1) Section 14.8
			 */
			AUTHORIZATION?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.9
			 */
			CACHE_CONTROL?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.10
			 */
			CONNECTION?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.3, RFC 2616 (HTTP/1.1) Section 14.11
			 */
			CONTENT_ENCODING?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.12
			 */
			CONTENT_LANGUAGE?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.4, RFC 2616 (HTTP/1.1) Section 14.13
			 */
			CONTENT_LENGTH?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.14
			 */
			CONTENT_LOCATION?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.15
			 */
			CONTENT_MD5?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.16
			 */
			CONTENT_RANGE?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.5, RFC 2616 (HTTP/1.1) Section 14.17
			 */
			CONTENT_TYPE?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.6, RFC 2616 (HTTP/1.1) Section 14.18
			 */
			DATE?: string;
			/**
			 RFC 2518 (WevDAV) Section 9.1
			 */
			DAV?: string;
			/**
			 RFC 2518 (WevDAV) Section 9.2
			 */
			DEPTH?: string;
			/**
			 RFC 2518 (WevDAV) Section 9.3
			 */
			DESTINATION?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.19
			 */
			ETAG?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.20
			 */
			EXPECT?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.7, RFC 2616 (HTTP/1.1) Section 14.21
			 */
			EXPIRES?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.8, RFC 2616 (HTTP/1.1) Section 14.22
			 */
			FROM?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.23
			 */
			HOST?: string;
			/**
			 RFC 2518 (WevDAV) Section 9.4
			 */
			IF?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.24
			 */
			IF_MATCH?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.9, RFC 2616 (HTTP/1.1) Section 14.25
			 */
			IF_MODIFIED_SINCE?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.26
			 */
			IF_NONE_MATCH?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.27
			 */
			IF_RANGE?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.28
			 */
			IF_UNMODIFIED_SINCE?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.10, RFC 2616 (HTTP/1.1) Section 14.29
			 */
			LAST_MODIFIED?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.11, RFC 2616 (HTTP/1.1) Section 14.30
			 */
			LOCATION?: string;
			/**
			 RFC 2518 (WevDAV) Section 9.5
			 */
			LOCK_TOKEN?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.31
			 */
			MAX_FORWARDS?: string;
			/**
			 RFC 2518 (WevDAV) Section 9.6
			 */
			OVERWRITE?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.12, RFC 2616 (HTTP/1.1) Section 14.32
			 */
			PRAGMA?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.33
			 */
			PROXY_AUTHENTICATE?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.34
			 */
			PROXY_AUTHORIZATION?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.35
			 */
			RANGE?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.13, RFC 2616 (HTTP/1.1) Section 14.36
			 */
			REFERER?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.37
			 */
			RETRY_AFTER?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.14, RFC 2616 (HTTP/1.1) Section 14.38
			 */
			SERVER?: string;
			/**
			 RFC 2518 (WevDAV) Section 9.7
			 */
			STATUS_URI?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.39
			 */
			TE?: string;
			/**
			 RFC 2518 (WevDAV) Section 9.8
			 */
			TIMEOUT?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.40
			 */
			TRAILER?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.41
			 */
			TRANSFER_ENCODING?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.42
			 */
			UPGRADE?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.15, RFC 2616 (HTTP/1.1) Section 14.43
			 */
			USER_AGENT?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.44
			 */
			VARY?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.45
			 */
			VIA?: string;
			/**
			 RFC 2616 (HTTP/1.1) Section 14.46
			 */
			WARNING?: string;
			/**
			 RFC 1945 (HTTP/1.0) Section 10.16, RFC 2616 (HTTP/1.1) Section 14.47
			 */
			WWW_AUTHENTICATE?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpHost
	 * Holds all of the variables needed to describe an HTTP connection to a host.
	 * This includes remote host name, port and scheme.
	 *
	 * @since 4.0
	 */
	export interface HttpHost extends Java.Object, Java.Cloneable, Java.Serializable {
		clone(): obj;
		equals(obj: obj): boolean;
		/**
		 * Returns the inet address if explicitly set by a constructor,
		 *   {@code null} otherwise.
		 * @return the inet address
		 *
		 * @since 4.3
		 */
		getAddress(): Java.InetAddress;
		/**
		 * Returns the host name.
		 *
		 * @return the host name (IP or DNS name)
		 */
		getHostName(): string;
		/**
		 * Returns the port.
		 *
		 * @return the host port, or {@code -1} if not set
		 */
		getPort(): int;
		/**
		 * Returns the scheme name.
		 *
		 * @return the scheme name
		 */
		getSchemeName(): string;
		/**
		 * @see java.lang.Object#hashCode()
		 */
		hashCode(): int;
		/**
		 * Obtains the host string, without scheme prefix.
		 *
		 * @return  the host string, for example {@code localhost:8080}
		 */
		toHostString(): string;
		toString(): string;
		/**
		 * Return the host URI, as a string.
		 *
		 * @return the host URI
		 */
		toURI(): string;
	}
	export module HttpHost {
		/**
		 * Corresponding Java class: org.apache.http.HttpHost
		 * Holds all of the variables needed to describe an HTTP connection to a host.
		 * This includes remote host name, port and scheme.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Java.Cloneable.Static, Java.Serializable.Static {
			/**
			 * Creates {@code HttpHost} instance with the given scheme, hostname and port.
			 *
			 * @param hostname  the hostname (IP or DNS name)
			 * @param port      the port number.
			 *                  {@code -1} indicates the scheme default port.
			 * @param scheme    the name of the scheme.
			 *                  {@code null} indicates the
			 *                  {@link #DEFAULT_SCHEME_NAME default scheme}
			 */
			new(hostname: string, port: int, scheme: string): Http.HttpHost;
			/**
			 * Creates {@code HttpHost} instance with the default scheme and the given hostname and port.
			 *
			 * @param hostname  the hostname (IP or DNS name)
			 * @param port      the port number.
			 *                  {@code -1} indicates the scheme default port.
			 */
			new(hostname: string, port: int): Http.HttpHost;
			/**
			 * Creates {@code HttpHost} instance with the default scheme and port and the given hostname.
			 *
			 * @param hostname  the hostname (IP or DNS name)
			 */
			new(hostname: string): Http.HttpHost;
			/**
			 * Creates {@code HttpHost} instance with the given scheme, inet address and port.
			 *
			 * @param address   the inet address.
			 * @param port      the port number.
			 *                  {@code -1} indicates the scheme default port.
			 * @param scheme    the name of the scheme.
			 *                  {@code null} indicates the
			 *                  {@link #DEFAULT_SCHEME_NAME default scheme}
			 *
			 * @since 4.3
			 */
			new(address: Java.InetAddress, port: int, scheme: string): Http.HttpHost;
			/**
			 * Creates a new {@link HttpHost HttpHost}, specifying all values.
			 * Constructor for HttpHost.
			 *
			 * @param address   the inet address.
			 * @param hostname   the hostname (IP or DNS name)
			 * @param port      the port number.
			 *                  {@code -1} indicates the scheme default port.
			 * @param scheme    the name of the scheme.
			 *                  {@code null} indicates the
			 *                  {@link #DEFAULT_SCHEME_NAME default scheme}
			 *
			 * @since 4.4
			 */
			new(address: Java.InetAddress, hostname: string, port: int, scheme: string): Http.HttpHost;
			/**
			 * Creates {@code HttpHost} instance with the default scheme and the given inet address
			 * and port.
			 *
			 * @param address   the inet address.
			 * @param port      the port number.
			 *                  {@code -1} indicates the scheme default port.
			 *
			 * @since 4.3
			 */
			new(address: Java.InetAddress, port: int): Http.HttpHost;
			/**
			 * Creates {@code HttpHost} instance with the default scheme and port and the given inet
			 * address.
			 *
			 * @param address   the inet address.
			 *
			 * @since 4.3
			 */
			new(address: Java.InetAddress): Http.HttpHost;
			/**
			 * Copy constructor for {@link HttpHost HttpHost}.
			 *
			 * @param httphost the HTTP host to copy details from
			 */
			new(httphost: Http.HttpHost): Http.HttpHost;
			/**
			 The default scheme is "http".
			 */
			DEFAULT_SCHEME_NAME?: string;
			/**
			 * Creates {@code HttpHost} instance from string. Text may not contain any blanks.
			 *
			 * @since 4.4
			 */
			create(s: string): Http.HttpHost;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpInetConnection
	 * An HTTP connection over the Internet Protocol (IP).
	 *
	 * @since 4.0
	 */
	export interface HttpInetConnection extends Http.HttpConnection {
		getLocalAddress(): Java.InetAddress;
		getLocalPort(): int;
		getRemoteAddress(): Java.InetAddress;
		getRemotePort(): int;
	}
	export module HttpInetConnection {
		/**
		 * Corresponding Java class: org.apache.http.HttpInetConnection
		 * An HTTP connection over the Internet Protocol (IP).
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpConnection.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpMessage
	 * HTTP messages consist of requests from client to server and responses
	 * from server to client.
	 * 
	 *     HTTP-message   = Request | Response     ; HTTP/1.1 messages
	 * 
	 * 
	 * HTTP messages use the generic message format of RFC 822 for
	 * transferring entities (the payload of the message). Both types
	 * of message consist of a start-line, zero or more header fields
	 * (also known as "headers"), an empty line (i.e., a line with nothing
	 * preceding the CRLF) indicating the end of the header fields,
	 * and possibly a message-body.
	 * 
	 * 
	 *      generic-message = start-line
	 *                        *(message-header CRLF)
	 *                        CRLF
	 *                        [ message-body ]
	 *      start-line      = Request-Line | Status-Line
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpMessage extends Java.Object {
		/**
		 * Adds a header to this message. The header will be appended to the end of
		 * the list.
		 *
		 * @param header the header to append.
		 */
		addHeader(header: Http.Header): void;
		/**
		 * Adds a header to this message. The header will be appended to the end of
		 * the list.
		 *
		 * @param name the name of the header.
		 * @param value the value of the header.
		 */
		addHeader(name: string, value: string): void;
		/**
		 * Checks if a certain header is present in this message. Header values are
		 * ignored.
		 *
		 * @param name the header name to check for.
		 * @return true if at least one header with this name is present.
		 */
		containsHeader(name: string): boolean;
		/**
		 * Returns all the headers of this message. Headers are orderd in the sequence
		 * they will be sent over a connection.
		 *
		 * @return all the headers of this message
		 */
		getAllHeaders(): array<Http.Header>;
		/**
		 * Returns the first header with a specified name of this message. Header
		 * values are ignored. If there is more than one matching header in the
		 * message the first element of {@link #getHeaders(String)} is returned.
		 * If there is no matching header in the message {@code null} is
		 * returned.
		 *
		 * @param name the name of the header to return.
		 * @return the first header whose name property equals {@code name}
		 *   or {@code null} if no such header could be found.
		 */
		getFirstHeader(name: string): Http.Header;
		/**
		 * Returns all the headers with a specified name of this message. Header values
		 * are ignored. Headers are orderd in the sequence they will be sent over a
		 * connection.
		 *
		 * @param name the name of the headers to return.
		 * @return the headers whose name property equals {@code name}.
		 */
		getHeaders(name: string): array<Http.Header>;
		/**
		 * Returns the last header with a specified name of this message. Header values
		 * are ignored. If there is more than one matching header in the message the
		 * last element of {@link #getHeaders(String)} is returned. If there is no
		 * matching header in the message {@code null} is returned.
		 *
		 * @param name the name of the header to return.
		 * @return the last header whose name property equals {@code name}.
		 *   or {@code null} if no such header could be found.
		 */
		getLastHeader(name: string): Http.Header;
		/**
		 * Returns the protocol version this message is compatible with.
		 */
		getProtocolVersion(): Http.ProtocolVersion;
		/**
		 * Returns an iterator of all the headers.
		 *
		 * @return Iterator that returns Header objects in the sequence they are
		 *         sent over a connection.
		 */
		headerIterator(): Http.HeaderIterator;
		/**
		 * Returns an iterator of the headers with a given name.
		 *
		 * @param name      the name of the headers over which to iterate, or
		 *                  {@code null} for all headers
		 *
		 * @return Iterator that returns Header objects with the argument name
		 *         in the sequence they are sent over a connection.
		 */
		headerIterator(name: string): Http.HeaderIterator;
		/**
		 * Removes a header from this message.
		 *
		 * @param header the header to remove.
		 */
		removeHeader(header: Http.Header): void;
		/**
		 * Removes all headers with a certain name from this message.
		 *
		 * @param name The name of the headers to remove.
		 */
		removeHeaders(name: string): void;
		/**
		 * Overwrites the first header with the same name. The new header will be appended to
		 * the end of the list, if no header with the given name can be found.
		 *
		 * @param header the header to set.
		 */
		setHeader(header: Http.Header): void;
		/**
		 * Overwrites the first header with the same name. The new header will be appended to
		 * the end of the list, if no header with the given name can be found.
		 *
		 * @param name the name of the header.
		 * @param value the value of the header.
		 */
		setHeader(name: string, value: string): void;
		/**
		 * Overwrites all the headers in the message.
		 *
		 * @param headers the array of headers to set.
		 */
		setHeaders(headers: array<Http.Header>): void;
	}
	export module HttpMessage {
		/**
		 * Corresponding Java class: org.apache.http.HttpMessage
		 * HTTP messages consist of requests from client to server and responses
		 * from server to client.
		 * 
		 *     HTTP-message   = Request | Response     ; HTTP/1.1 messages
		 * 
		 * 
		 * HTTP messages use the generic message format of RFC 822 for
		 * transferring entities (the payload of the message). Both types
		 * of message consist of a start-line, zero or more header fields
		 * (also known as "headers"), an empty line (i.e., a line with nothing
		 * preceding the CRLF) indicating the end of the header fields,
		 * and possibly a message-body.
		 * 
		 * 
		 *      generic-message = start-line
		 *                        *(message-header CRLF)
		 *                        CRLF
		 *                        [ message-body ]
		 *      start-line      = Request-Line | Status-Line
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpRequest
	 * A request message from a client to a server includes, within the
	 * first line of that message, the method to be applied to the resource,
	 * the identifier of the resource, and the protocol version in use.
	 * 
	 *      Request       = Request-Line
	 *                      *(( general-header
	 *                       | request-header
	 *                       | entity-header ) CRLF)
	 *                      CRLF
	 *                      [ message-body ]
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpRequest extends Http.HttpMessage {
		/**
		 * Returns the request line of this request.
		 * @return the request line.
		 */
		getRequestLine(): Http.RequestLine;
	}
	export module HttpRequest {
		/**
		 * Corresponding Java class: org.apache.http.HttpRequest
		 * A request message from a client to a server includes, within the
		 * first line of that message, the method to be applied to the resource,
		 * the identifier of the resource, and the protocol version in use.
		 * 
		 *      Request       = Request-Line
		 *                      *(( general-header
		 *                       | request-header
		 *                       | entity-header ) CRLF)
		 *                      CRLF
		 *                      [ message-body ]
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpMessage.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpRequestFactory
	 * A factory for {@link HttpRequest HttpRequest} objects.
	 *
	 * @since 4.0
	 */
	export interface HttpRequestFactory extends Java.Object {
		newHttpRequest(requestline: Http.RequestLine): Http.HttpRequest;
		newHttpRequest(method: string, uri: string): Http.HttpRequest;
	}
	export module HttpRequestFactory {
		/**
		 * Corresponding Java class: org.apache.http.HttpRequestFactory
		 * A factory for {@link HttpRequest HttpRequest} objects.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpRequestInterceptor
	 * HTTP protocol interceptor is a routine that implements a specific aspect of
	 * the HTTP protocol. Usually protocol interceptors are expected to act upon
	 * one specific header or a group of related headers of the incoming message
	 * or populate the outgoing message with one specific header or a group of
	 * related headers.
	 * 
	 *  Protocol Interceptors can also manipulate content entities enclosed with messages.
	 * Usually this is accomplished by using the 'Decorator' pattern where a wrapper
	 * entity class is used to decorate the original entity.
	 * 
	 * Protocol interceptors must be implemented as thread-safe. Similarly to
	 * servlets, protocol interceptors should not use instance variables unless
	 * access to those variables is synchronized.
	 *
	 * @since 4.0
	 */
	export interface HttpRequestInterceptor extends Java.Object {
		/**
		 * Processes a request.
		 * On the client side, this step is performed before the request is
		 * sent to the server. On the server side, this step is performed
		 * on incoming messages before the message body is evaluated.
		 *
		 * @param request   the request to preprocess
		 * @param context   the context for the request
		 *
		 * @throws HttpException in case of an HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module HttpRequestInterceptor {
		/**
		 * Corresponding Java class: org.apache.http.HttpRequestInterceptor
		 * HTTP protocol interceptor is a routine that implements a specific aspect of
		 * the HTTP protocol. Usually protocol interceptors are expected to act upon
		 * one specific header or a group of related headers of the incoming message
		 * or populate the outgoing message with one specific header or a group of
		 * related headers.
		 * 
		 *  Protocol Interceptors can also manipulate content entities enclosed with messages.
		 * Usually this is accomplished by using the 'Decorator' pattern where a wrapper
		 * entity class is used to decorate the original entity.
		 * 
		 * Protocol interceptors must be implemented as thread-safe. Similarly to
		 * servlets, protocol interceptors should not use instance variables unless
		 * access to those variables is synchronized.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpResponse
	 * After receiving and interpreting a request message, a server responds
	 * with an HTTP response message.
	 * 
	 *     Response      = Status-Line
	 *                     *(( general-header
	 *                      | response-header
	 *                      | entity-header ) CRLF)
	 *                     CRLF
	 *                     [ message-body ]
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpResponse extends Http.HttpMessage {
		/**
		 * Obtains the message entity of this response, if any.
		 * The entity is provided by calling {@link #setEntity setEntity}.
		 *
		 * @return  the response entity, or
		 *          {@code null} if there is none
		 */
		getEntity(): Http.HttpEntity;
		/**
		 * Obtains the locale of this response.
		 * The locale is used to determine the reason phrase
		 * for the {@link #setStatusCode status code}.
		 * It can be changed using {@link #setLocale setLocale}.
		 *
		 * @return  the locale of this response, never {@code null}
		 */
		getLocale(): Java.Locale;
		/**
		 * Obtains the status line of this response.
		 * The status line can be set using one of the
		 * {@link #setStatusLine setStatusLine} methods,
		 * or it can be initialized in a constructor.
		 *
		 * @return  the status line, or {@code null} if not yet set
		 */
		getStatusLine(): Http.StatusLine;
		/**
		 * Associates a response entity with this response.
		 * 
		 * Please note that if an entity has already been set for this response and it depends on
		 * an input stream ({@link HttpEntity#isStreaming()} returns {@code true}),
		 * it must be fully consumed in order to ensure release of resources.
		 *
		 * @param entity    the entity to associate with this response, or
		 *                  {@code null} to unset
		 *
		 * @see HttpEntity#isStreaming()
		 * @see org.apache.http.util.EntityUtils#updateEntity(HttpResponse, HttpEntity)
		 */
		setEntity(entity: Http.HttpEntity): void;
		/**
		 * Changes the locale of this response.
		 *
		 * @param loc       the new locale
		 */
		setLocale(loc: Java.Locale): void;
		/**
		 * Updates the status line of this response with a new reason phrase.
		 *
		 * @param reason    the new reason phrase as a single-line string, or
		 *                  {@code null} to unset the reason phrase
		 *
		 * @throws IllegalStateException
		 *          if the status line has not be set
		 *
		 * @see #setStatusLine(StatusLine)
		 * @see #setStatusLine(ProtocolVersion,int)
		 */
		setReasonPhrase(reason: string): void;
		/**
		 * Updates the status line of this response with a new status code.
		 *
		 * @param code the HTTP status code.
		 *
		 * @throws IllegalStateException
		 *          if the status line has not be set
		 *
		 * @see HttpStatus
		 * @see #setStatusLine(StatusLine)
		 * @see #setStatusLine(ProtocolVersion,int)
		 */
		setStatusCode(code: int): void;
		/**
		 * Sets the status line of this response.
		 *
		 * @param statusline the status line of this response
		 */
		setStatusLine(statusline: Http.StatusLine): void;
		/**
		 * Sets the status line of this response.
		 * The reason phrase will be determined based on the current
		 * {@link #getLocale locale}.
		 *
		 * @param ver       the HTTP version
		 * @param code      the status code
		 */
		setStatusLine(ver: Http.ProtocolVersion, code: int): void;
		/**
		 * Sets the status line of this response with a reason phrase.
		 *
		 * @param ver       the HTTP version
		 * @param code      the status code
		 * @param reason    the reason phrase, or {@code null} to omit
		 */
		setStatusLine(ver: Http.ProtocolVersion, code: int, reason: string): void;
	}
	export module HttpResponse {
		/**
		 * Corresponding Java class: org.apache.http.HttpResponse
		 * After receiving and interpreting a request message, a server responds
		 * with an HTTP response message.
		 * 
		 *     Response      = Status-Line
		 *                     *(( general-header
		 *                      | response-header
		 *                      | entity-header ) CRLF)
		 *                     CRLF
		 *                     [ message-body ]
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpMessage.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpResponseFactory
	 * A factory for {@link HttpResponse HttpResponse} objects.
	 *
	 * @since 4.0
	 */
	export interface HttpResponseFactory extends Java.Object {
		/**
		 * Creates a new response from status line elements.
		 *
		 * @param ver       the protocol version
		 * @param status    the status code
		 * @param context   the context from which to determine the locale
		 *                  for looking up a reason phrase to the status code, or
		 *                  {@code null} to use the default locale
		 *
		 * @return  the new response with an initialized status line
		 */
		newHttpResponse(ver: Http.ProtocolVersion, status: int, context: Http.HttpContext): Http.HttpResponse;
		/**
		 * Creates a new response from a status line.
		 *
		 * @param statusline the status line
		 * @param context    the context from which to determine the locale
		 *                   for looking up a reason phrase if the status code
		 *                   is updated, or
		 *                   {@code null} to use the default locale
		 *
		 * @return  the new response with the argument status line
		 */
		newHttpResponse(statusline: Http.StatusLine, context: Http.HttpContext): Http.HttpResponse;
	}
	export module HttpResponseFactory {
		/**
		 * Corresponding Java class: org.apache.http.HttpResponseFactory
		 * A factory for {@link HttpResponse HttpResponse} objects.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpResponseInterceptor
	 * HTTP protocol interceptor is a routine that implements a specific aspect of
	 * the HTTP protocol. Usually protocol interceptors are expected to act upon
	 * one specific header or a group of related headers of the incoming message
	 * or populate the outgoing message with one specific header or a group of
	 * related headers. Protocol
	 * 
	 * Interceptors can also manipulate content entities enclosed with messages.
	 * Usually this is accomplished by using the 'Decorator' pattern where a wrapper
	 * entity class is used to decorate the original entity.
	 * 
	 * Protocol interceptors must be implemented as thread-safe. Similarly to
	 * servlets, protocol interceptors should not use instance variables unless
	 * access to those variables is synchronized.
	 *
	 * @since 4.0
	 */
	export interface HttpResponseInterceptor extends Java.Object {
		/**
		 * Processes a response.
		 * On the server side, this step is performed before the response is
		 * sent to the client. On the client side, this step is performed
		 * on incoming messages before the message body is evaluated.
		 *
		 * @param response  the response to postprocess
		 * @param context   the context for the request
		 *
		 * @throws HttpException in case of an HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		process(response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module HttpResponseInterceptor {
		/**
		 * Corresponding Java class: org.apache.http.HttpResponseInterceptor
		 * HTTP protocol interceptor is a routine that implements a specific aspect of
		 * the HTTP protocol. Usually protocol interceptors are expected to act upon
		 * one specific header or a group of related headers of the incoming message
		 * or populate the outgoing message with one specific header or a group of
		 * related headers. Protocol
		 * 
		 * Interceptors can also manipulate content entities enclosed with messages.
		 * Usually this is accomplished by using the 'Decorator' pattern where a wrapper
		 * entity class is used to decorate the original entity.
		 * 
		 * Protocol interceptors must be implemented as thread-safe. Similarly to
		 * servlets, protocol interceptors should not use instance variables unless
		 * access to those variables is synchronized.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.AbstractHttpClientConnection
	 * Abstract client-side HTTP connection capable of transmitting and receiving
	 * data using arbitrary {@link SessionInputBuffer} and
	 * {@link SessionOutputBuffer} implementations.
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link DefaultBHttpClientConnection}
	 */
	export interface AbstractHttpClientConnection extends Java.Object, Http.HttpClientConnection {
	}
	export module AbstractHttpClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.AbstractHttpClientConnection
		 * Abstract client-side HTTP connection capable of transmitting and receiving
		 * data using arbitrary {@link SessionInputBuffer} and
		 * {@link SessionOutputBuffer} implementations.
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link DefaultBHttpClientConnection}
		 */
		export interface Static extends Java.Object.Static, Http.HttpClientConnection.Static {
			new(): Http.AbstractHttpClientConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.BHttpConnectionBase
	 * This class serves as a base for all {@link HttpConnection} implementations and provides
	 * functionality common to both client and server HTTP connections.
	 *
	 * @since 4.0
	 */
	export interface BHttpConnectionBase extends Java.Object, Http.HttpConnection, Http.HttpInetConnection {
		close(): void;
		getLocalAddress(): Java.InetAddress;
		getLocalPort(): int;
		getMetrics(): Http.HttpConnectionMetrics;
		getRemoteAddress(): Java.InetAddress;
		getRemotePort(): int;
		getSocketTimeout(): int;
		isOpen(): boolean;
		isStale(): boolean;
		setSocketTimeout(timeout: int): void;
		shutdown(): void;
		toString(): string;
	}
	export module BHttpConnectionBase {
		/**
		 * Corresponding Java class: org.apache.http.impl.BHttpConnectionBase
		 * This class serves as a base for all {@link HttpConnection} implementations and provides
		 * functionality common to both client and server HTTP connections.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpConnection.Static, Http.HttpInetConnection.Static {
			new(): Http.BHttpConnectionBase;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.auth.params.AuthParamBean
	 * This is a Java Bean class that can be used to wrap an instance of
	 * {@link HttpParams} and manipulate HTTP authentication parameters
	 * using Java Beans conventions.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}
	 *   and constructor parameters of
	 *   {@link org.apache.http.auth.AuthSchemeProvider}s.
	 */
	export interface AuthParamBean extends Http.HttpAbstractParamBean {
	}
	export module AuthParamBean {
		/**
		 * Corresponding Java class: org.apache.http.auth.params.AuthParamBean
		 * This is a Java Bean class that can be used to wrap an instance of
		 * {@link HttpParams} and manipulate HTTP authentication parameters
		 * using Java Beans conventions.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.client.config.RequestConfig}
		 *   and constructor parameters of
		 *   {@link org.apache.http.auth.AuthSchemeProvider}s.
		 */
		export interface Static extends Http.HttpAbstractParamBean.Static {
			new(): Http.AuthParamBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.bootstrap.RequestListener
	 * @since 4.4
	 */
	export interface RequestListener extends Java.Object, Java.Runnable {
		isTerminated(): boolean;
		run(): void;
		terminate(): void;
	}
	export module RequestListener {
		/**
		 * Corresponding Java class: org.apache.http.impl.bootstrap.RequestListener
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Java.Runnable.Static {
			new(socketConfig: Http.SocketConfig, serversocket: Java.ServerSocket, httpService: Http.HttpService, connectionFactory: Http.HttpConnectionFactory<Http.HttpServerConnection>, exceptionLogger: Http.ExceptionLogger, executorService: Java.ExecutorService): Http.RequestListener;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.bootstrap.SSLServerSetupHandler
	 * Server SSL setup handler. Custom implementations of this interface can be used to
	 * configure various SSL protocol aspects such as supported protocol versions, cypher suites,
	 * and mandatory / optional client authentication.
	 *
	 * @see javax.net.ssl.SSLServerSocket
	 * @see javax.net.ssl.SSLSession
	 * @since 4.4
	 */
	export interface SSLServerSetupHandler extends Java.Object {
		initialize(socket: Java.SSLServerSocket): void;
	}
	export module SSLServerSetupHandler {
		/**
		 * Corresponding Java class: org.apache.http.impl.bootstrap.SSLServerSetupHandler
		 * Server SSL setup handler. Custom implementations of this interface can be used to
		 * configure various SSL protocol aspects such as supported protocol versions, cypher suites,
		 * and mandatory / optional client authentication.
		 *
		 * @see javax.net.ssl.SSLServerSocket
		 * @see javax.net.ssl.SSLSession
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.AbstractSessionOutputBuffer
	 * Abstract base class for session output buffers that stream data to
	 * an arbitrary {@link OutputStream}. This class buffers small chunks of
	 * output data in an internal byte array for optimal output performance.
	 * 
	 * {@link #writeLine(CharArrayBuffer)} and {@link #writeLine(String)} methods
	 * of this class use CR-LF as a line delimiter.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link SessionOutputBufferImpl}
	 */
	export interface AbstractSessionOutputBuffer extends Java.Object, Http.SessionOutputBuffer, Http.BufferInfo {
	}
	export module AbstractSessionOutputBuffer {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.AbstractSessionOutputBuffer
		 * Abstract base class for session output buffers that stream data to
		 * an arbitrary {@link OutputStream}. This class buffers small chunks of
		 * output data in an internal byte array for optimal output performance.
		 * 
		 * {@link #writeLine(CharArrayBuffer)} and {@link #writeLine(String)} methods
		 * of this class use CR-LF as a line delimiter.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link SessionOutputBufferImpl}
		 */
		export interface Static extends Java.Object.Static, Http.SessionOutputBuffer.Static, Http.BufferInfo.Static {
			new(): Http.AbstractSessionOutputBuffer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.ChunkedOutputStream
	 * Implements chunked transfer coding. The content is sent in small chunks.
	 * Entities transferred using this output stream can be of unlimited length.
	 * Writes are buffered to an internal buffer (2048 default size).
	 * 
	 * Note that this class NEVER closes the underlying stream, even when close
	 * gets called.  Instead, the stream will be marked as closed and no further
	 * output will be permitted.
	 *
	 *
	 * @since 4.0
	 */
	export interface ChunkedOutputStream extends Java.OutputStream {
		/**
		 * Finishes writing to the underlying stream, but does NOT close the underlying stream.
		 */
		close(): void;
		/**
		 * Must be called to ensure the internal cache is flushed and the closing
		 * chunk is written.
		 * @throws IOException in case of an I/O error
		 */
		finish(): void;
		/**
		 * Flushes the content buffer and the underlying stream.
		 */
		flush(): void;
		write(b: int): void;
		/**
		 * Writes the array. If the array does not fit within the buffer, it is
		 * not split, but rather written out as one large chunk.
		 */
		write(b: array<byte>): void;
		/**
		 * Writes the array. If the array does not fit within the buffer, it is
		 * not split, but rather written out as one large chunk.
		 */
		write(src: array<byte>, off: int, len: int): void;
	}
	export module ChunkedOutputStream {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.ChunkedOutputStream
		 * Implements chunked transfer coding. The content is sent in small chunks.
		 * Entities transferred using this output stream can be of unlimited length.
		 * Writes are buffered to an internal buffer (2048 default size).
		 * 
		 * Note that this class NEVER closes the underlying stream, even when close
		 * gets called.  Instead, the stream will be marked as closed and no further
		 * output will be permitted.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.OutputStream.Static {
			/**
			 * Wraps a session output buffer and chunk-encodes the output.
			 *
			 * @param bufferSize The minimum chunk size (excluding last chunk)
			 * @param out The session output buffer
			 */
			new(bufferSize: int, out: Http.SessionOutputBuffer): Http.ChunkedOutputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.ChunkedInputStream
	 * Implements chunked transfer coding. The content is received in small chunks.
	 * Entities transferred using this input stream can be of unlimited length.
	 * After the stream is read to the end, it provides access to the trailers,
	 * if any.
	 * 
	 * Note that this class NEVER closes the underlying stream, even when close
	 * gets called.  Instead, it will read until the "end" of its chunking on
	 * close, which allows for the seamless execution of subsequent HTTP 1.1
	 * requests, while not requiring the client to remember to read the entire
	 * contents of the response.
	 *
	 *
	 * @since 4.0
	 *
	 */
	export interface ChunkedInputStream extends Java.InputStream {
		available(): int;
		/**
		 * Upon close, this reads the remainder of the chunked message,
		 * leaving the underlying socket at a position to start reading the
		 * next response without scanning.
		 * @throws IOException in case of an I/O error
		 */
		close(): void;
		getFooters(): array<Http.Header>;
		/**
		 *  Returns all the data in a chunked stream in coalesced form. A chunk
		 * is followed by a CRLF. The method returns -1 as soon as a chunksize of 0
		 * is detected.
		 *
		 *  Trailer headers are read automatically at the end of the stream and
		 * can be obtained with the getResponseFooters() method.
		 *
		 * @return -1 of the end of the stream has been reached or the next data
		 * byte
		 * @throws IOException in case of an I/O error
		 */
		read(): int;
		/**
		 * Read some bytes from the stream.
		 * @param b The byte array that will hold the contents from the stream.
		 * @param off The offset into the byte array at which bytes will start to be
		 * placed.
		 * @param len the maximum number of bytes that can be returned.
		 * @return The number of bytes returned or -1 if the end of stream has been
		 * reached.
		 * @throws IOException in case of an I/O error
		 */
		read(b: array<byte>, off: int, len: int): int;
		/**
		 * Read some bytes from the stream.
		 * @param b The byte array that will hold the contents from the stream.
		 * @return The number of bytes returned or -1 if the end of stream has been
		 * reached.
		 * @throws IOException in case of an I/O error
		 */
		read(b: array<byte>): int;
	}
	export module ChunkedInputStream {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.ChunkedInputStream
		 * Implements chunked transfer coding. The content is received in small chunks.
		 * Entities transferred using this input stream can be of unlimited length.
		 * After the stream is read to the end, it provides access to the trailers,
		 * if any.
		 * 
		 * Note that this class NEVER closes the underlying stream, even when close
		 * gets called.  Instead, it will read until the "end" of its chunking on
		 * close, which allows for the seamless execution of subsequent HTTP 1.1
		 * requests, while not requiring the client to remember to read the entire
		 * contents of the response.
		 *
		 *
		 * @since 4.0
		 *
		 */
		export interface Static extends Java.InputStream.Static {
			/**
			 * Wraps session input stream and reads chunk coded input.
			 *
			 * @param in The session input buffer
			 * @param constraints Message constraints. If {@code null}
			 *   {@link MessageConstraints#DEFAULT} will be used.
			 *
			 * @since 4.4
			 */
			new(in_: Http.SessionInputBuffer, constraints: Http.MessageConstraints): Http.ChunkedInputStream;
			/**
			 * Wraps session input stream and reads chunk coded input.
			 *
			 * @param in The session input buffer
			 */
			new(in_: Http.SessionInputBuffer): Http.ChunkedInputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.ContentLengthOutputStream
	 * Output stream that cuts off after a defined number of bytes. This class
	 * is used to send content of HTTP messages where the end of the content entity
	 * is determined by the value of the {@code Content-Length header}.
	 * Entities transferred using this stream can be maximum {@link Long#MAX_VALUE}
	 * long.
	 * 
	 * Note that this class NEVER closes the underlying stream, even when close
	 * gets called.  Instead, the stream will be marked as closed and no further
	 * output will be permitted.
	 *
	 * @since 4.0
	 */
	export interface ContentLengthOutputStream extends Java.OutputStream {
		/**
		 * Does not close the underlying socket output.
		 *
		 * @throws IOException If an I/O problem occurs.
		 */
		close(): void;
		flush(): void;
		write(b: array<byte>, off: int, len: int): void;
		write(b: array<byte>): void;
		write(b: int): void;
	}
	export module ContentLengthOutputStream {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.ContentLengthOutputStream
		 * Output stream that cuts off after a defined number of bytes. This class
		 * is used to send content of HTTP messages where the end of the content entity
		 * is determined by the value of the {@code Content-Length header}.
		 * Entities transferred using this stream can be maximum {@link Long#MAX_VALUE}
		 * long.
		 * 
		 * Note that this class NEVER closes the underlying stream, even when close
		 * gets called.  Instead, the stream will be marked as closed and no further
		 * output will be permitted.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.OutputStream.Static {
			/**
			 * Wraps a session output buffer and cuts off output after a defined number
			 * of bytes.
			 *
			 * @param out The session output buffer
			 * @param contentLength The maximum number of bytes that can be written to
			 * the stream. Subsequent write operations will be ignored.
			 *
			 * @since 4.0
			 */
			new(out: Http.SessionOutputBuffer, contentLength: long): Http.ContentLengthOutputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpRequestParser
	 * HTTP request parser that obtain its input from an instance
	 * of {@link SessionInputBuffer}.
	 *
	 * @since 4.2
	 */
	export interface DefaultHttpRequestParser extends Http.AbstractMessageParser<Http.HttpRequest> {
	}
	export module DefaultHttpRequestParser {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpRequestParser
		 * HTTP request parser that obtain its input from an instance
		 * of {@link SessionInputBuffer}.
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.AbstractMessageParser.Static {
			/**
			 * Creates new instance of DefaultHttpRequestParser.
			 *
			 * @param buffer the session input buffer.
			 * @param lineParser the line parser. If {@code null}
			 *   {@link org.apache.http.message.BasicLineParser#INSTANCE} will be used.
			 * @param requestFactory the response factory. If {@code null}
			 *   {@link DefaultHttpRequestFactory#INSTANCE} will be used.
			 * @param constraints the message constraints. If {@code null}
			 *   {@link MessageConstraints#DEFAULT} will be used.
			 *
			 * @since 4.3
			 */
			new(buffer: Http.SessionInputBuffer, lineParser: Http.LineParser, requestFactory: Http.HttpRequestFactory, constraints: Http.MessageConstraints): Http.DefaultHttpRequestParser;
			/**
			 * @since 4.3
			 */
			new(buffer: Http.SessionInputBuffer, constraints: Http.MessageConstraints): Http.DefaultHttpRequestParser;
			/**
			 * @since 4.3
			 */
			new(buffer: Http.SessionInputBuffer): Http.DefaultHttpRequestParser;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpRequestParserFactory
	 * Default factory for request message parsers.
	 *
	 * @since 4.3
	 */
	export interface DefaultHttpRequestParserFactory extends Java.Object, Http.HttpMessageParserFactory<Http.HttpRequest> {
		create(buffer: Http.SessionInputBuffer, constraints: Http.MessageConstraints): Http.HttpMessageParser<Http.HttpRequest>;
	}
	export module DefaultHttpRequestParserFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpRequestParserFactory
		 * Default factory for request message parsers.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpMessageParserFactory.Static {
			new(lineParser: Http.LineParser, requestFactory: Http.HttpRequestFactory): Http.DefaultHttpRequestParserFactory;
			new(): Http.DefaultHttpRequestParserFactory;
			INSTANCE?: Http.DefaultHttpRequestParserFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.ContentLengthInputStream
	 * Input stream that cuts off after a defined number of bytes. This class
	 * is used to receive content of HTTP messages where the end of the content
	 * entity is determined by the value of the {@code Content-Length header}.
	 * Entities transferred using this stream can be maximum {@link Long#MAX_VALUE}
	 * long.
	 * 
	 * Note that this class NEVER closes the underlying stream, even when close
	 * gets called.  Instead, it will read until the "end" of its limit on
	 * close, which allows for the seamless execution of subsequent HTTP 1.1
	 * requests, while not requiring the client to remember to read the entire
	 * contents of the response.
	 *
	 *
	 * @since 4.0
	 */
	export interface ContentLengthInputStream extends Java.InputStream {
		available(): int;
		/**
		 * Reads until the end of the known length of content.
		 *
		 * Does not close the underlying socket input, but instead leaves it
		 * primed to parse the next response.
		 * @throws IOException If an IO problem occurs.
		 */
		close(): void;
		/**
		 * Read the next byte from the stream
		 * @return The next byte or -1 if the end of stream has been reached.
		 * @throws IOException If an IO problem occurs
		 * @see java.io.InputStream#read()
		 */
		read(): int;
		/**
		 * Does standard {@link InputStream#read(byte[], int, int)} behavior, but
		 * also notifies the watcher when the contents have been consumed.
		 *
		 * @param b     The byte array to fill.
		 * @param off   Start filling at this position.
		 * @param len   The number of bytes to attempt to read.
		 * @return The number of bytes read, or -1 if the end of content has been
		 *  reached.
		 *
		 * @throws java.io.IOException Should an error occur on the wrapped stream.
		 */
		read(b: array<byte>, off: int, len: int): int;
		/**
		 * Read more bytes from the stream.
		 * @param b The byte array to put the new data in.
		 * @return The number of bytes read into the buffer.
		 * @throws IOException If an IO problem occurs
		 * @see java.io.InputStream#read(byte[])
		 */
		read(b: array<byte>): int;
		/**
		 * Skips and discards a number of bytes from the input stream.
		 * @param n The number of bytes to skip.
		 * @return The actual number of bytes skipped. &le; 0 if no bytes
		 * are skipped.
		 * @throws IOException If an error occurs while skipping bytes.
		 * @see InputStream#skip(long)
		 */
		skip(n: long): long;
	}
	export module ContentLengthInputStream {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.ContentLengthInputStream
		 * Input stream that cuts off after a defined number of bytes. This class
		 * is used to receive content of HTTP messages where the end of the content
		 * entity is determined by the value of the {@code Content-Length header}.
		 * Entities transferred using this stream can be maximum {@link Long#MAX_VALUE}
		 * long.
		 * 
		 * Note that this class NEVER closes the underlying stream, even when close
		 * gets called.  Instead, it will read until the "end" of its limit on
		 * close, which allows for the seamless execution of subsequent HTTP 1.1
		 * requests, while not requiring the client to remember to read the entire
		 * contents of the response.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.InputStream.Static {
			/**
			 * Wraps a session input buffer and cuts off output after a defined number
			 * of bytes.
			 *
			 * @param in The session input buffer
			 * @param contentLength The maximum number of bytes that can be read from
			 * the stream. Subsequent read operations will return -1.
			 */
			new(in_: Http.SessionInputBuffer, contentLength: long): Http.ContentLengthInputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpRequestWriter
	 * HTTP request writer that serializes its output to an instance of {@link SessionOutputBuffer}.
	 *
	 * @since 4.3
	 */
	export interface DefaultHttpRequestWriter extends Http.AbstractMessageWriter<Http.HttpRequest> {
	}
	export module DefaultHttpRequestWriter {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpRequestWriter
		 * HTTP request writer that serializes its output to an instance of {@link SessionOutputBuffer}.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.AbstractMessageWriter.Static {
			/**
			 * Creates an instance of DefaultHttpRequestWriter.
			 *
			 * @param buffer the session output buffer.
			 * @param formatter the line formatter If {@code null}
			 *   {@link org.apache.http.message.BasicLineFormatter#INSTANCE}
			 *   will be used.
			 */
			new(buffer: Http.SessionOutputBuffer, formatter: Http.LineFormatter): Http.DefaultHttpRequestWriter;
			new(buffer: Http.SessionOutputBuffer): Http.DefaultHttpRequestWriter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpResponseParser
	 * HTTP response parser that obtain its input from an instance
	 * of {@link SessionInputBuffer}.
	 *
	 * @since 4.2
	 */
	export interface DefaultHttpResponseParser extends Http.AbstractMessageParser<Http.HttpResponse> {
	}
	export module DefaultHttpResponseParser {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpResponseParser
		 * HTTP response parser that obtain its input from an instance
		 * of {@link SessionInputBuffer}.
		 *
		 * @since 4.2
		 */
		export interface Static extends Http.AbstractMessageParser.Static {
			/**
			 * Creates new instance of DefaultHttpResponseParser.
			 *
			 * @param buffer the session input buffer.
			 * @param lineParser the line parser. If {@code null}
			 *   {@link org.apache.http.message.BasicLineParser#INSTANCE} will be used
			 * @param responseFactory the response factory. If {@code null}
			 *   {@link DefaultHttpResponseFactory#INSTANCE} will be used.
			 * @param constraints the message constraints. If {@code null}
			 *   {@link MessageConstraints#DEFAULT} will be used.
			 *
			 * @since 4.3
			 */
			new(buffer: Http.SessionInputBuffer, lineParser: Http.LineParser, responseFactory: Http.HttpResponseFactory, constraints: Http.MessageConstraints): Http.DefaultHttpResponseParser;
			/**
			 * @since 4.3
			 */
			new(buffer: Http.SessionInputBuffer, constraints: Http.MessageConstraints): Http.DefaultHttpResponseParser;
			/**
			 * @since 4.3
			 */
			new(buffer: Http.SessionInputBuffer): Http.DefaultHttpResponseParser;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpResponseParserFactory
	 * Default factory for response message parsers.
	 *
	 * @since 4.3
	 */
	export interface DefaultHttpResponseParserFactory extends Java.Object, Http.HttpMessageParserFactory<Http.HttpResponse> {
		create(buffer: Http.SessionInputBuffer, constraints: Http.MessageConstraints): Http.HttpMessageParser<Http.HttpResponse>;
	}
	export module DefaultHttpResponseParserFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpResponseParserFactory
		 * Default factory for response message parsers.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpMessageParserFactory.Static {
			new(lineParser: Http.LineParser, responseFactory: Http.HttpResponseFactory): Http.DefaultHttpResponseParserFactory;
			new(): Http.DefaultHttpResponseParserFactory;
			INSTANCE?: Http.DefaultHttpResponseParserFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpResponseWriterFactory
	 * Default factory for response message writers.
	 *
	 * @since 4.3
	 */
	export interface DefaultHttpResponseWriterFactory extends Java.Object, Http.HttpMessageWriterFactory<Http.HttpResponse> {
		create(buffer: Http.SessionOutputBuffer): Http.HttpMessageWriter<Http.HttpResponse>;
	}
	export module DefaultHttpResponseWriterFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpResponseWriterFactory
		 * Default factory for response message writers.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpMessageWriterFactory.Static {
			new(lineFormatter: Http.LineFormatter): Http.DefaultHttpResponseWriterFactory;
			new(): Http.DefaultHttpResponseWriterFactory;
			INSTANCE?: Http.DefaultHttpResponseWriterFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.HttpRequestParser
	 * HTTP request parser that obtain its input from an instance
	 * of {@link SessionInputBuffer}.
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2) use {@link DefaultHttpRequestParser}
	 */
	export interface HttpRequestParser extends Http.AbstractMessageParser<Http.HttpMessage> {
	}
	export module HttpRequestParser {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.HttpRequestParser
		 * HTTP request parser that obtain its input from an instance
		 * of {@link SessionInputBuffer}.
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2) use {@link DefaultHttpRequestParser}
		 */
		export interface Static extends Http.AbstractMessageParser.Static {
			new(): Http.HttpRequestParser;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.HttpResponseParser
	 * HTTP response parser that obtain its input from an instance
	 * of {@link SessionInputBuffer}.
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2) use {@link DefaultHttpResponseParser}
	 */
	export interface HttpResponseParser extends Http.AbstractMessageParser<Http.HttpMessage> {
	}
	export module HttpResponseParser {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.HttpResponseParser
		 * HTTP response parser that obtain its input from an instance
		 * of {@link SessionInputBuffer}.
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2) use {@link DefaultHttpResponseParser}
		 */
		export interface Static extends Http.AbstractMessageParser.Static {
			new(): Http.HttpResponseParser;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpRequestWriterFactory
	 * Default factory for request message writers.
	 *
	 * @since 4.3
	 */
	export interface DefaultHttpRequestWriterFactory extends Java.Object, Http.HttpMessageWriterFactory<Http.HttpRequest> {
		create(buffer: Http.SessionOutputBuffer): Http.HttpMessageWriter<Http.HttpRequest>;
	}
	export module DefaultHttpRequestWriterFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpRequestWriterFactory
		 * Default factory for request message writers.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpMessageWriterFactory.Static {
			new(lineFormatter: Http.LineFormatter): Http.DefaultHttpRequestWriterFactory;
			new(): Http.DefaultHttpRequestWriterFactory;
			INSTANCE?: Http.DefaultHttpRequestWriterFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.IdentityOutputStream
	 * Output stream that writes data without any transformation. The end of
	 * the content entity is demarcated by closing the underlying connection
	 * (EOF condition). Entities transferred using this input stream can be of
	 * unlimited length.
	 * 
	 * Note that this class NEVER closes the underlying stream, even when close
	 * gets called.  Instead, the stream will be marked as closed and no further
	 * output will be permitted.
	 *
	 * @since 4.0
	 */
	export interface IdentityOutputStream extends Java.OutputStream {
		/**
		 * Does not close the underlying socket output.
		 *
		 * @throws IOException If an I/O problem occurs.
		 */
		close(): void;
		flush(): void;
		write(b: array<byte>, off: int, len: int): void;
		write(b: array<byte>): void;
		write(b: int): void;
	}
	export module IdentityOutputStream {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.IdentityOutputStream
		 * Output stream that writes data without any transformation. The end of
		 * the content entity is demarcated by closing the underlying connection
		 * (EOF condition). Entities transferred using this input stream can be of
		 * unlimited length.
		 * 
		 * Note that this class NEVER closes the underlying stream, even when close
		 * gets called.  Instead, the stream will be marked as closed and no further
		 * output will be permitted.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.OutputStream.Static {
			new(out: Http.SessionOutputBuffer): Http.IdentityOutputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.HttpTransportMetricsImpl
	 * Default implementation of {@link HttpTransportMetrics}.
	 *
	 * @since 4.0
	 */
	export interface HttpTransportMetricsImpl extends Java.Object, Http.HttpTransportMetrics {
		getBytesTransferred(): long;
		incrementBytesTransferred(count: long): void;
		reset(): void;
		setBytesTransferred(count: long): void;
	}
	export module HttpTransportMetricsImpl {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.HttpTransportMetricsImpl
		 * Default implementation of {@link HttpTransportMetrics}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpTransportMetrics.Static {
			new(): Http.HttpTransportMetricsImpl;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.SocketInputBuffer
	 * {@link org.apache.http.io.SessionInputBuffer} implementation
	 * bound to a {@link Socket}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link SessionInputBufferImpl}
	 */
	export interface SocketInputBuffer extends Http.AbstractSessionInputBuffer, Http.EofSensor {
	}
	export module SocketInputBuffer {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.SocketInputBuffer
		 * {@link org.apache.http.io.SessionInputBuffer} implementation
		 * bound to a {@link Socket}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link SessionInputBufferImpl}
		 */
		export interface Static extends Http.AbstractSessionInputBuffer.Static, Http.EofSensor.Static {
			new(): Http.SocketInputBuffer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.SocketOutputBuffer
	 * {@link org.apache.http.io.SessionOutputBuffer} implementation
	 * bound to a {@link Socket}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link SessionOutputBufferImpl}
	 */
	export interface SocketOutputBuffer extends Http.AbstractSessionOutputBuffer {
	}
	export module SocketOutputBuffer {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.SocketOutputBuffer
		 * {@link org.apache.http.io.SessionOutputBuffer} implementation
		 * bound to a {@link Socket}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link SessionOutputBufferImpl}
		 */
		export interface Static extends Http.AbstractSessionOutputBuffer.Static {
			new(): Http.SocketOutputBuffer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.NoConnectionReuseStrategy
	 * A strategy that never re-uses a connection.
	 *
	 * @since 4.0
	 */
	export interface NoConnectionReuseStrategy extends Java.Object, Http.ConnectionReuseStrategy {
		keepAlive(response: Http.HttpResponse, context: Http.HttpContext): boolean;
	}
	export module NoConnectionReuseStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.NoConnectionReuseStrategy
		 * A strategy that never re-uses a connection.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionReuseStrategy.Static {
			new(): Http.NoConnectionReuseStrategy;
			INSTANCE?: Http.NoConnectionReuseStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.SessionOutputBufferImpl
	 * Abstract base class for session output buffers that stream data to
	 * an arbitrary {@link OutputStream}. This class buffers small chunks of
	 * output data in an internal byte array for optimal output performance.
	 * 
	 * {@link #writeLine(CharArrayBuffer)} and {@link #writeLine(String)} methods
	 * of this class use CR-LF as a line delimiter.
	 *
	 * @since 4.3
	 */
	export interface SessionOutputBufferImpl extends Java.Object, Http.SessionOutputBuffer, Http.BufferInfo {
		available(): int;
		bind(outstream: Java.OutputStream): void;
		capacity(): int;
		flush(): void;
		getMetrics(): Http.HttpTransportMetrics;
		isBound(): boolean;
		length(): int;
		write(b: array<byte>, off: int, len: int): void;
		write(b: array<byte>): void;
		write(b: int): void;
		/**
		 * Writes characters from the specified string followed by a line delimiter
		 * to this session buffer.
		 * 
		 * This method uses CR-LF as a line delimiter.
		 *
		 * @param      s   the line.
		 * @throws  IOException  if an I/O error occurs.
		 */
		writeLine(s: string): void;
		/**
		 * Writes characters from the specified char array followed by a line
		 * delimiter to this session buffer.
		 * 
		 * This method uses CR-LF as a line delimiter.
		 *
		 * @param      charbuffer the buffer containing chars of the line.
		 * @throws  IOException  if an I/O error occurs.
		 */
		writeLine(charbuffer: Http.CharArrayBuffer): void;
	}
	export module SessionOutputBufferImpl {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.SessionOutputBufferImpl
		 * Abstract base class for session output buffers that stream data to
		 * an arbitrary {@link OutputStream}. This class buffers small chunks of
		 * output data in an internal byte array for optimal output performance.
		 * 
		 * {@link #writeLine(CharArrayBuffer)} and {@link #writeLine(String)} methods
		 * of this class use CR-LF as a line delimiter.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.SessionOutputBuffer.Static, Http.BufferInfo.Static {
			/**
			 * Creates new instance of SessionOutputBufferImpl.
			 *
			 * @param metrics HTTP transport metrics.
			 * @param buffersize buffer size. Must be a positive number.
			 * @param fragementSizeHint fragment size hint defining a minimal size of a fragment
			 *   that should be written out directly to the socket bypassing the session buffer.
			 *   Value {@code 0} disables fragment buffering.
			 * @param charencoder charencoder to be used for encoding HTTP protocol elements.
			 *   If {@code null} simple type cast will be used for char to byte conversion.
			 */
			new(metrics: Http.HttpTransportMetricsImpl, buffersize: int, fragementSizeHint: int, charencoder: Java.CharsetEncoder): Http.SessionOutputBufferImpl;
			new(metrics: Http.HttpTransportMetricsImpl, buffersize: int): Http.SessionOutputBufferImpl;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.pool.BasicConnFactory
	 * A very basic {@link ConnFactory} implementation that creates
	 * {@link HttpClientConnection} instances given a {@link HttpHost} instance.
	 *
	 * @see HttpHost
	 * @since 4.2
	 */
	export interface BasicConnFactory extends Java.Object, Http.ConnFactory<Http.HttpHost, Http.HttpClientConnection> {
		create(host: Http.HttpHost): Http.HttpClientConnection;
	}
	export module BasicConnFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.pool.BasicConnFactory
		 * A very basic {@link ConnFactory} implementation that creates
		 * {@link HttpClientConnection} instances given a {@link HttpHost} instance.
		 *
		 * @see HttpHost
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.ConnFactory.Static {
			/**
			 * @since 4.3
			 */
			new(plainfactory: Java.SocketFactory, sslfactory: Java.SSLSocketFactory, connectTimeout: int, sconfig: Http.SocketConfig, cconfig: Http.ConnectionConfig): Http.BasicConnFactory;
			/**
			 * @since 4.3
			 */
			new(connectTimeout: int, sconfig: Http.SocketConfig, cconfig: Http.ConnectionConfig): Http.BasicConnFactory;
			/**
			 * @since 4.3
			 */
			new(sconfig: Http.SocketConfig, cconfig: Http.ConnectionConfig): Http.BasicConnFactory;
			/**
			 * @since 4.3
			 */
			new(): Http.BasicConnFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.pool.BasicPoolEntry
	 * A very basic {@link PoolEntry} implementation that represents an entry
	 * in a pool of blocking {@link HttpClientConnection}s identified by
	 * an {@link HttpHost} instance.
	 *
	 * @see HttpHost
	 * @since 4.2
	 */
	export interface BasicPoolEntry extends Http.PoolEntry<Http.HttpHost, Http.HttpClientConnection> {
		close(): void;
		isClosed(): boolean;
	}
	export module BasicPoolEntry {
		/**
		 * Corresponding Java class: org.apache.http.impl.pool.BasicPoolEntry
		 * A very basic {@link PoolEntry} implementation that represents an entry
		 * in a pool of blocking {@link HttpClientConnection}s identified by
		 * an {@link HttpHost} instance.
		 *
		 * @see HttpHost
		 * @since 4.2
		 */
		export interface Static extends Http.PoolEntry.Static {
			new(id: string, route: Http.HttpHost, conn: Http.HttpClientConnection): Http.BasicPoolEntry;
		}
	}

	/**
	 * @deprecated
	 * Corresponding Java class: org.apache.http.impl.SocketHttpServerConnection
	 */
	export interface SocketHttpServerConnection extends Http.AbstractHttpServerConnection, Http.HttpInetConnection {
	}
	export module SocketHttpServerConnection {
		/**
		 * @deprecated
		 * Corresponding Java class: org.apache.http.impl.SocketHttpServerConnection
		 */
		export interface Static extends Http.AbstractHttpServerConnection.Static, Http.HttpInetConnection.Static {
			new(): Http.SocketHttpServerConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.pool.BasicConnPool
	 * A very basic {@link org.apache.http.pool.ConnPool} implementation that
	 * represents a pool of blocking {@link HttpClientConnection} connections
	 * identified by an {@link HttpHost} instance. Please note this pool
	 * implementation does not support complex routes via a proxy cannot
	 * differentiate between direct and proxied connections.
	 *
	 * @see HttpHost
	 * @since 4.2
	 */
	export interface BasicConnPool extends Http.AbstractConnPool<Http.HttpHost, Http.HttpClientConnection, Http.BasicPoolEntry> {
	}
	export module BasicConnPool {
		/**
		 * Corresponding Java class: org.apache.http.impl.pool.BasicConnPool
		 * A very basic {@link org.apache.http.pool.ConnPool} implementation that
		 * represents a pool of blocking {@link HttpClientConnection} connections
		 * identified by an {@link HttpHost} instance. Please note this pool
		 * implementation does not support complex routes via a proxy cannot
		 * differentiate between direct and proxied connections.
		 *
		 * @see HttpHost
		 * @since 4.2
		 */
		export interface Static extends Http.AbstractConnPool.Static {
			new(connFactory: Http.ConnFactory<Http.HttpHost, Http.HttpClientConnection>): Http.BasicConnPool;
			/**
			 * @since 4.3
			 */
			new(sconfig: Http.SocketConfig, cconfig: Http.ConnectionConfig): Http.BasicConnPool;
			/**
			 * @since 4.3
			 */
			new(): Http.BasicConnPool;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicHeader
	 * Basic implementation of {@link Header}.
	 *
	 * @since 4.0
	 */
	export interface BasicHeader extends Java.Object, Http.Header, Java.Cloneable, Java.Serializable {
		clone(): obj;
		getElements(): array<Http.HeaderElement>;
		getName(): string;
		getValue(): string;
		toString(): string;
	}
	export module BasicHeader {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicHeader
		 * Basic implementation of {@link Header}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.Header.Static, Java.Cloneable.Static, Java.Serializable.Static {
			/**
			 * Constructor with name and value
			 *
			 * @param name the header name
			 * @param value the header value
			 */
			new(name: string, value: string): Http.BasicHeader;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicHttpRequest
	 * Basic implementation of {@link HttpRequest}.
	 *
	 * @since 4.0
	 */
	export interface BasicHttpRequest extends Http.AbstractHttpMessage, Http.HttpRequest {
		/**
		 * Returns the HTTP protocol version to be used for this request.
		 *
		 * @see #BasicHttpRequest(String, String)
		 */
		getProtocolVersion(): Http.ProtocolVersion;
		/**
		 * Returns the request line of this request.
		 *
		 * @see #BasicHttpRequest(String, String)
		 */
		getRequestLine(): Http.RequestLine;
		toString(): string;
	}
	export module BasicHttpRequest {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicHttpRequest
		 * Basic implementation of {@link HttpRequest}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractHttpMessage.Static, Http.HttpRequest.Static {
			/**
			 * Creates an instance of this class using the given request method
			 * and URI.
			 *
			 * @param method request method.
			 * @param uri request URI.
			 */
			new(method: string, uri: string): Http.BasicHttpRequest;
			/**
			 * Creates an instance of this class using the given request method, URI
			 * and the HTTP protocol version.
			 *
			 * @param method request method.
			 * @param uri request URI.
			 * @param ver HTTP protocol version.
			 */
			new(method: string, uri: string, ver: Http.ProtocolVersion): Http.BasicHttpRequest;
			/**
			 * Creates an instance of this class using the given request line.
			 *
			 * @param requestline request line.
			 */
			new(requestline: Http.RequestLine): Http.BasicHttpRequest;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicHeaderIterator
	 * Basic implementation of a {@link HeaderIterator}.
	 *
	 * @since 4.0
	 */
	export interface BasicHeaderIterator extends Java.Object, Http.HeaderIterator {
		hasNext(): boolean;
		/**
		 * Returns the next header.
		 * Same as {@link #nextHeader nextHeader}, but not type-safe.
		 *
		 * @return  the next header in this iteration
		 *
		 * @throws NoSuchElementException   if there are no more headers
		 */
		next(): obj;
		/**
		 * Obtains the next header from this iteration.
		 *
		 * @return  the next header in this iteration
		 *
		 * @throws NoSuchElementException   if there are no more headers
		 */
		nextHeader(): Http.Header;
		/**
		 * Removing headers is not supported.
		 *
		 * @throws UnsupportedOperationException    always
		 */
		remove(): void;
	}
	export module BasicHeaderIterator {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicHeaderIterator
		 * Basic implementation of a {@link HeaderIterator}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HeaderIterator.Static {
			/**
			 * Creates a new header iterator.
			 *
			 * @param headers   an array of headers over which to iterate
			 * @param name      the name of the headers over which to iterate, or
			 *                  {@code null} for any
			 */
			new(headers: array<Http.Header>, name: string): Http.BasicHeaderIterator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicTokenIterator
	 * Basic implementation of a {@link TokenIterator}.
	 * This implementation parses {@code #token} sequences as
	 * defined by RFC 2616, section 2.
	 * It extends that definition somewhat beyond US-ASCII.
	 *
	 * @since 4.0
	 */
	export interface BasicTokenIterator extends Java.Object, Http.TokenIterator {
		hasNext(): boolean;
		/**
		 * Returns the next token.
		 * Same as {@link #nextToken}, but with generic return type.
		 *
		 * @return  the next token in this iteration
		 *
		 * @throws NoSuchElementException   if there are no more tokens
		 * @throws ParseException   if an invalid header value is encountered
		 */
		next(): obj;
		/**
		 * Obtains the next token from this iteration.
		 *
		 * @return  the next token in this iteration
		 *
		 * @throws NoSuchElementException   if the iteration is already over
		 * @throws ParseException   if an invalid header value is encountered
		 */
		nextToken(): string;
		/**
		 * Removing tokens is not supported.
		 *
		 * @throws UnsupportedOperationException    always
		 */
		remove(): void;
	}
	export module BasicTokenIterator {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicTokenIterator
		 * Basic implementation of a {@link TokenIterator}.
		 * This implementation parses {@code #token} sequences as
		 * defined by RFC 2616, section 2.
		 * It extends that definition somewhat beyond US-ASCII.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.TokenIterator.Static {
			/**
			 * Creates a new instance of {@link BasicTokenIterator}.
			 *
			 * @param headerIterator    the iterator for the headers to tokenize
			 */
			new(headerIterator: Http.HeaderIterator): Http.BasicTokenIterator;
			HTTP_SEPARATORS?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.LineFormatter
	 * Interface for formatting elements of the HEAD section of an HTTP message.
	 * This is the complement to {@link LineParser}.
	 * There are individual methods for formatting a request line, a
	 * status line, or a header line. The formatting does not include the
	 * trailing line break sequence CR-LF.
	 * Instances of this interface are expected to be stateless and thread-safe.
	 *
	 * 
	 * The formatted lines are returned in memory, the formatter does not depend
	 * on any specific IO mechanism.
	 * In order to avoid unnecessary creation of temporary objects,
	 * a buffer can be passed as argument to all formatting methods.
	 * The implementation may or may not actually use that buffer for formatting.
	 * If it is used, the buffer will first be cleared by the
	 * {@code formatXXX} methods.
	 * The argument buffer can always be re-used after the call. The buffer
	 * returned as the result, if it is different from the argument buffer,
	 * MUST NOT be modified.
	 * 
	 *
	 * @since 4.0
	 */
	export interface LineFormatter extends Java.Object {
		/**
		 * Formats a protocol version.
		 * This method does not follow the general contract for
		 * {@code buffer} arguments.
		 * It does not clear the argument buffer, but appends instead.
		 * The returned buffer can always be modified by the caller.
		 * Because of these differing conventions, it is not named
		 * {@code formatProtocolVersion}.
		 *
		 * @param buffer    a buffer to which to append, or {@code null}
		 * @param version   the protocol version to format
		 *
		 * @return  a buffer with the formatted protocol version appended.
		 *          The caller is allowed to modify the result buffer.
		 *          If the {@code buffer} argument is not {@code null},
		 *          the returned buffer is the argument buffer.
		 */
		appendProtocolVersion(buffer: Http.CharArrayBuffer, version: Http.ProtocolVersion): Http.CharArrayBuffer;
		/**
		 * Formats a header.
		 * Due to header continuation, the result may be multiple lines.
		 * In order to generate well-formed HTTP, the lines in the result
		 * must be separated by the HTTP line break sequence CR-LF.
		 * There is no trailing CR-LF in the result.
		 * 
		 * See the class comment for details about the buffer argument.
		 * 
		 *
		 * @param buffer    a buffer available for formatting, or
		 *                  {@code null}.
		 *                  The buffer will be cleared before use.
		 * @param header    the header to format
		 *
		 * @return  a buffer holding the formatted header, never {@code null}.
		 *          The returned buffer may be different from the argument buffer.
		 *
		 * @throws org.apache.http.ParseException        in case of a parse error
		 */
		formatHeader(buffer: Http.CharArrayBuffer, header: Http.Header): Http.CharArrayBuffer;
		/**
		 * Formats a request line.
		 *
		 * @param buffer    a buffer available for formatting, or
		 *                  {@code null}.
		 *                  The buffer will be cleared before use.
		 * @param reqline   the request line to format
		 *
		 * @return  the formatted request line
		 */
		formatRequestLine(buffer: Http.CharArrayBuffer, reqline: Http.RequestLine): Http.CharArrayBuffer;
		/**
		 * Formats a status line.
		 *
		 * @param buffer    a buffer available for formatting, or
		 *                  {@code null}.
		 *                  The buffer will be cleared before use.
		 * @param statline  the status line to format
		 *
		 * @return  the formatted status line
		 *
		 * @throws org.apache.http.ParseException        in case of a parse error
		 */
		formatStatusLine(buffer: Http.CharArrayBuffer, statline: Http.StatusLine): Http.CharArrayBuffer;
	}
	export module LineFormatter {
		/**
		 * Corresponding Java class: org.apache.http.message.LineFormatter
		 * Interface for formatting elements of the HEAD section of an HTTP message.
		 * This is the complement to {@link LineParser}.
		 * There are individual methods for formatting a request line, a
		 * status line, or a header line. The formatting does not include the
		 * trailing line break sequence CR-LF.
		 * Instances of this interface are expected to be stateless and thread-safe.
		 *
		 * 
		 * The formatted lines are returned in memory, the formatter does not depend
		 * on any specific IO mechanism.
		 * In order to avoid unnecessary creation of temporary objects,
		 * a buffer can be passed as argument to all formatting methods.
		 * The implementation may or may not actually use that buffer for formatting.
		 * If it is used, the buffer will first be cleared by the
		 * {@code formatXXX} methods.
		 * The argument buffer can always be re-used after the call. The buffer
		 * returned as the result, if it is different from the argument buffer,
		 * MUST NOT be modified.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.HttpProtocolParamBean
	 * This is a Java Bean class that can be used to wrap an instance of
	 * {@link HttpParams} and manipulate HTTP protocol parameters using Java Beans
	 * conventions.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface HttpProtocolParamBean extends Http.HttpAbstractParamBean {
	}
	export module HttpProtocolParamBean {
		/**
		 * Corresponding Java class: org.apache.http.params.HttpProtocolParamBean
		 * This is a Java Bean class that can be used to wrap an instance of
		 * {@link HttpParams} and manipulate HTTP protocol parameters using Java Beans
		 * conventions.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Http.HttpAbstractParamBean.Static {
			new(): Http.HttpProtocolParamBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicListHeaderIterator
	 * Implementation of a {@link HeaderIterator} based on a {@link List}.
	 * For use by {@link HeaderGroup}.
	 *
	 * @since 4.0
	 */
	export interface BasicListHeaderIterator extends Java.Object, Http.HeaderIterator {
		hasNext(): boolean;
		/**
		 * Returns the next header.
		 * Same as {@link #nextHeader nextHeader}, but not type-safe.
		 *
		 * @return  the next header in this iteration
		 *
		 * @throws NoSuchElementException   if there are no more headers
		 */
		next(): obj;
		/**
		 * Obtains the next header from this iteration.
		 *
		 * @return  the next header in this iteration
		 *
		 * @throws NoSuchElementException   if there are no more headers
		 */
		nextHeader(): Http.Header;
		/**
		 * Removes the header that was returned last.
		 */
		remove(): void;
	}
	export module BasicListHeaderIterator {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicListHeaderIterator
		 * Implementation of a {@link HeaderIterator} based on a {@link List}.
		 * For use by {@link HeaderGroup}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HeaderIterator.Static {
			/**
			 * Creates a new header iterator.
			 *
			 * @param headers   a list of headers over which to iterate
			 * @param name      the name of the headers over which to iterate, or
			 *                  {@code null} for any
			 */
			new(headers: Java.List<Http.Header>, name: string): Http.BasicListHeaderIterator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.pool.PoolEntryCallback
	 * Pool entry callabck.
	 *
	 * @param  the route type that represents the opposite endpoint of a pooled
	 *   connection.
	 * @param  the connection type.
	 * @since 4.3
	 */
	export interface PoolEntryCallback<T = any, C = any> extends Java.Object {
		process(entry: Http.PoolEntry<T, C>): void;
	}
	export module PoolEntryCallback {
		/**
		 * Corresponding Java class: org.apache.http.pool.PoolEntryCallback
		 * Pool entry callabck.
		 *
		 * @param  the route type that represents the opposite endpoint of a pooled
		 *   connection.
		 * @param  the connection type.
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.pool.AbstractConnPool
	 * Abstract synchronous (blocking) pool of connections.
	 * 
	 * Please note that this class does not maintain its own pool of execution {@link Thread}s.
	 * Therefore, one must call {@link Future#get()} or {@link Future#get(long, TimeUnit)}
	 * method on the {@link Future} object returned by the
	 * {@link #lease(Object, Object, FutureCallback)} method in order for the lease operation
	 * to complete.
	 *
	 * @param  the route type that represents the opposite endpoint of a pooled
	 *   connection.
	 * @param  the connection type.
	 * @param  the type of the pool entry containing a pooled connection.
	 * @since 4.2
	 */
	export interface AbstractConnPool<T = any, C = any, E extends PoolEntry<T, C> = any> extends Java.Object, Http.ConnPool<T, E>, Http.ConnPoolControl<T> {
		/**
		 * Closes expired connections and evicts them from the pool.
		 */
		closeExpired(): void;
		/**
		 * Closes connections that have been idle longer than the given period
		 * of time and evicts them from the pool.
		 *
		 * @param idletime maximum idle time.
		 * @param tunit time unit.
		 */
		closeIdle(idletime: long, tunit: Java.TimeUnit): void;
		getDefaultMaxPerRoute(): int;
		getMaxPerRoute(route: T): int;
		getMaxTotal(): int;
		/**
		 * Returns snapshot of all knows routes
		 * @return the set of routes
		 *
		 * @since 4.4
		 */
		getRoutes(): Java.Set<T>;
		getStats(route: T): Http.PoolStats;
		getTotalStats(): Http.PoolStats;
		/**
		 * @return the number of milliseconds
		 * @since 4.4
		 */
		getValidateAfterInactivity(): int;
		isShutdown(): boolean;
		/**
		 * {@inheritDoc}
		 * 
		 * Please note that this class does not maintain its own pool of execution
		 * {@link Thread}s. Therefore, one must call {@link Future#get()}
		 * or {@link Future#get(long, TimeUnit)} method on the {@link Future}
		 * returned by this method in order for the lease operation to complete.
		 */
		lease(route: T, state: obj, callback: Http.FutureCallback<E>): Java.Future<E>;
		/**
		 * Attempts to lease a connection for the given route and with the given
		 * state from the pool.
		 * 
		 * Please note that this class does not maintain its own pool of execution
		 * {@link Thread}s. Therefore, one must call {@link Future#get()}
		 * or {@link Future#get(long, TimeUnit)} method on the {@link Future}
		 * returned by this method in order for the lease operation to complete.
		 *
		 * @param route route of the connection.
		 * @param state arbitrary object that represents a particular state
		 *  (usually a security principal or a unique token identifying
		 *  the user whose credentials have been used while establishing the connection).
		 *  May be {@code null}.
		 * @return future for a leased pool entry.
		 */
		lease(route: T, state: obj): Java.Future<E>;
		release(entry: E, reusable: boolean): void;
		setDefaultMaxPerRoute(max: int): void;
		setMaxPerRoute(route: T, max: int): void;
		setMaxTotal(max: int): void;
		/**
		 * @param ms the number of milliseconds
		 * @since 4.4
		 */
		setValidateAfterInactivity(ms: int): void;
		/**
		 * Shuts down the pool.
		 */
		shutdown(): void;
		toString(): string;
	}
	export module AbstractConnPool {
		/**
		 * Corresponding Java class: org.apache.http.pool.AbstractConnPool
		 * Abstract synchronous (blocking) pool of connections.
		 * 
		 * Please note that this class does not maintain its own pool of execution {@link Thread}s.
		 * Therefore, one must call {@link Future#get()} or {@link Future#get(long, TimeUnit)}
		 * method on the {@link Future} object returned by the
		 * {@link #lease(Object, Object, FutureCallback)} method in order for the lease operation
		 * to complete.
		 *
		 * @param  the route type that represents the opposite endpoint of a pooled
		 *   connection.
		 * @param  the connection type.
		 * @param  the type of the pool entry containing a pooled connection.
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.ConnPool.Static, Http.ConnPoolControl.Static {
			new <T, C, E extends PoolEntry<T, C>>(connFactory: Http.ConnFactory<T, C>, defaultMaxPerRoute: int, maxTotal: int): Http.AbstractConnPool<T, C, E>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HTTP
	 * Constants and static helpers related to the HTTP protocol.
	 *
	 * @since 4.0
	 */
	export interface HTTP extends Java.Object {
	}
	export module HTTP {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HTTP
		 * Constants and static helpers related to the HTTP protocol.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			CR?: int;
			LF?: int;
			SP?: int;
			HT?: int;
			/**
			 HTTP header definitions
			 */
			TRANSFER_ENCODING?: string;
			CONTENT_LEN?: string;
			CONTENT_TYPE?: string;
			CONTENT_ENCODING?: string;
			EXPECT_DIRECTIVE?: string;
			CONN_DIRECTIVE?: string;
			TARGET_HOST?: string;
			USER_AGENT?: string;
			DATE_HEADER?: string;
			SERVER_HEADER?: string;
			/**
			 HTTP expectations
			 */
			EXPECT_CONTINUE?: string;
			/**
			 HTTP connection control
			 */
			CONN_CLOSE?: string;
			CONN_KEEP_ALIVE?: string;
			/**
			 Transfer encoding definitions
			 */
			CHUNK_CODING?: string;
			IDENTITY_CODING?: string;
			DEF_CONTENT_CHARSET?: Java.Charset;
			DEF_PROTOCOL_CHARSET?: Java.Charset;
			isWhitespace(ch: char): boolean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpExpectationVerifier
	 * Defines an interface to verify whether an incoming HTTP request meets
	 * the target server's expectations.
	 *
	 * The Expect request-header field is used to indicate that particular
	 * server behaviors are required by the client.
	 *
	 *
	 *    Expect       =  "Expect" ":" 1#expectation
	 *
	 *    expectation  =  "100-continue" | expectation-extension
	 *    expectation-extension =  token [ "=" ( token | quoted-string )
	 *                             *expect-params ]
	 *    expect-params =  ";" token [ "=" ( token | quoted-string ) ]
	 *
	 *
	 * A server that does not understand or is unable to comply with any of
	 * the expectation values in the Expect field of a request MUST respond
	 * with appropriate error status. The server MUST respond with a 417
	 * (Expectation Failed) status if any of the expectations cannot be met
	 * or, if there are other problems with the request, some other 4xx
	 * status.
	 *
	 *
	 * @since 4.0
	 */
	export interface HttpExpectationVerifier extends Java.Object {
		/**
		 * Verifies whether the given request meets the server's expectations.
		 * 
		 * If the request fails to meet particular criteria, this method can
		 * trigger a terminal response back to the client by setting the status
		 * code of the response object to a value greater or equal to
		 * {@code 200}. In this case the client will not have to transmit
		 * the request body. If the request meets expectations this method can
		 * terminate without modifying the response object. Per default the status
		 * code of the response object will be set to {@code 100}.
		 *
		 * @param request the HTTP request.
		 * @param response the HTTP response.
		 * @param context the HTTP context.
		 * @throws HttpException in case of an HTTP protocol violation.
		 */
		verify(request: Http.HttpRequest, response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module HttpExpectationVerifier {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpExpectationVerifier
		 * Defines an interface to verify whether an incoming HTTP request meets
		 * the target server's expectations.
		 *
		 * The Expect request-header field is used to indicate that particular
		 * server behaviors are required by the client.
		 *
		 *
		 *    Expect       =  "Expect" ":" 1#expectation
		 *
		 *    expectation  =  "100-continue" | expectation-extension
		 *    expectation-extension =  token [ "=" ( token | quoted-string )
		 *                             *expect-params ]
		 *    expect-params =  ";" token [ "=" ( token | quoted-string ) ]
		 *
		 *
		 * A server that does not understand or is unable to comply with any of
		 * the expectation values in the Expect field of a request MUST respond
		 * with appropriate error status. The server MUST respond with a 417
		 * (Expectation Failed) status if any of the expectations cannot be met
		 * or, if there are other problems with the request, some other 4xx
		 * status.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpRequestHandler
	 * HttpRequestHandler represents a routine for processing of a specific group
	 * of HTTP requests. Protocol handlers are designed to take care of protocol
	 * specific aspects, whereas individual request handlers are expected to take
	 * care of application specific HTTP processing. The main purpose of a request
	 * handler is to generate a response object with a content entity to be sent
	 * back to the client in response to the given request
	 *
	 * @since 4.0
	 */
	export interface HttpRequestHandler extends Java.Object {
		/**
		 * Handles the request and produces a response to be sent back to
		 * the client.
		 *
		 * @param request the HTTP request.
		 * @param response the HTTP response.
		 * @param context the HTTP execution context.
		 * @throws IOException in case of an I/O error.
		 * @throws HttpException in case of HTTP protocol violation or a processing
		 *   problem.
		 */
		handle(request: Http.HttpRequest, response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module HttpRequestHandler {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpRequestHandler
		 * HttpRequestHandler represents a routine for processing of a specific group
		 * of HTTP requests. Protocol handlers are designed to take care of protocol
		 * specific aspects, whereas individual request handlers are expected to take
		 * care of application specific HTTP processing. The main purpose of a request
		 * handler is to generate a response object with a content entity to be sent
		 * back to the client in response to the given request
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpRequestInterceptorList
	 * Provides access to an ordered list of request interceptors.
	 * Lists are expected to be built upfront and used read-only afterwards
	 * for {@link HttpProcessor processing}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3)
	 */
	export interface HttpRequestInterceptorList extends Java.Object {
	}
	export module HttpRequestInterceptorList {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpRequestInterceptorList
		 * Provides access to an ordered list of request interceptors.
		 * Lists are expected to be built upfront and used read-only afterwards
		 * for {@link HttpProcessor processing}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3)
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.ImmutableHttpProcessor
	 * Immutable {@link HttpProcessor}.
	 *
	 * @since 4.1
	 */
	export interface ImmutableHttpProcessor extends Java.Object, Http.HttpProcessor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
		process(response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module ImmutableHttpProcessor {
		/**
		 * Corresponding Java class: org.apache.http.protocol.ImmutableHttpProcessor
		 * Immutable {@link HttpProcessor}.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static, Http.HttpProcessor.Static {
			new(requestInterceptors: array<Http.HttpRequestInterceptor>, responseInterceptors: array<Http.HttpResponseInterceptor>): Http.ImmutableHttpProcessor;
			/**
			 * @since 4.3
			 */
			new(requestInterceptors: Java.List<Http.HttpRequestInterceptor>, responseInterceptors: Java.List<Http.HttpResponseInterceptor>): Http.ImmutableHttpProcessor;
			new(...requestInterceptors: Http.HttpRequestInterceptor[]): Http.ImmutableHttpProcessor;
			new(requestInterceptors: array<Http.HttpRequestInterceptor>): Http.ImmutableHttpProcessor;
			new(...responseInterceptors: Http.HttpResponseInterceptor[]): Http.ImmutableHttpProcessor;
			new(responseInterceptors: array<Http.HttpResponseInterceptor>): Http.ImmutableHttpProcessor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.RequestExpectContinue
	 * RequestExpectContinue is responsible for enabling the 'expect-continue'
	 * handshake by adding {@code Expect} header. This interceptor is
	 * recommended for client side protocol processors.
	 *
	 * @since 4.0
	 */
	export interface RequestExpectContinue extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestExpectContinue {
		/**
		 * Corresponding Java class: org.apache.http.protocol.RequestExpectContinue
		 * RequestExpectContinue is responsible for enabling the 'expect-continue'
		 * handshake by adding {@code Expect} header. This interceptor is
		 * recommended for client side protocol processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			/**
			 * @since 4.3
			 */
			new(activeByDefault: boolean): Http.RequestExpectContinue;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.ResponseContent
	 * ResponseContent is the most important interceptor for outgoing responses.
	 * It is responsible for delimiting content length by adding
	 * {@code Content-Length} or {@code Transfer-Content} headers based
	 * on the properties of the enclosed entity and the protocol version.
	 * This interceptor is required for correct functioning of server side protocol
	 * processors.
	 *
	 * @since 4.0
	 */
	export interface ResponseContent extends Java.Object, Http.HttpResponseInterceptor {
		/**
		 * Processes the response (possibly updating or inserting) Content-Length and Transfer-Encoding headers.
		 * @param response The HttpResponse to modify.
		 * @param context Unused.
		 * @throws ProtocolException If either the Content-Length or Transfer-Encoding headers are found.
		 * @throws IllegalArgumentException If the response is null.
		 */
		process(response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module ResponseContent {
		/**
		 * Corresponding Java class: org.apache.http.protocol.ResponseContent
		 * ResponseContent is the most important interceptor for outgoing responses.
		 * It is responsible for delimiting content length by adding
		 * {@code Content-Length} or {@code Transfer-Content} headers based
		 * on the properties of the enclosed entity and the protocol version.
		 * This interceptor is required for correct functioning of server side protocol
		 * processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpResponseInterceptor.Static {
			/**
			 * Default constructor. The {@code Content-Length} or {@code Transfer-Encoding}
			 * will cause the interceptor to throw {@link ProtocolException} if already present in the
			 * response message.
			 */
			new(): Http.ResponseContent;
			/**
			 * Constructor that can be used to fine-tune behavior of this interceptor.
			 *
			 * @param overwrite If set to {@code true} the {@code Content-Length} and
			 * {@code Transfer-Encoding} headers will be created or updated if already present.
			 * If set to {@code false} the {@code Content-Length} and
			 * {@code Transfer-Encoding} headers will cause the interceptor to throw
			 * {@link ProtocolException} if already present in the response message.
			 *
			 * @since 4.2
			 */
			new(overwrite: boolean): Http.ResponseContent;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.UriHttpRequestHandlerMapper
	 * Maintains a map of HTTP request handlers keyed by a request URI pattern.
	 * 
	 * Patterns may have three formats:
	 * 
	 *   {@code *}
	 *   {@code *&lt;uri&gt;}
	 *   {@code &lt;uri&gt;*}
	 * 
	 * 
	 * This class can be used to map an instance of
	 * {@link HttpRequestHandler} matching a particular request URI. Usually the
	 * mapped request handler will be used to process the request with the
	 * specified request URI.
	 *
	 * @since 4.3
	 */
	export interface UriHttpRequestHandlerMapper extends Java.Object, Http.HttpRequestHandlerMapper {
		/**
		 * Looks up a handler matching the given request URI.
		 *
		 * @param request the request
		 * @return handler or {@code null} if no match is found.
		 */
		lookup(request: Http.HttpRequest): Http.HttpRequestHandler;
		/**
		 * Registers the given {@link HttpRequestHandler} as a handler for URIs
		 * matching the given pattern.
		 *
		 * @param pattern the pattern to register the handler for.
		 * @param handler the handler.
		 */
		register(pattern: string, handler: Http.HttpRequestHandler): void;
		/**
		 * Removes registered handler, if exists, for the given pattern.
		 *
		 * @param pattern the pattern to unregister the handler for.
		 */
		unregister(pattern: string): void;
	}
	export module UriHttpRequestHandlerMapper {
		/**
		 * Corresponding Java class: org.apache.http.protocol.UriHttpRequestHandlerMapper
		 * Maintains a map of HTTP request handlers keyed by a request URI pattern.
		 * 
		 * Patterns may have three formats:
		 * 
		 *   {@code *}
		 *   {@code *&lt;uri&gt;}
		 *   {@code &lt;uri&gt;*}
		 * 
		 * 
		 * This class can be used to map an instance of
		 * {@link HttpRequestHandler} matching a particular request URI. Usually the
		 * mapped request handler will be used to process the request with the
		 * specified request URI.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestHandlerMapper.Static {
			new(): Http.UriHttpRequestHandlerMapper;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ReasonPhraseCatalog
	 * Interface for obtaining reason phrases for HTTP status codes.
	 *
	 * @since 4.0
	 */
	export interface ReasonPhraseCatalog extends Java.Object {
		/**
		 * Obtains the reason phrase for a status code.
		 * The optional context allows for catalogs that detect
		 * the language for the reason phrase.
		 *
		 * @param status    the status code, in the range 100-599
		 * @param loc       the preferred locale for the reason phrase
		 *
		 * @return  the reason phrase, or {@code null} if unknown
		 */
		getReason(status: int, loc: Java.Locale): string;
	}
	export module ReasonPhraseCatalog {
		/**
		 * Corresponding Java class: org.apache.http.ReasonPhraseCatalog
		 * Interface for obtaining reason phrases for HTTP status codes.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.DefaultConnectionReuseStrategy
	 * Default implementation of a strategy deciding about connection re-use.
	 * The default implementation first checks some basics, for example
	 * whether the connection is still open or whether the end of the
	 * request entity can be determined without closing the connection.
	 * If these checks pass, the tokens in the {@code Connection} header will
	 * be examined. In the absence of a {@code Connection} header, the
	 * non-standard but commonly used {@code Proxy-Connection} header takes
	 * it's role. A token {@code close} indicates that the connection cannot
	 * be reused. If there is no such token, a token {@code keep-alive}
	 * indicates that the connection should be re-used. If neither token is found,
	 * or if there are no {@code Connection} headers, the default policy for
	 * the HTTP version is applied. Since {@code HTTP/1.1}, connections are
	 * re-used by default. Up until {@code HTTP/1.0}, connections are not
	 * re-used by default.
	 *
	 * @since 4.0
	 */
	export interface DefaultConnectionReuseStrategy extends Java.Object, Http.ConnectionReuseStrategy {
		keepAlive(response: Http.HttpResponse, context: Http.HttpContext): boolean;
	}
	export module DefaultConnectionReuseStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.DefaultConnectionReuseStrategy
		 * Default implementation of a strategy deciding about connection re-use.
		 * The default implementation first checks some basics, for example
		 * whether the connection is still open or whether the end of the
		 * request entity can be determined without closing the connection.
		 * If these checks pass, the tokens in the {@code Connection} header will
		 * be examined. In the absence of a {@code Connection} header, the
		 * non-standard but commonly used {@code Proxy-Connection} header takes
		 * it's role. A token {@code close} indicates that the connection cannot
		 * be reused. If there is no such token, a token {@code keep-alive}
		 * indicates that the connection should be re-used. If neither token is found,
		 * or if there are no {@code Connection} headers, the default policy for
		 * the HTTP version is applied. Since {@code HTTP/1.1}, connections are
		 * re-used by default. Up until {@code HTTP/1.0}, connections are not
		 * re-used by default.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.ConnectionReuseStrategy.Static {
			new(): Http.DefaultConnectionReuseStrategy;
			INSTANCE?: Http.DefaultConnectionReuseStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.DefaultHttpClientConnection
	 * Default implementation of a client-side HTTP connection.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link DefaultBHttpClientConnection}
	 */
	export interface DefaultHttpClientConnection extends Http.SocketHttpClientConnection {
	}
	export module DefaultHttpClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.DefaultHttpClientConnection
		 * Default implementation of a client-side HTTP connection.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link DefaultBHttpClientConnection}
		 */
		export interface Static extends Http.SocketHttpClientConnection.Static {
			new(): Http.DefaultHttpClientConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.DefaultHttpRequestFactory
	 * Default factory for creating {@link HttpRequest} objects.
	 *
	 * @since 4.0
	 */
	export interface DefaultHttpRequestFactory extends Java.Object, Http.HttpRequestFactory {
		newHttpRequest(requestline: Http.RequestLine): Http.HttpRequest;
		newHttpRequest(method: string, uri: string): Http.HttpRequest;
	}
	export module DefaultHttpRequestFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.DefaultHttpRequestFactory
		 * Default factory for creating {@link HttpRequest} objects.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestFactory.Static {
			new(): Http.DefaultHttpRequestFactory;
			INSTANCE?: Http.DefaultHttpRequestFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.DefaultHttpResponseFactory
	 * Default factory for creating {@link HttpResponse} objects.
	 *
	 * @since 4.0
	 */
	export interface DefaultHttpResponseFactory extends Java.Object, Http.HttpResponseFactory {
		newHttpResponse(ver: Http.ProtocolVersion, status: int, context: Http.HttpContext): Http.HttpResponse;
		newHttpResponse(statusline: Http.StatusLine, context: Http.HttpContext): Http.HttpResponse;
	}
	export module DefaultHttpResponseFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.DefaultHttpResponseFactory
		 * Default factory for creating {@link HttpResponse} objects.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpResponseFactory.Static {
			/**
			 * Creates a new response factory with the given catalog.
			 *
			 * @param catalog   the catalog of reason phrases
			 */
			new(catalog: Http.ReasonPhraseCatalog): Http.DefaultHttpResponseFactory;
			/**
			 * Creates a new response factory with the default catalog.
			 * The default catalog is {@link EnglishReasonPhraseCatalog}.
			 */
			new(): Http.DefaultHttpResponseFactory;
			INSTANCE?: Http.DefaultHttpResponseFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.DefaultHttpServerConnection
	 * Default implementation of a server-side HTTP connection.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link DefaultBHttpServerConnection}
	 */
	export interface DefaultHttpServerConnection extends Http.SocketHttpServerConnection {
	}
	export module DefaultHttpServerConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.DefaultHttpServerConnection
		 * Default implementation of a server-side HTTP connection.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link DefaultBHttpServerConnection}
		 */
		export interface Static extends Http.SocketHttpServerConnection.Static {
			new(): Http.DefaultHttpServerConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.EnglishReasonPhraseCatalog
	 * English reason phrases for HTTP status codes.
	 * All status codes defined in RFC1945 (HTTP/1.0), RFC2616 (HTTP/1.1), and
	 * RFC2518 (WebDAV) are supported.
	 *
	 * @since 4.0
	 */
	export interface EnglishReasonPhraseCatalog extends Java.Object, Http.ReasonPhraseCatalog {
		/**
		 * Obtains the reason phrase for a status code.
		 *
		 * @param status    the status code, in the range 100-599
		 * @param loc       ignored
		 *
		 * @return  the reason phrase, or {@code null}
		 */
		getReason(status: int, loc: Java.Locale): string;
	}
	export module EnglishReasonPhraseCatalog {
		/**
		 * Corresponding Java class: org.apache.http.impl.EnglishReasonPhraseCatalog
		 * English reason phrases for HTTP status codes.
		 * All status codes defined in RFC1945 (HTTP/1.0), RFC2616 (HTTP/1.1), and
		 * RFC2518 (WebDAV) are supported.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.ReasonPhraseCatalog.Static {
			new(): Http.EnglishReasonPhraseCatalog;
			/**
			 * The default instance of this catalog.
			 * This catalog is thread safe, so there typically
			 * is no need to create other instances.
			 */
			INSTANCE?: Http.EnglishReasonPhraseCatalog;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.BasicHttpProcessor
	 * Default implementation of {@link HttpProcessor}.
	 * 
	 * Please note access to the internal structures of this class is not
	 * synchronized and therefore this class may be thread-unsafe.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3)
	 */
	export interface BasicHttpProcessor extends Java.Object, Http.HttpProcessor, Http.HttpRequestInterceptorList, Http.HttpResponseInterceptorList, Java.Cloneable {
	}
	export module BasicHttpProcessor {
		/**
		 * Corresponding Java class: org.apache.http.protocol.BasicHttpProcessor
		 * Default implementation of {@link HttpProcessor}.
		 * 
		 * Please note access to the internal structures of this class is not
		 * synchronized and therefore this class may be thread-unsafe.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3)
		 */
		export interface Static extends Java.Object.Static, Http.HttpProcessor.Static, Http.HttpRequestInterceptorList.Static, Http.HttpResponseInterceptorList.Static, Java.Cloneable.Static {
			new(): Http.BasicHttpProcessor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.entity.EntityDeserializer
	 * HTTP entity deserializer.
	 * 
	 * This entity deserializer supports "chunked" and "identitiy" transfer-coding
	 * and content length delimited content.
	 * 
	 * This class relies on a specific implementation of
	 * {@link ContentLengthStrategy} to determine the content length or transfer
	 * encoding of the entity.
	 * 
	 * This class generates an instance of {@link HttpEntity} based on
	 * properties of the message. The content of the entity will be decoded
	 * transparently for the consumer.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.impl.BHttpConnectionBase}
	 */
	export interface EntityDeserializer extends Java.Object {
	}
	export module EntityDeserializer {
		/**
		 * Corresponding Java class: org.apache.http.impl.entity.EntityDeserializer
		 * HTTP entity deserializer.
		 * 
		 * This entity deserializer supports "chunked" and "identitiy" transfer-coding
		 * and content length delimited content.
		 * 
		 * This class relies on a specific implementation of
		 * {@link ContentLengthStrategy} to determine the content length or transfer
		 * encoding of the entity.
		 * 
		 * This class generates an instance of {@link HttpEntity} based on
		 * properties of the message. The content of the entity will be decoded
		 * transparently for the consumer.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.impl.BHttpConnectionBase}
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.EntityDeserializer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.entity.DisallowIdentityContentLengthStrategy
	 * Decorator for  {@link ContentLengthStrategy} implementations that disallows the use of
	 * identity transfer encoding.
	 *
	 * @since 4.2
	 */
	export interface DisallowIdentityContentLengthStrategy extends Java.Object, Http.ContentLengthStrategy {
		determineLength(message: Http.HttpMessage): long;
	}
	export module DisallowIdentityContentLengthStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.entity.DisallowIdentityContentLengthStrategy
		 * Decorator for  {@link ContentLengthStrategy} implementations that disallows the use of
		 * identity transfer encoding.
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Http.ContentLengthStrategy.Static {
			new(contentLengthStrategy: Http.ContentLengthStrategy): Http.DisallowIdentityContentLengthStrategy;
			INSTANCE?: Http.DisallowIdentityContentLengthStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.entity.LaxContentLengthStrategy
	 * The lax implementation of the content length strategy. This class will ignore
	 * unrecognized transfer encodings and malformed {@code Content-Length}
	 * header values.
	 * 
	 * This class recognizes "chunked" and "identitiy" transfer-coding only.
	 *
	 * @since 4.0
	 */
	export interface LaxContentLengthStrategy extends Java.Object, Http.ContentLengthStrategy {
		determineLength(message: Http.HttpMessage): long;
	}
	export module LaxContentLengthStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.entity.LaxContentLengthStrategy
		 * The lax implementation of the content length strategy. This class will ignore
		 * unrecognized transfer encodings and malformed {@code Content-Length}
		 * header values.
		 * 
		 * This class recognizes "chunked" and "identitiy" transfer-coding only.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.ContentLengthStrategy.Static {
			/**
			 * Creates {@code LaxContentLengthStrategy} instance with the given length used per default
			 * when content length is not explicitly specified in the message.
			 *
			 * @param implicitLen implicit content length.
			 *
			 * @since 4.2
			 */
			new(implicitLen: int): Http.LaxContentLengthStrategy;
			/**
			 * Creates {@code LaxContentLengthStrategy} instance. {@link ContentLengthStrategy#IDENTITY}
			 * is used per default when content length is not explicitly specified in the message.
			 */
			new(): Http.LaxContentLengthStrategy;
			INSTANCE?: Http.LaxContentLengthStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.entity.StrictContentLengthStrategy
	 * The strict implementation of the content length strategy. This class
	 * will throw {@link ProtocolException} if it encounters an unsupported
	 * transfer encoding or a malformed {@code Content-Length} header
	 * value.
	 * 
	 * This class recognizes "chunked" and "identitiy" transfer-coding only.
	 *
	 * @since 4.0
	 */
	export interface StrictContentLengthStrategy extends Java.Object, Http.ContentLengthStrategy {
		determineLength(message: Http.HttpMessage): long;
	}
	export module StrictContentLengthStrategy {
		/**
		 * Corresponding Java class: org.apache.http.impl.entity.StrictContentLengthStrategy
		 * The strict implementation of the content length strategy. This class
		 * will throw {@link ProtocolException} if it encounters an unsupported
		 * transfer encoding or a malformed {@code Content-Length} header
		 * value.
		 * 
		 * This class recognizes "chunked" and "identitiy" transfer-coding only.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.ContentLengthStrategy.Static {
			/**
			 * Creates {@code StrictContentLengthStrategy} instance with the given length used per default
			 * when content length is not explicitly specified in the message.
			 *
			 * @param implicitLen implicit content length.
			 *
			 * @since 4.2
			 */
			new(implicitLen: int): Http.StrictContentLengthStrategy;
			/**
			 * Creates {@code StrictContentLengthStrategy} instance. {@link ContentLengthStrategy#IDENTITY}
			 * is used per default when content length is not explicitly specified in the message.
			 */
			new(): Http.StrictContentLengthStrategy;
			INSTANCE?: Http.StrictContentLengthStrategy;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.HttpConnectionMetricsImpl
	 * Default implementation of the {@link HttpConnectionMetrics} interface.
	 *
	 * @since 4.0
	 */
	export interface HttpConnectionMetricsImpl extends Java.Object, Http.HttpConnectionMetrics {
		getMetric(metricName: string): obj;
		getReceivedBytesCount(): long;
		getRequestCount(): long;
		getResponseCount(): long;
		getSentBytesCount(): long;
		incrementRequestCount(): void;
		incrementResponseCount(): void;
		reset(): void;
		setMetric(metricName: string, obj: obj): void;
	}
	export module HttpConnectionMetricsImpl {
		/**
		 * Corresponding Java class: org.apache.http.impl.HttpConnectionMetricsImpl
		 * Default implementation of the {@link HttpConnectionMetrics} interface.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpConnectionMetrics.Static {
			new(inTransportMetric: Http.HttpTransportMetrics, outTransportMetric: Http.HttpTransportMetrics): Http.HttpConnectionMetricsImpl;
			REQUEST_COUNT?: string;
			RESPONSE_COUNT?: string;
			SENT_BYTES_COUNT?: string;
			RECEIVED_BYTES_COUNT?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.AbstractMessageParser
	 * Abstract base class for HTTP message parsers that obtain input from
	 * an instance of {@link SessionInputBuffer}.
	 *
	 * @since 4.0
	 */
	export interface AbstractMessageParser<T extends HttpMessage = any> extends Java.Object, Http.HttpMessageParser<T> {
		parse(): T;
	}
	export module AbstractMessageParser {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.AbstractMessageParser
		 * Abstract base class for HTTP message parsers that obtain input from
		 * an instance of {@link SessionInputBuffer}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpMessageParser.Static {
			/**
			 * Creates new instance of AbstractMessageParser.
			 *
			 * @param buffer the session input buffer.
			 * @param lineParser the line parser. If {@code null} {@link BasicLineParser#INSTANCE}
			 *   will be used.
			 * @param constraints the message constraints. If {@code null}
			 *   {@link MessageConstraints#DEFAULT} will be used.
			 *
			 * @since 4.3
			 */
			new <T extends HttpMessage>(buffer: Http.SessionInputBuffer, lineParser: Http.LineParser, constraints: Http.MessageConstraints): Http.AbstractMessageParser<T>;
			/**
			 * Parses HTTP headers from the data receiver stream according to the generic
			 * format as given in Section 3.1 of RFC 822, RFC-2616 Section 4 and 19.3.
			 *
			 * @param inbuffer Session input buffer
			 * @param maxHeaderCount maximum number of headers allowed. If the number
			 *  of headers received from the data stream exceeds maxCount value, an
			 *  IOException will be thrown. Setting this parameter to a negative value
			 *  or zero will disable the check.
			 * @param maxLineLen maximum number of characters for a header line,
			 *  including the continuation lines. Setting this parameter to a negative
			 *  value or zero will disable the check.
			 * @return array of HTTP headers
			 * @param parser line parser to use. Can be {@code null}, in which case
			 *  the default implementation of this interface will be used.
			 *
			 * @throws IOException in case of an I/O error
			 * @throws HttpException in case of HTTP protocol violation
			 */
			parseHeaders(inbuffer: Http.SessionInputBuffer, maxHeaderCount: int, maxLineLen: int, parser: Http.LineParser): array<Http.Header>;
			/**
			 * Parses HTTP headers from the data receiver stream according to the generic
			 * format as given in Section 3.1 of RFC 822, RFC-2616 Section 4 and 19.3.
			 *
			 * @param inbuffer Session input buffer
			 * @param maxHeaderCount maximum number of headers allowed. If the number
			 *  of headers received from the data stream exceeds maxCount value, an
			 *  IOException will be thrown. Setting this parameter to a negative value
			 *  or zero will disable the check.
			 * @param maxLineLen maximum number of characters for a header line,
			 *  including the continuation lines. Setting this parameter to a negative
			 *  value or zero will disable the check.
			 * @param parser line parser to use.
			 * @param headerLines List of header lines. This list will be used to store
			 *   intermediate results. This makes it possible to resume parsing of
			 *   headers in case of a {@link java.io.InterruptedIOException}.
			 *
			 * @return array of HTTP headers
			 *
			 * @throws IOException in case of an I/O error
			 * @throws HttpException in case of HTTP protocol violation
			 *
			 * @since 4.1
			 */
			parseHeaders(inbuffer: Http.SessionInputBuffer, maxHeaderCount: int, maxLineLen: int, parser: Http.LineParser, headerLines: Java.List<Http.CharArrayBuffer>): array<Http.Header>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.AbstractMessageWriter
	 * Abstract base class for HTTP message writers that serialize output to
	 * an instance of {@link SessionOutputBuffer}.
	 *
	 * @since 4.0
	 */
	export interface AbstractMessageWriter<T extends HttpMessage = any> extends Java.Object, Http.HttpMessageWriter<T> {
		write(message: T): void;
	}
	export module AbstractMessageWriter {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.AbstractMessageWriter
		 * Abstract base class for HTTP message writers that serialize output to
		 * an instance of {@link SessionOutputBuffer}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpMessageWriter.Static {
			/**
			 * Creates an instance of AbstractMessageWriter.
			 *
			 * @param buffer the session output buffer.
			 * @param formatter the line formatter If {@code null} {@link BasicLineFormatter#INSTANCE}
			 *   will be used.
			 *
			 * @since 4.3
			 */
			new <T extends HttpMessage>(buffer: Http.SessionOutputBuffer, formatter: Http.LineFormatter): Http.AbstractMessageWriter<T>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.AbstractSessionInputBuffer
	 * Abstract base class for session input buffers that stream data from
	 * an arbitrary {@link InputStream}. This class buffers input data in
	 * an internal byte array for optimal input performance.
	 * 
	 * {@link #readLine(CharArrayBuffer)} and {@link #readLine()} methods of this
	 * class treat a lone LF as valid line delimiters in addition to CR-LF required
	 * by the HTTP specification.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link SessionInputBufferImpl}
	 */
	export interface AbstractSessionInputBuffer extends Java.Object, Http.SessionInputBuffer, Http.BufferInfo {
	}
	export module AbstractSessionInputBuffer {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.AbstractSessionInputBuffer
		 * Abstract base class for session input buffers that stream data from
		 * an arbitrary {@link InputStream}. This class buffers input data in
		 * an internal byte array for optimal input performance.
		 * 
		 * {@link #readLine(CharArrayBuffer)} and {@link #readLine()} methods of this
		 * class treat a lone LF as valid line delimiters in addition to CR-LF required
		 * by the HTTP specification.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link SessionInputBufferImpl}
		 */
		export interface Static extends Java.Object.Static, Http.SessionInputBuffer.Static, Http.BufferInfo.Static {
			new(): Http.AbstractSessionInputBuffer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.AbstractHttpMessage
	 * Basic implementation of {@link HttpMessage}.
	 *
	 * @since 4.0
	 */
	export interface AbstractHttpMessage extends Java.Object, Http.HttpMessage {
		addHeader(header: Http.Header): void;
		addHeader(name: string, value: string): void;
		containsHeader(name: string): boolean;
		getAllHeaders(): array<Http.Header>;
		getFirstHeader(name: string): Http.Header;
		getHeaders(name: string): array<Http.Header>;
		getLastHeader(name: string): Http.Header;
		headerIterator(): Http.HeaderIterator;
		headerIterator(name: string): Http.HeaderIterator;
		removeHeader(header: Http.Header): void;
		removeHeaders(name: string): void;
		setHeader(header: Http.Header): void;
		setHeader(name: string, value: string): void;
		setHeaders(headers: array<Http.Header>): void;
	}
	export module AbstractHttpMessage {
		/**
		 * Corresponding Java class: org.apache.http.message.AbstractHttpMessage
		 * Basic implementation of {@link HttpMessage}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpMessage.Static {
			new(): Http.AbstractHttpMessage;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicHeaderValueFormatter
	 * Basic implementation for formatting header value elements.
	 * Instances of this class are stateless and thread-safe.
	 * Derived classes are expected to maintain these properties.
	 *
	 * @since 4.0
	 */
	export interface BasicHeaderValueFormatter extends Java.Object, Http.HeaderValueFormatter {
		formatElements(charBuffer: Http.CharArrayBuffer, elems: array<Http.HeaderElement>, quote: boolean): Http.CharArrayBuffer;
		formatHeaderElement(charBuffer: Http.CharArrayBuffer, elem: Http.HeaderElement, quote: boolean): Http.CharArrayBuffer;
		formatNameValuePair(charBuffer: Http.CharArrayBuffer, nvp: Http.NameValuePair, quote: boolean): Http.CharArrayBuffer;
		formatParameters(charBuffer: Http.CharArrayBuffer, nvps: array<Http.NameValuePair>, quote: boolean): Http.CharArrayBuffer;
	}
	export module BasicHeaderValueFormatter {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicHeaderValueFormatter
		 * Basic implementation for formatting header value elements.
		 * Instances of this class are stateless and thread-safe.
		 * Derived classes are expected to maintain these properties.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HeaderValueFormatter.Static {
			new(): Http.BasicHeaderValueFormatter;
			INSTANCE?: Http.BasicHeaderValueFormatter;
			/**
			 * Special characters that can be used as separators in HTTP parameters.
			 * These special characters MUST be in a quoted string to be used within
			 * a parameter value .
			 */
			SEPARATORS?: string;
			/**
			 * Unsafe special characters that must be escaped using the backslash
			 * character
			 */
			UNSAFE_CHARS?: string;
			/**
			 * Formats an array of header elements.
			 *
			 * @param elems     the header elements to format
			 * @param quote     {@code true} to always format with quoted values,
			 *                  {@code false} to use quotes only when necessary
			 * @param formatter         the formatter to use, or {@code null}
			 *                          for the {@link #INSTANCE default}
			 *
			 * @return  the formatted header elements
			 */
			formatElements(elems: array<Http.HeaderElement>, quote: boolean, formatter: Http.HeaderValueFormatter): string;
			/**
			 * Formats a header element.
			 *
			 * @param elem      the header element to format
			 * @param quote     {@code true} to always format with quoted values,
			 *                  {@code false} to use quotes only when necessary
			 * @param formatter         the formatter to use, or {@code null}
			 *                          for the {@link #INSTANCE default}
			 *
			 * @return  the formatted header element
			 */
			formatHeaderElement(elem: Http.HeaderElement, quote: boolean, formatter: Http.HeaderValueFormatter): string;
			/**
			 * Formats a name-value pair.
			 *
			 * @param nvp       the name-value pair to format
			 * @param quote     {@code true} to always format with a quoted value,
			 *                  {@code false} to use quotes only when necessary
			 * @param formatter         the formatter to use, or {@code null}
			 *                          for the {@link #INSTANCE default}
			 *
			 * @return  the formatted name-value pair
			 */
			formatNameValuePair(nvp: Http.NameValuePair, quote: boolean, formatter: Http.HeaderValueFormatter): string;
			/**
			 * Formats a set of parameters.
			 *
			 * @param nvps      the parameters to format
			 * @param quote     {@code true} to always format with quoted values,
			 *                  {@code false} to use quotes only when necessary
			 * @param formatter         the formatter to use, or {@code null}
			 *                          for the {@link #INSTANCE default}
			 *
			 * @return  the formatted parameters
			 */
			formatParameters(nvps: array<Http.NameValuePair>, quote: boolean, formatter: Http.HeaderValueFormatter): string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicHttpResponse
	 * Basic implementation of {@link HttpResponse}.
	 *
	 * @see org.apache.http.impl.DefaultHttpResponseFactory
	 *
	 * @since 4.0
	 */
	export interface BasicHttpResponse extends Http.AbstractHttpMessage, Http.HttpResponse {
		getEntity(): Http.HttpEntity;
		getLocale(): Java.Locale;
		getProtocolVersion(): Http.ProtocolVersion;
		getStatusLine(): Http.StatusLine;
		setEntity(entity: Http.HttpEntity): void;
		setLocale(locale: Java.Locale): void;
		setReasonPhrase(reason: string): void;
		setStatusCode(code: int): void;
		setStatusLine(statusline: Http.StatusLine): void;
		setStatusLine(ver: Http.ProtocolVersion, code: int): void;
		setStatusLine(ver: Http.ProtocolVersion, code: int, reason: string): void;
		toString(): string;
	}
	export module BasicHttpResponse {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicHttpResponse
		 * Basic implementation of {@link HttpResponse}.
		 *
		 * @see org.apache.http.impl.DefaultHttpResponseFactory
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.AbstractHttpMessage.Static, Http.HttpResponse.Static {
			/**
			 * Creates a new response.
			 * This is the constructor to which all others map.
			 *
			 * @param statusline        the status line
			 * @param catalog           the reason phrase catalog, or
			 *                          {@code null} to disable automatic
			 *                          reason phrase lookup
			 * @param locale            the locale for looking up reason phrases, or
			 *                          {@code null} for the system locale
			 */
			new(statusline: Http.StatusLine, catalog: Http.ReasonPhraseCatalog, locale: Java.Locale): Http.BasicHttpResponse;
			/**
			 * Creates a response from a status line.
			 * The response will not have a reason phrase catalog and
			 * use the system default locale.
			 *
			 * @param statusline        the status line
			 */
			new(statusline: Http.StatusLine): Http.BasicHttpResponse;
			/**
			 * Creates a response from elements of a status line.
			 * The response will not have a reason phrase catalog and
			 * use the system default locale.
			 *
			 * @param ver       the protocol version of the response
			 * @param code      the status code of the response
			 * @param reason    the reason phrase to the status code, or
			 *                  {@code null}
			 */
			new(ver: Http.ProtocolVersion, code: int, reason: string): Http.BasicHttpResponse;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicNameValuePair
	 * Basic implementation of {@link NameValuePair}.
	 *
	 * @since 4.0
	 */
	export interface BasicNameValuePair extends Java.Object, Http.NameValuePair, Java.Cloneable, Java.Serializable {
		clone(): obj;
		equals(object: obj): boolean;
		getName(): string;
		getValue(): string;
		hashCode(): int;
		toString(): string;
	}
	export module BasicNameValuePair {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicNameValuePair
		 * Basic implementation of {@link NameValuePair}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.NameValuePair.Static, Java.Cloneable.Static, Java.Serializable.Static {
			/**
			 * Default Constructor taking a name and a value. The value may be null.
			 *
			 * @param name The name.
			 * @param value The value.
			 */
			new(name: string, value: string): Http.BasicNameValuePair;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BufferedHeader
	 * This class represents a raw HTTP header whose content is parsed 'on demand'
	 * only when the header value needs to be consumed.
	 *
	 * @since 4.0
	 */
	export interface BufferedHeader extends Java.Object, Http.FormattedHeader, Java.Cloneable, Java.Serializable {
		clone(): obj;
		getBuffer(): Http.CharArrayBuffer;
		getElements(): array<Http.HeaderElement>;
		getName(): string;
		getValue(): string;
		getValuePos(): int;
		toString(): string;
	}
	export module BufferedHeader {
		/**
		 * Corresponding Java class: org.apache.http.message.BufferedHeader
		 * This class represents a raw HTTP header whose content is parsed 'on demand'
		 * only when the header value needs to be consumed.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.FormattedHeader.Static, Java.Cloneable.Static, Java.Serializable.Static {
			/**
			 * Creates a new header from a buffer.
			 * The name of the header will be parsed immediately,
			 * the value only if it is accessed.
			 *
			 * @param buffer    the buffer containing the header to represent
			 *
			 * @throws ParseException   in case of a parse error
			 */
			new(buffer: Http.CharArrayBuffer): Http.BufferedHeader;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.LineParser
	 * Interface for parsing lines in the HEAD section of an HTTP message.
	 * There are individual methods for parsing a request line, a
	 * status line, or a header line.
	 * The lines to parse are passed in memory, the parser does not depend
	 * on any specific IO mechanism.
	 * Instances of this interface are expected to be stateless and thread-safe.
	 *
	 * @since 4.0
	 */
	export interface LineParser extends Java.Object {
		/**
		 * Checks whether there likely is a protocol version in a line.
		 * This method implements a heuristic to check for a
		 * likely protocol version specification. It does not
		 * guarantee that {@link #parseProtocolVersion} would not
		 * detect a parse error.
		 * This can be used to detect garbage lines before a request
		 * or status line.
		 *
		 * @param buffer    a buffer holding the line to inspect
		 * @param cursor    the cursor at which to check for a protocol version, or
		 *                  negative for "end of line". Whether the check tolerates
		 *                  whitespace before or after the protocol version is
		 *                  implementation dependent.
		 *
		 * @return  {@code true} if there is a protocol version at the
		 *          argument index (possibly ignoring whitespace),
		 *          {@code false} otherwise
		 */
		hasProtocolVersion(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): boolean;
		/**
		 * Creates a header from a line.
		 * The full header line is expected here. Header continuation lines
		 * must be joined by the caller before invoking this method.
		 *
		 * @param buffer    a buffer holding the full header line.
		 *                  This buffer MUST NOT be re-used afterwards, since
		 *                  the returned object may reference the contents later.
		 *
		 * @return  the header in the argument buffer.
		 *          The returned object MAY be a wrapper for the argument buffer.
		 *          The argument buffer MUST NOT be re-used or changed afterwards.
		 *
		 * @throws ParseException        in case of a parse error
		 */
		parseHeader(buffer: Http.CharArrayBuffer): Http.Header;
		/**
		 * Parses the textual representation of a protocol version.
		 * This is needed for parsing request lines (last element)
		 * as well as status lines (first element).
		 *
		 * @param buffer    a buffer holding the protocol version to parse
		 * @param cursor    the parser cursor containing the current position and
		 *                  the bounds within the buffer for the parsing operation
		 *
		 * @return  the parsed protocol version
		 *
		 * @throws ParseException        in case of a parse error
		 */
		parseProtocolVersion(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.ProtocolVersion;
		/**
		 * Parses a request line.
		 *
		 * @param buffer    a buffer holding the line to parse
		 * @param cursor    the parser cursor containing the current position and
		 *                  the bounds within the buffer for the parsing operation
		 *
		 * @return  the parsed request line
		 *
		 * @throws ParseException        in case of a parse error
		 */
		parseRequestLine(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.RequestLine;
		/**
		 * Parses a status line.
		 *
		 * @param buffer    a buffer holding the line to parse
		 * @param cursor    the parser cursor containing the current position and
		 *                  the bounds within the buffer for the parsing operation
		 *
		 * @return  the parsed status line
		 *
		 * @throws ParseException        in case of a parse error
		 */
		parseStatusLine(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.StatusLine;
	}
	export module LineParser {
		/**
		 * Corresponding Java class: org.apache.http.message.LineParser
		 * Interface for parsing lines in the HEAD section of an HTTP message.
		 * There are individual methods for parsing a request line, a
		 * status line, or a header line.
		 * The lines to parse are passed in memory, the parser does not depend
		 * on any specific IO mechanism.
		 * Instances of this interface are expected to be stateless and thread-safe.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.MessageConstraintException
	 * Signals a message constraint violation.
	 *
	 * @since 4.3
	 */
	export interface MessageConstraintException extends Java.CharacterCodingException {
		getMessage(): string;
	}
	export module MessageConstraintException {
		/**
		 * Corresponding Java class: org.apache.http.MessageConstraintException
		 * Signals a message constraint violation.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.CharacterCodingException.Static {
			/**
			 * Creates a TruncatedChunkException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.MessageConstraintException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.NameValuePair
	 * A name / value pair parameter used as an element of HTTP messages.
	 * 
	 * parameter               = attribute "=" value
	 * attribute               = token
	 * value                   = token | quoted-string
	 * 
	 *
	 *
	 * @since 4.0
	 */
	export interface NameValuePair extends Java.Object {
		getName(): string;
		getValue(): string;
	}
	export module NameValuePair {
		/**
		 * Corresponding Java class: org.apache.http.NameValuePair
		 * A name / value pair parameter used as an element of HTTP messages.
		 * 
		 * parameter               = attribute "=" value
		 * attribute               = token
		 * value                   = token | quoted-string
		 * 
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.AbstractHttpParams
	 * Abstract base class for parameter collections.
	 * Type specific setters and getters are mapped to the abstract,
	 * generic getters and setters.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface AbstractHttpParams extends Java.Object, Http.HttpParams, Http.HttpParamsNames {
	}
	export module AbstractHttpParams {
		/**
		 * Corresponding Java class: org.apache.http.params.AbstractHttpParams
		 * Abstract base class for parameter collections.
		 * Type specific setters and getters are mapped to the abstract,
		 * generic getters and setters.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Java.Object.Static, Http.HttpParams.Static, Http.HttpParamsNames.Static {
			new(): Http.AbstractHttpParams;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.HttpConnectionParamBean
	 * This is a Java Bean class that can be used to wrap an instance of
	 * {@link HttpParams} and manipulate HTTP connection parameters using Java Beans
	 * conventions.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface HttpConnectionParamBean extends Http.HttpAbstractParamBean {
	}
	export module HttpConnectionParamBean {
		/**
		 * Corresponding Java class: org.apache.http.params.HttpConnectionParamBean
		 * This is a Java Bean class that can be used to wrap an instance of
		 * {@link HttpParams} and manipulate HTTP connection parameters using Java Beans
		 * conventions.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Http.HttpAbstractParamBean.Static {
			new(): Http.HttpConnectionParamBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.HttpParamConfig
	 * @deprecated (4.3) provided for compatibility with {@link HttpParams}. Do not use.
	 *
	 * @since 4.3
	 */
	export interface HttpParamConfig extends Java.Object {
	}
	export module HttpParamConfig {
		/**
		 * Corresponding Java class: org.apache.http.params.HttpParamConfig
		 * @deprecated (4.3) provided for compatibility with {@link HttpParams}. Do not use.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.HttpProtocolParams
	 * Utility class for accessing protocol parameters in {@link HttpParams}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface HttpProtocolParams extends Java.Object, Http.CoreProtocolPNames {
	}
	export module HttpProtocolParams {
		/**
		 * Corresponding Java class: org.apache.http.params.HttpProtocolParams
		 * Utility class for accessing protocol parameters in {@link HttpParams}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Java.Object.Static, Http.CoreProtocolPNames.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.pool.ConnFactory
	 * Factory for poolable blocking connections.
	 *
	 * @param  the route type that represents the opposite endpoint of a pooled
	 *   connection.
	 * @param  the connection type.
	 * @since 4.2
	 */
	export interface ConnFactory<T = any, C = any> extends Java.Object {
		create(route: T): C;
	}
	export module ConnFactory {
		/**
		 * Corresponding Java class: org.apache.http.pool.ConnFactory
		 * Factory for poolable blocking connections.
		 *
		 * @param  the route type that represents the opposite endpoint of a pooled
		 *   connection.
		 * @param  the connection type.
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.pool.PoolEntry
	 * Pool entry containing a pool connection object along with its route.
	 * 
	 * The connection contained by the pool entry may have an expiration time which
	 * can be either set upon construction time or updated with
	 * the {@link #updateExpiry(long, TimeUnit)}.
	 * 
	 * Pool entry may also have an object associated with it that represents
	 * a connection state (usually a security principal or a unique token identifying
	 * the user whose credentials have been used while establishing the connection).
	 *
	 * @param  the route type that represents the opposite endpoint of a pooled
	 *   connection.
	 * @param  the connection type.
	 * @since 4.2
	 */
	export interface PoolEntry<T = any, C = any> extends Java.Object {
		/**
		 * Invalidates the pool entry and closes the pooled connection associated
		 * with it.
		 */
		close(): void;
		getConnection(): C;
		getCreated(): long;
		getExpiry(): long;
		getId(): string;
		getRoute(): T;
		getState(): obj;
		getUpdated(): long;
		/**
		 * @since 4.4
		 */
		getValidityDeadline(): long;
		/**
		 * Returns {@code true} if the pool entry has been invalidated.
		 */
		isClosed(): boolean;
		isExpired(now: long): boolean;
		setState(state: obj): void;
		toString(): string;
		updateExpiry(time: long, tunit: Java.TimeUnit): void;
	}
	export module PoolEntry {
		/**
		 * Corresponding Java class: org.apache.http.pool.PoolEntry
		 * Pool entry containing a pool connection object along with its route.
		 * 
		 * The connection contained by the pool entry may have an expiration time which
		 * can be either set upon construction time or updated with
		 * the {@link #updateExpiry(long, TimeUnit)}.
		 * 
		 * Pool entry may also have an object associated with it that represents
		 * a connection state (usually a security principal or a unique token identifying
		 * the user whose credentials have been used while establishing the connection).
		 *
		 * @param  the route type that represents the opposite endpoint of a pooled
		 *   connection.
		 * @param  the connection type.
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Creates new {@code PoolEntry} instance.
			 *
			 * @param id unique identifier of the pool entry. May be {@code null}.
			 * @param route route to the opposite endpoint.
			 * @param conn the connection.
			 * @param timeToLive maximum time to live. May be zero if the connection
			 *   does not have an expiry deadline.
			 * @param tunit time unit.
			 */
			new <T, C>(id: string, route: T, conn: C, timeToLive: long, tunit: Java.TimeUnit): Http.PoolEntry<T, C>;
			/**
			 * Creates new {@code PoolEntry} instance without an expiry deadline.
			 *
			 * @param id unique identifier of the pool entry. May be {@code null}.
			 * @param route route to the opposite endpoint.
			 * @param conn the connection.
			 */
			new <T, C>(id: string, route: T, conn: C): Http.PoolEntry<T, C>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.BasicHttpContext
	 * Default implementation of {@link HttpContext}.
	 * 
	 * Please note instances of this class can be thread unsafe if the
	 * parent context is not thread safe.
	 *
	 * @since 4.0
	 */
	export interface BasicHttpContext extends Java.Object, Http.HttpContext {
		/**
		 * @since 4.2
		 */
		clear(): void;
		getAttribute(id: string): obj;
		removeAttribute(id: string): obj;
		setAttribute(id: string, obj: obj): void;
		toString(): string;
	}
	export module BasicHttpContext {
		/**
		 * Corresponding Java class: org.apache.http.protocol.BasicHttpContext
		 * Default implementation of {@link HttpContext}.
		 * 
		 * Please note instances of this class can be thread unsafe if the
		 * parent context is not thread safe.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpContext.Static {
			new(): Http.BasicHttpContext;
			new(parentContext: Http.HttpContext): Http.BasicHttpContext;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.ExecutionContext
	 * {@link HttpContext} attribute names for protocol execution.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link HttpCoreContext}.
	 */
	export interface ExecutionContext extends Java.Object {
	}
	export module ExecutionContext {
		/**
		 * Corresponding Java class: org.apache.http.protocol.ExecutionContext
		 * {@link HttpContext} attribute names for protocol execution.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link HttpCoreContext}.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpDateGenerator
	 * Generates a date in the format required by the HTTP protocol.
	 *
	 * @since 4.0
	 */
	export interface HttpDateGenerator extends Java.Object {
		getCurrentDate(): string;
	}
	export module HttpDateGenerator {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpDateGenerator
		 * Generates a date in the format required by the HTTP protocol.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.HttpDateGenerator;
			/**
			 Date format pattern used to generate the header in RFC 1123 format.
			 */
			PATTERN_RFC1123?: string;
			/**
			 The time zone to use in the date header.
			 */
			GMT?: Java.TimeZone;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpRequestExecutor
	 * {@code HttpRequestExecutor} is a client side HTTP protocol handler based
	 * on the blocking (classic) I/O model.
	 * 
	 * {@code HttpRequestExecutor} relies on {@link HttpProcessor} to generate
	 * mandatory protocol headers for all outgoing messages and apply common,
	 * cross-cutting message transformations to all incoming and outgoing messages.
	 * Application specific processing can be implemented outside
	 * {@code HttpRequestExecutor} once the request has been executed and
	 * a response has been received.
	 *
	 * @since 4.0
	 */
	export interface HttpRequestExecutor extends Java.Object {
		/**
		 * Sends the request and obtain a response.
		 *
		 * @param request   the request to execute.
		 * @param conn      the connection over which to execute the request.
		 *
		 * @return  the response to the request.
		 *
		 * @throws IOException in case of an I/O error.
		 * @throws HttpException in case of HTTP protocol violation or a processing
		 *   problem.
		 */
		execute(request: Http.HttpRequest, conn: Http.HttpClientConnection, context: Http.HttpContext): Http.HttpResponse;
		/**
		 * Post-processes the given response using the given protocol processor and
		 * completes the process of request execution.
		 * 
		 * This method does not read the response entity, if any.
		 * The connection over which content of the response entity is being
		 * streamed from cannot be reused until
		 * {@link org.apache.http.util.EntityUtils#consume(org.apache.http.HttpEntity)}
		 * has been invoked.
		 *
		 * @param response  the response object to post-process
		 * @param processor the processor to use
		 * @param context   the context for post-processing the response
		 *
		 * @throws IOException in case of an I/O error.
		 * @throws HttpException in case of HTTP protocol violation or a processing
		 *   problem.
		 */
		postProcess(response: Http.HttpResponse, processor: Http.HttpProcessor, context: Http.HttpContext): void;
		/**
		 * Pre-process the given request using the given protocol processor and
		 * initiates the process of request execution.
		 *
		 * @param request   the request to prepare
		 * @param processor the processor to use
		 * @param context   the context for sending the request
		 *
		 * @throws IOException in case of an I/O error.
		 * @throws HttpException in case of HTTP protocol violation or a processing
		 *   problem.
		 */
		preProcess(request: Http.HttpRequest, processor: Http.HttpProcessor, context: Http.HttpContext): void;
	}
	export module HttpRequestExecutor {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpRequestExecutor
		 * {@code HttpRequestExecutor} is a client side HTTP protocol handler based
		 * on the blocking (classic) I/O model.
		 * 
		 * {@code HttpRequestExecutor} relies on {@link HttpProcessor} to generate
		 * mandatory protocol headers for all outgoing messages and apply common,
		 * cross-cutting message transformations to all incoming and outgoing messages.
		 * Application specific processing can be implemented outside
		 * {@code HttpRequestExecutor} once the request has been executed and
		 * a response has been received.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Creates new instance of HttpRequestExecutor.
			 *
			 * @since 4.3
			 */
			new(waitForContinue: int): Http.HttpRequestExecutor;
			new(): Http.HttpRequestExecutor;
			DEFAULT_WAIT_FOR_CONTINUE?: int;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpRequestHandlerResolver
	 * HttpRequestHandlerResolver can be used to resolve an instance of
	 * {@link HttpRequestHandler} matching a particular request URI. Usually the
	 * mapped request handler will be used to process the request with the
	 * specified request URI.
	 *
	 * @since 4.0
	 * @deprecated see {@link HttpRequestHandlerMapper}
	 */
	export interface HttpRequestHandlerResolver extends Java.Object {
	}
	export module HttpRequestHandlerResolver {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpRequestHandlerResolver
		 * HttpRequestHandlerResolver can be used to resolve an instance of
		 * {@link HttpRequestHandler} matching a particular request URI. Usually the
		 * mapped request handler will be used to process the request with the
		 * specified request URI.
		 *
		 * @since 4.0
		 * @deprecated see {@link HttpRequestHandlerMapper}
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.RequestContent
	 * RequestContent is the most important interceptor for outgoing requests.
	 * It is responsible for delimiting content length by adding
	 * {@code Content-Length} or {@code Transfer-Content} headers based
	 * on the properties of the enclosed entity and the protocol version.
	 * This interceptor is required for correct functioning of client side protocol
	 * processors.
	 *
	 * @since 4.0
	 */
	export interface RequestContent extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestContent {
		/**
		 * Corresponding Java class: org.apache.http.protocol.RequestContent
		 * RequestContent is the most important interceptor for outgoing requests.
		 * It is responsible for delimiting content length by adding
		 * {@code Content-Length} or {@code Transfer-Content} headers based
		 * on the properties of the enclosed entity and the protocol version.
		 * This interceptor is required for correct functioning of client side protocol
		 * processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			/**
			 * Default constructor. The {@code Content-Length} or {@code Transfer-Encoding}
			 * will cause the interceptor to throw {@link ProtocolException} if already present in the
			 * response message.
			 */
			new(): Http.RequestContent;
			/**
			 * Constructor that can be used to fine-tune behavior of this interceptor.
			 *
			 * @param overwrite If set to {@code true} the {@code Content-Length} and
			 * {@code Transfer-Encoding} headers will be created or updated if already present.
			 * If set to {@code false} the {@code Content-Length} and
			 * {@code Transfer-Encoding} headers will cause the interceptor to throw
			 * {@link ProtocolException} if already present in the response message.
			 *
			 * @since 4.2
			 */
			new(overwrite: boolean): Http.RequestContent;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.RequestUserAgent
	 * RequestUserAgent is responsible for adding {@code User-Agent} header.
	 * This interceptor is recommended for client side protocol processors.
	 *
	 * @since 4.0
	 */
	export interface RequestUserAgent extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestUserAgent {
		/**
		 * Corresponding Java class: org.apache.http.protocol.RequestUserAgent
		 * RequestUserAgent is responsible for adding {@code User-Agent} header.
		 * This interceptor is recommended for client side protocol processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			new(userAgent: string): Http.RequestUserAgent;
			new(): Http.RequestUserAgent;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.ResponseServer
	 * ResponseServer is responsible for adding {@code Server} header. This
	 * interceptor is recommended for server side protocol processors.
	 *
	 * @since 4.0
	 */
	export interface ResponseServer extends Java.Object, Http.HttpResponseInterceptor {
		process(response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module ResponseServer {
		/**
		 * Corresponding Java class: org.apache.http.protocol.ResponseServer
		 * ResponseServer is responsible for adding {@code Server} header. This
		 * interceptor is recommended for server side protocol processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpResponseInterceptor.Static {
			/**
			 * @since 4.3
			 */
			new(originServer: string): Http.ResponseServer;
			new(): Http.ResponseServer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ProtocolException
	 * Signals that an HTTP protocol violation has occurred.
	 * For example a malformed status line or headers, a missing message body, etc.
	 *
	 *
	 * @since 4.0
	 */
	export interface ProtocolException extends Http.HttpException {
	}
	export module ProtocolException {
		/**
		 * Corresponding Java class: org.apache.http.ProtocolException
		 * Signals that an HTTP protocol violation has occurred.
		 * For example a malformed status line or headers, a missing message body, etc.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpException.Static {
			/**
			 * Creates a new ProtocolException with a {@code null} detail message.
			 */
			new(): Http.ProtocolException;
			/**
			 * Creates a new ProtocolException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.ProtocolException;
			/**
			 * Creates a new ProtocolException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.ProtocolException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.entity.EntitySerializer
	 * HTTP entity serializer.
	 * 
	 * This entity serializer currently supports "chunked" and "identitiy"
	 * transfer-coding and content length delimited content.
	 * 
	 * This class relies on a specific implementation of
	 * {@link ContentLengthStrategy} to determine the content length or transfer
	 * encoding of the entity.
	 * 
	 * This class writes out the content of {@link HttpEntity} to the data stream
	 * using a transfer coding based on properties on the HTTP message.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link org.apache.http.impl.BHttpConnectionBase}
	 */
	export interface EntitySerializer extends Java.Object {
	}
	export module EntitySerializer {
		/**
		 * Corresponding Java class: org.apache.http.impl.entity.EntitySerializer
		 * HTTP entity serializer.
		 * 
		 * This entity serializer currently supports "chunked" and "identitiy"
		 * transfer-coding and content length delimited content.
		 * 
		 * This class relies on a specific implementation of
		 * {@link ContentLengthStrategy} to determine the content length or transfer
		 * encoding of the entity.
		 * 
		 * This class writes out the content of {@link HttpEntity} to the data stream
		 * using a transfer coding based on properties on the HTTP message.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link org.apache.http.impl.BHttpConnectionBase}
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.EntitySerializer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ssl.PrivateKeyDetails
	 * Private key details.
	 *
	 * @since 4.4
	 */
	export interface PrivateKeyDetails extends Java.Object {
		getCertChain(): array<Java.X509Certificate>;
		getType(): string;
		toString(): string;
	}
	export module PrivateKeyDetails {
		/**
		 * Corresponding Java class: org.apache.http.ssl.PrivateKeyDetails
		 * Private key details.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			new(type: string, certChain: array<Java.X509Certificate>): Http.PrivateKeyDetails;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ssl.TrustStrategy
	 * A strategy to establish trustworthiness of certificates without consulting the trust manager
	 * configured in the actual SSL context. This interface can be used to override the standard
	 * JSSE certificate verification process.
	 *
	 * @since 4.4
	 */
	export interface TrustStrategy extends Java.Object {
		/**
		 * Determines whether the certificate chain can be trusted without consulting the trust manager
		 * configured in the actual SSL context. This method can be used to override the standard JSSE
		 * certificate verification process.
		 * 
		 * Please note that, if this method returns {@code false}, the trust manager configured
		 * in the actual SSL context can still clear the certificate as trusted.
		 *
		 * @param chain the peer certificate chain
		 * @param authType the authentication type based on the client certificate
		 * @return {@code true} if the certificate can be trusted without verification by
		 *   the trust manager, {@code false} otherwise.
		 * @throws CertificateException thrown if the certificate is not trusted or invalid.
		 */
		isTrusted(chain: array<Java.X509Certificate>, authType: string): boolean;
	}
	export module TrustStrategy {
		/**
		 * Corresponding Java class: org.apache.http.ssl.TrustStrategy
		 * A strategy to establish trustworthiness of certificates without consulting the trust manager
		 * configured in the actual SSL context. This interface can be used to override the standard
		 * JSSE certificate verification process.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.StatusLine
	 * The first line of a Response message is the Status-Line, consisting
	 * of the protocol version followed by a numeric status code and its
	 * associated textual phrase, with each element separated by SP
	 * characters. No CR or LF is allowed except in the final CRLF sequence.
	 * 
	 *     Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
	 * 
	 *
	 * @see HttpStatus
	 * @version $Id$
	 *
	 * @since 4.0
	 */
	export interface StatusLine extends Java.Object {
		getProtocolVersion(): Http.ProtocolVersion;
		getReasonPhrase(): string;
		getStatusCode(): int;
	}
	export module StatusLine {
		/**
		 * Corresponding Java class: org.apache.http.StatusLine
		 * The first line of a Response message is the Status-Line, consisting
		 * of the protocol version followed by a numeric status code and its
		 * associated textual phrase, with each element separated by SP
		 * characters. No CR or LF is allowed except in the final CRLF sequence.
		 * 
		 *     Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
		 * 
		 *
		 * @see HttpStatus
		 * @version $Id$
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.TokenIterator
	 * An iterator for {@link String} tokens.
	 * This interface is designed as a complement to
	 * {@link HeaderElementIterator}, in cases where the items
	 * are plain strings rather than full header elements.
	 *
	 * @since 4.0
	 */
	export interface TokenIterator extends Java.Iterator<obj> {
		/**
		 * Indicates whether there is another token in this iteration.
		 *
		 * @return  {@code true} if there is another token,
		 *          {@code false} otherwise
		 */
		hasNext(): boolean;
		/**
		 * Obtains the next token from this iteration.
		 * This method should only be called while {@link #hasNext hasNext}
		 * is true.
		 *
		 * @return  the next token in this iteration
		 */
		nextToken(): string;
	}
	export module TokenIterator {
		/**
		 * Corresponding Java class: org.apache.http.TokenIterator
		 * An iterator for {@link String} tokens.
		 * This interface is designed as a complement to
		 * {@link HeaderElementIterator}, in cases where the items
		 * are plain strings rather than full header elements.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Iterator.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.TruncatedChunkException
	 * Signals a truncated chunk in a chunked stream.
	 *
	 * @since 4.1
	 */
	export interface TruncatedChunkException extends Http.MalformedChunkCodingException {
	}
	export module TruncatedChunkException {
		/**
		 * Corresponding Java class: org.apache.http.TruncatedChunkException
		 * Signals a truncated chunk in a chunked stream.
		 *
		 * @since 4.1
		 */
		export interface Static extends Http.MalformedChunkCodingException.Static {
			/**
			 * Creates a TruncatedChunkException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.TruncatedChunkException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.UnsupportedHttpVersionException
	 * Signals an unsupported version of the HTTP protocol.
	 *
	 * @since 4.0
	 */
	export interface UnsupportedHttpVersionException extends Http.ProtocolException {
	}
	export module UnsupportedHttpVersionException {
		/**
		 * Corresponding Java class: org.apache.http.UnsupportedHttpVersionException
		 * Signals an unsupported version of the HTTP protocol.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.ProtocolException.Static {
			/**
			 * Creates an exception without a detail message.
			 */
			new(): Http.UnsupportedHttpVersionException;
			/**
			 * Creates an exception with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.UnsupportedHttpVersionException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ssl.SSLInitializationException
	 */
	export interface SSLInitializationException extends Java.IllegalStateException {
	}
	export module SSLInitializationException {
		/**
		 * Corresponding Java class: org.apache.http.ssl.SSLInitializationException
		 */
		export interface Static extends Java.IllegalStateException.Static {
			new(message: string, cause: Java.Throwable): Http.SSLInitializationException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.Args
	 */
	export interface Args extends Java.Object {
	}
	export module Args {
		/**
		 * Corresponding Java class: org.apache.http.util.Args
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.Args;
			check(expression: boolean, message: string): void;
			check(expression: boolean, message: string, ...args: obj[]): void;
			check(expression: boolean, message: string, args: array<obj>): void;
			check(expression: boolean, message: string, arg: obj): void;
			containsNoBlanks<T extends string>(argument: T, name: string): T;
			notBlank<T extends string>(argument: T, name: string): T;
			notEmpty<T extends string>(argument: T, name: string): T;
			notEmpty<E,T extends Java.Collection<E>>(argument: T, name: string): T;
			notNegative(n: int, name: string): int;
			notNegative(n: long, name: string): long;
			notNull<T>(argument: T, name: string): T;
			positive(n: int, name: string): int;
			positive(n: long, name: string): long;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.ByteArrayBuffer
	 * A resizable byte array.
	 *
	 * @since 4.0
	 */
	export interface ByteArrayBuffer extends Java.Object, Java.Serializable {
		/**
		 * Appends {@code len} bytes to this buffer from the given source
		 * array starting at index {@code off}. The capacity of the buffer
		 * is increased, if necessary, to accommodate all {@code len} bytes.
		 *
		 * @param   b        the bytes to be appended.
		 * @param   off      the index of the first byte to append.
		 * @param   len      the number of bytes to append.
		 * @throws IndexOutOfBoundsException if {@code off} if out of
		 * range, {@code len} is negative, or
		 * {@code off} + {@code len} is out of range.
		 */
		append(b: array<byte>, off: int, len: int): void;
		/**
		 * Appends {@code b} byte to this buffer. The capacity of the buffer
		 * is increased, if necessary, to accommodate the additional byte.
		 *
		 * @param   b        the byte to be appended.
		 */
		append(b: int): void;
		/**
		 * Appends {@code len} chars to this buffer from the given source
		 * array starting at index {@code off}. The capacity of the buffer
		 * is increased if necessary to accommodate all {@code len} chars.
		 * 
		 * The chars are converted to bytes using simple cast.
		 *
		 * @param   b        the chars to be appended.
		 * @param   off      the index of the first char to append.
		 * @param   len      the number of bytes to append.
		 * @throws IndexOutOfBoundsException if {@code off} if out of
		 * range, {@code len} is negative, or
		 * {@code off} + {@code len} is out of range.
		 */
		append(b: array<char>, off: int, len: int): void;
		/**
		 * Appends {@code len} chars to this buffer from the given source
		 * char array buffer starting at index {@code off}. The capacity
		 * of the buffer is increased if necessary to accommodate all
		 * {@code len} chars.
		 * 
		 * The chars are converted to bytes using simple cast.
		 *
		 * @param   b        the chars to be appended.
		 * @param   off      the index of the first char to append.
		 * @param   len      the number of bytes to append.
		 * @throws IndexOutOfBoundsException if {@code off} if out of
		 * range, {@code len} is negative, or
		 * {@code off} + {@code len} is out of range.
		 */
		append(b: Http.CharArrayBuffer, off: int, len: int): void;
		/**
		 * Returns reference to the underlying byte array.
		 *
		 * @return the byte array.
		 */
		buffer(): array<byte>;
		/**
		 * Returns the {@code byte} value in this buffer at the specified
		 * index. The index argument must be greater than or equal to
		 * {@code 0}, and less than the length of this buffer.
		 *
		 * @param      i   the index of the desired byte value.
		 * @return     the byte value at the specified index.
		 * @throws     IndexOutOfBoundsException  if {@code index} is
		 *             negative or greater than or equal to {@link #length()}.
		 */
		byteAt(i: int): int;
		/**
		 * Returns the current capacity. The capacity is the amount of storage
		 * available for newly appended bytes, beyond which an allocation
		 * will occur.
		 *
		 * @return  the current capacity
		 */
		capacity(): int;
		/**
		 * Clears content of the buffer. The underlying byte array is not resized.
		 */
		clear(): void;
		/**
		 * Ensures that the capacity is at least equal to the specified minimum.
		 * If the current capacity is less than the argument, then a new internal
		 * array is allocated with greater capacity. If the {@code required}
		 * argument is non-positive, this method takes no action.
		 *
		 * @param   required   the minimum required capacity.
		 *
		 * @since 4.1
		 */
		ensureCapacity(required: int): void;
		/**
		 * Returns the index within this buffer of the first occurrence of the
		 * specified byte, starting the search at the specified
		 * {@code beginIndex} and finishing at {@code endIndex}.
		 * If no such byte occurs in this buffer within the specified bounds,
		 * {@code -1} is returned.
		 * 
		 * There is no restriction on the value of {@code beginIndex} and
		 * {@code endIndex}. If {@code beginIndex} is negative,
		 * it has the same effect as if it were zero. If {@code endIndex} is
		 * greater than {@link #length()}, it has the same effect as if it were
		 * {@link #length()}. If the {@code beginIndex} is greater than
		 * the {@code endIndex}, {@code -1} is returned.
		 *
		 * @param   b            the byte to search for.
		 * @param   from         the index to start the search from.
		 * @param   to           the index to finish the search at.
		 * @return  the index of the first occurrence of the byte in the buffer
		 *   within the given bounds, or {@code -1} if the byte does
		 *   not occur.
		 *
		 * @since 4.1
		 */
		indexOf(b: byte, from: int, to: int): int;
		/**
		 * Returns the index within this buffer of the first occurrence of the
		 * specified byte, starting the search at {@code 0} and finishing
		 * at {@link #length()}. If no such byte occurs in this buffer within
		 * those bounds, {@code -1} is returned.
		 *
		 * @param   b   the byte to search for.
		 * @return  the index of the first occurrence of the byte in the
		 *   buffer, or {@code -1} if the byte does not occur.
		 *
		 * @since 4.1
		 */
		indexOf(b: byte): int;
		/**
		 * Returns {@code true} if this buffer is empty, that is, its
		 * {@link #length()} is equal to {@code 0}.
		 * @return {@code true} if this buffer is empty, {@code false}
		 *   otherwise.
		 */
		isEmpty(): boolean;
		/**
		 * Returns {@code true} if this buffer is full, that is, its
		 * {@link #length()} is equal to its {@link #capacity()}.
		 * @return {@code true} if this buffer is full, {@code false}
		 *   otherwise.
		 */
		isFull(): boolean;
		/**
		 * Returns the length of the buffer (byte count).
		 *
		 * @return  the length of the buffer
		 */
		length(): int;
		/**
		 * Sets the length of the buffer. The new length value is expected to be
		 * less than the current capacity and greater than or equal to
		 * {@code 0}.
		 *
		 * @param      len   the new length
		 * @throws     IndexOutOfBoundsException  if the
		 *               {@code len} argument is greater than the current
		 *               capacity of the buffer or less than {@code 0}.
		 */
		setLength(len: int): void;
		/**
		 * Converts the content of this buffer to an array of bytes.
		 *
		 * @return byte array
		 */
		toByteArray(): array<byte>;
	}
	export module ByteArrayBuffer {
		/**
		 * Corresponding Java class: org.apache.http.util.ByteArrayBuffer
		 * A resizable byte array.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Java.Serializable.Static {
			/**
			 * Creates an instance of {@link ByteArrayBuffer} with the given initial
			 * capacity.
			 *
			 * @param capacity the capacity
			 */
			new(capacity: int): Http.ByteArrayBuffer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.CharArrayBuffer
	 * A resizable char array.
	 *
	 * @since 4.0
	 */
	export interface CharArrayBuffer extends Java.Object, Java.CharSequence, Java.Serializable {
		/**
		 * Appends {@code len} chars to this buffer from the given source
		 * array starting at index {@code off}. The capacity of the buffer
		 * is increased, if necessary, to accommodate all {@code len} chars.
		 *
		 * @param   b        the chars to be appended.
		 * @param   off      the index of the first char to append.
		 * @param   len      the number of chars to append.
		 * @throws IndexOutOfBoundsException if {@code off} is out of
		 * range, {@code len} is negative, or
		 * {@code off} + {@code len} is out of range.
		 */
		append(b: array<char>, off: int, len: int): void;
		/**
		 * Appends chars of the given string to this buffer. The capacity of the
		 * buffer is increased, if necessary, to accommodate all chars.
		 *
		 * @param str    the string.
		 */
		append(str: string): void;
		/**
		 * Appends {@code len} chars to this buffer from the given source
		 * buffer starting at index {@code off}. The capacity of the
		 * destination buffer is increased, if necessary, to accommodate all
		 * {@code len} chars.
		 *
		 * @param   b        the source buffer to be appended.
		 * @param   off      the index of the first char to append.
		 * @param   len      the number of chars to append.
		 * @throws IndexOutOfBoundsException if {@code off} is out of
		 * range, {@code len} is negative, or
		 * {@code off} + {@code len} is out of range.
		 */
		append(b: Http.CharArrayBuffer, off: int, len: int): void;
		/**
		 * Appends all chars to this buffer from the given source buffer starting
		 * at index {@code 0}. The capacity of the destination buffer is
		 * increased, if necessary, to accommodate all {@link #length()} chars.
		 *
		 * @param   b        the source buffer to be appended.
		 */
		append(b: Http.CharArrayBuffer): void;
		/**
		 * Appends {@code ch} char to this buffer. The capacity of the buffer
		 * is increased, if necessary, to accommodate the additional char.
		 *
		 * @param   ch        the char to be appended.
		 */
		append(ch: char): void;
		/**
		 * Appends {@code len} bytes to this buffer from the given source
		 * array starting at index {@code off}. The capacity of the buffer
		 * is increased, if necessary, to accommodate all {@code len} bytes.
		 * 
		 * The bytes are converted to chars using simple cast.
		 *
		 * @param   b        the bytes to be appended.
		 * @param   off      the index of the first byte to append.
		 * @param   len      the number of bytes to append.
		 * @throws IndexOutOfBoundsException if {@code off} is out of
		 * range, {@code len} is negative, or
		 * {@code off} + {@code len} is out of range.
		 */
		append(b: array<byte>, off: int, len: int): void;
		/**
		 * Appends {@code len} bytes to this buffer from the given source
		 * array starting at index {@code off}. The capacity of the buffer
		 * is increased, if necessary, to accommodate all {@code len} bytes.
		 * 
		 * The bytes are converted to chars using simple cast.
		 *
		 * @param   b        the bytes to be appended.
		 * @param   off      the index of the first byte to append.
		 * @param   len      the number of bytes to append.
		 * @throws IndexOutOfBoundsException if {@code off} is out of
		 * range, {@code len} is negative, or
		 * {@code off} + {@code len} is out of range.
		 */
		append(b: Http.ByteArrayBuffer, off: int, len: int): void;
		/**
		 * Appends chars of the textual representation of the given object to this
		 * buffer. The capacity of the buffer is increased, if necessary, to
		 * accommodate all chars.
		 *
		 * @param obj    the object.
		 */
		append(obj: obj): void;
		/**
		 * Returns reference to the underlying char array.
		 *
		 * @return the char array.
		 */
		buffer(): array<char>;
		/**
		 * Returns the current capacity. The capacity is the amount of storage
		 * available for newly appended chars, beyond which an allocation will
		 * occur.
		 *
		 * @return  the current capacity
		 */
		capacity(): int;
		/**
		 * Returns the {@code char} value in this buffer at the specified
		 * index. The index argument must be greater than or equal to
		 * {@code 0}, and less than the length of this buffer.
		 *
		 * @param      i   the index of the desired char value.
		 * @return     the char value at the specified index.
		 * @throws     IndexOutOfBoundsException  if {@code index} is
		 *             negative or greater than or equal to {@link #length()}.
		 */
		charAt(i: int): char;
		/**
		 * Clears content of the buffer. The underlying char array is not resized.
		 */
		clear(): void;
		/**
		 * Ensures that the capacity is at least equal to the specified minimum.
		 * If the current capacity is less than the argument, then a new internal
		 * array is allocated with greater capacity. If the {@code required}
		 * argument is non-positive, this method takes no action.
		 *
		 * @param   required   the minimum required capacity.
		 */
		ensureCapacity(required: int): void;
		/**
		 * Returns the index within this buffer of the first occurrence of the
		 * specified character, starting the search at the specified
		 * {@code beginIndex} and finishing at {@code endIndex}.
		 * If no such character occurs in this buffer within the specified bounds,
		 * {@code -1} is returned.
		 * 
		 * There is no restriction on the value of {@code beginIndex} and
		 * {@code endIndex}. If {@code beginIndex} is negative,
		 * it has the same effect as if it were zero. If {@code endIndex} is
		 * greater than {@link #length()}, it has the same effect as if it were
		 * {@link #length()}. If the {@code beginIndex} is greater than
		 * the {@code endIndex}, {@code -1} is returned.
		 *
		 * @param   ch     the char to search for.
		 * @param   from   the index to start the search from.
		 * @param   to     the index to finish the search at.
		 * @return  the index of the first occurrence of the character in the buffer
		 *   within the given bounds, or {@code -1} if the character does
		 *   not occur.
		 */
		indexOf(ch: int, from: int, to: int): int;
		/**
		 * Returns the index within this buffer of the first occurrence of the
		 * specified character, starting the search at {@code 0} and finishing
		 * at {@link #length()}. If no such character occurs in this buffer within
		 * those bounds, {@code -1} is returned.
		 *
		 * @param   ch          the char to search for.
		 * @return  the index of the first occurrence of the character in the
		 *   buffer, or {@code -1} if the character does not occur.
		 */
		indexOf(ch: int): int;
		/**
		 * Returns {@code true} if this buffer is empty, that is, its
		 * {@link #length()} is equal to {@code 0}.
		 * @return {@code true} if this buffer is empty, {@code false}
		 *   otherwise.
		 */
		isEmpty(): boolean;
		/**
		 * Returns {@code true} if this buffer is full, that is, its
		 * {@link #length()} is equal to its {@link #capacity()}.
		 * @return {@code true} if this buffer is full, {@code false}
		 *   otherwise.
		 */
		isFull(): boolean;
		/**
		 * Returns the length of the buffer (char count).
		 *
		 * @return  the length of the buffer
		 */
		length(): int;
		/**
		 * Sets the length of the buffer. The new length value is expected to be
		 * less than the current capacity and greater than or equal to
		 * {@code 0}.
		 *
		 * @param      len   the new length
		 * @throws     IndexOutOfBoundsException  if the
		 *               {@code len} argument is greater than the current
		 *               capacity of the buffer or less than {@code 0}.
		 */
		setLength(len: int): void;
		/**
		 * {@inheritDoc}
		 * @since 4.4
		 */
		subSequence(beginIndex: int, endIndex: int): string;
		/**
		 * Returns a substring of this buffer. The substring begins at the specified
		 * {@code beginIndex} and extends to the character at index
		 * {@code endIndex - 1}.
		 *
		 * @param      beginIndex   the beginning index, inclusive.
		 * @param      endIndex     the ending index, exclusive.
		 * @return     the specified substring.
		 * @throws  StringIndexOutOfBoundsException  if the
		 *             {@code beginIndex} is negative, or
		 *             {@code endIndex} is larger than the length of this
		 *             buffer, or {@code beginIndex} is larger than
		 *             {@code endIndex}.
		 */
		substring(beginIndex: int, endIndex: int): string;
		/**
		 * Returns a substring of this buffer with leading and trailing whitespace
		 * omitted. The substring begins with the first non-whitespace character
		 * from {@code beginIndex} and extends to the last
		 * non-whitespace character with the index lesser than
		 * {@code endIndex}.
		 *
		 * @param      beginIndex   the beginning index, inclusive.
		 * @param      endIndex     the ending index, exclusive.
		 * @return     the specified substring.
		 * @throws  IndexOutOfBoundsException  if the
		 *             {@code beginIndex} is negative, or
		 *             {@code endIndex} is larger than the length of this
		 *             buffer, or {@code beginIndex} is larger than
		 *             {@code endIndex}.
		 */
		substringTrimmed(beginIndex: int, endIndex: int): string;
		/**
		 * Converts the content of this buffer to an array of chars.
		 *
		 * @return char array
		 */
		toCharArray(): array<char>;
		toString(): string;
	}
	export module CharArrayBuffer {
		/**
		 * Corresponding Java class: org.apache.http.util.CharArrayBuffer
		 * A resizable char array.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Java.CharSequence.Static, Java.Serializable.Static {
			/**
			 * Creates an instance of {@link CharArrayBuffer} with the given initial
			 * capacity.
			 *
			 * @param capacity the capacity
			 */
			new(capacity: int): Http.CharArrayBuffer;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.CharsetUtils
	 */
	export interface CharsetUtils extends Java.Object {
	}
	export module CharsetUtils {
		/**
		 * Corresponding Java class: org.apache.http.util.CharsetUtils
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.CharsetUtils;
			get(name: string): Java.Charset;
			lookup(name: string): Java.Charset;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.EncodingUtils
	 * The home for utility methods that handle various encoding tasks.
	 *
	 *
	 * @since 4.0
	 */
	export interface EncodingUtils extends Java.Object {
	}
	export module EncodingUtils {
		/**
		 * Corresponding Java class: org.apache.http.util.EncodingUtils
		 * The home for utility methods that handle various encoding tasks.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Converts the specified string to byte array of ASCII characters.
			 *
			 * @param data the string to be encoded
			 * @return The string as a byte array.
			 */
			getAsciiBytes(data: string): array<byte>;
			/**
			 * Converts the byte array of ASCII characters to a string. This method is
			 * to be used when decoding content of HTTP elements (such as response
			 * headers)
			 *
			 * @param data the byte array to be encoded
			 * @param offset the index of the first byte to encode
			 * @param length the number of bytes to encode
			 * @return The string representation of the byte array
			 */
			getAsciiString(data: array<byte>, offset: int, length: int): string;
			/**
			 * Converts the byte array of ASCII characters to a string. This method is
			 * to be used when decoding content of HTTP elements (such as response
			 * headers)
			 *
			 * @param data the byte array to be encoded
			 * @return The string representation of the byte array
			 */
			getAsciiString(data: array<byte>): string;
			/**
			 * Converts the specified string to a byte array.  If the charset is not supported the
			 * default system charset is used.
			 *
			 * @param data the string to be encoded
			 * @param charset the desired character encoding
			 * @return The resulting byte array.
			 */
			getBytes(data: string, charset: string): array<byte>;
			/**
			 * Converts the byte array of HTTP content characters to a string. If
			 * the specified charset is not supported, default system encoding
			 * is used.
			 *
			 * @param data the byte array to be encoded
			 * @param offset the index of the first byte to encode
			 * @param length the number of bytes to encode
			 * @param charset the desired character encoding
			 * @return The result of the conversion.
			 */
			getString(data: array<byte>, offset: int, length: int, charset: string): string;
			/**
			 * Converts the byte array of HTTP content characters to a string. If
			 * the specified charset is not supported, default system encoding
			 * is used.
			 *
			 * @param data the byte array to be encoded
			 * @param charset the desired character encoding
			 * @return The result of the conversion.
			 */
			getString(data: array<byte>, charset: string): string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.EntityUtils
	 * Static helpers for dealing with {@link HttpEntity}s.
	 *
	 * @since 4.0
	 */
	export interface EntityUtils extends Java.Object {
	}
	export module EntityUtils {
		/**
		 * Corresponding Java class: org.apache.http.util.EntityUtils
		 * Static helpers for dealing with {@link HttpEntity}s.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Ensures that the entity content is fully consumed and the content stream, if exists,
			 * is closed.
			 *
			 * @param entity the entity to consume.
			 * @throws IOException if an error occurs reading the input stream
			 *
			 * @since 4.1
			 */
			consume(entity: Http.HttpEntity): void;
			/**
			 * Ensures that the entity content is fully consumed and the content stream, if exists,
			 * is closed. The process is done, quietly , without throwing any IOException.
			 *
			 * @param entity the entity to consume.
			 *
			 *
			 * @since 4.2
			 */
			consumeQuietly(entity: Http.HttpEntity): void;
			/**
			 * Read the contents of an entity and return it as a byte array.
			 *
			 * @param entity the entity to read from=
			 * @return byte array containing the entity content. May be null if
			 *   {@link HttpEntity#getContent()} is null.
			 * @throws IOException if an error occurs reading the input stream
			 * @throws IllegalArgumentException if entity is null or if content length &gt; Integer.MAX_VALUE
			 */
			toByteArray(entity: Http.HttpEntity): array<byte>;
			/**
			 * Get the entity content as a String, using the provided default character set
			 * if none is found in the entity.
			 * If defaultCharset is null, the default "ISO-8859-1" is used.
			 *
			 * @param entity must not be null
			 * @param defaultCharset character set to be applied if none found in the entity,
			 * or if the entity provided charset is invalid or not available.
			 * @return the entity content as a String. May be null if
			 *   {@link HttpEntity#getContent()} is null.
			 * @throws ParseException if header elements cannot be parsed
			 * @throws IllegalArgumentException if entity is null or if content length &gt; Integer.MAX_VALUE
			 * @throws IOException if an error occurs reading the input stream
			 * @throws java.nio.charset.UnsupportedCharsetException Thrown when the named entity's charset is not available in
			 * this instance of the Java virtual machine and no defaultCharset is provided.
			 */
			toString(entity: Http.HttpEntity, defaultCharset: Java.Charset): string;
			/**
			 * Get the entity content as a String, using the provided default character set
			 * if none is found in the entity.
			 * If defaultCharset is null, the default "ISO-8859-1" is used.
			 *
			 * @param entity must not be null
			 * @param defaultCharset character set to be applied if none found in the entity
			 * @return the entity content as a String. May be null if
			 *   {@link HttpEntity#getContent()} is null.
			 * @throws ParseException if header elements cannot be parsed
			 * @throws IllegalArgumentException if entity is null or if content length &gt; Integer.MAX_VALUE
			 * @throws IOException if an error occurs reading the input stream
			 * @throws java.nio.charset.UnsupportedCharsetException Thrown when the named charset is not available in
			 * this instance of the Java virtual machine
			 */
			toString(entity: Http.HttpEntity, defaultCharset: string): string;
			/**
			 * Read the contents of an entity and return it as a String.
			 * The content is converted using the character set from the entity (if any),
			 * failing that, "ISO-8859-1" is used.
			 *
			 * @param entity the entity to convert to a string; must not be null
			 * @return String containing the content.
			 * @throws ParseException if header elements cannot be parsed
			 * @throws IllegalArgumentException if entity is null or if content length &gt; Integer.MAX_VALUE
			 * @throws IOException if an error occurs reading the input stream
			 * @throws java.nio.charset.UnsupportedCharsetException Thrown when the named charset is not available in
			 * this instance of the Java virtual machine
			 */
			toString(entity: Http.HttpEntity): string;
			/**
			 * Updates an entity in a response by first consuming an existing entity, then setting the new one.
			 *
			 * @param response the response with an entity to update; must not be null.
			 * @param entity the entity to set in the response.
			 * @throws IOException if an error occurs while reading the input stream on the existing
			 * entity.
			 * @throws IllegalArgumentException if response is null.
			 *
			 * @since 4.3
			 */
			updateEntity(response: Http.HttpResponse, entity: Http.HttpEntity): void;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.ExceptionUtils
	 * The home for utility methods that handle various exception-related tasks.
	 *
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2) no longer used
	 */
	export interface ExceptionUtils extends Java.Object {
	}
	export module ExceptionUtils {
		/**
		 * Corresponding Java class: org.apache.http.util.ExceptionUtils
		 * The home for utility methods that handle various exception-related tasks.
		 *
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2) no longer used
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.LangUtils
	 * A set of utility methods to help produce consistent
	 * {@link Object#equals equals} and {@link Object#hashCode hashCode} methods.
	 *
	 *
	 * @since 4.0
	 */
	export interface LangUtils extends Java.Object {
	}
	export module LangUtils {
		/**
		 * Corresponding Java class: org.apache.http.util.LangUtils
		 * A set of utility methods to help produce consistent
		 * {@link Object#equals equals} and {@link Object#hashCode hashCode} methods.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			HASH_SEED?: int;
			HASH_OFFSET?: int;
			/**
			 * Check if two objects are equal.
			 *
			 * @param obj1 first object to compare, may be {@code null}
			 * @param obj2 second object to compare, may be {@code null}
			 * @return {@code true} if the objects are equal or both null
			 */
			equals(obj1: obj, obj2: obj): boolean;
			/**
			 * Check if two object arrays are equal.
			 * 
			 * If both parameters are null, return {@code true}
			 * If one parameter is null, return {@code false}
			 * If the array lengths are different, return {@code false}
			 * Compare array elements using .equals(); return {@code false} if any comparisons fail.
			 * Return {@code true}
			 * 
			 *
			 * @param a1 first array to compare, may be {@code null}
			 * @param a2 second array to compare, may be {@code null}
			 * @return {@code true} if the arrays are equal or both null
			 */
			equals(a1: array<obj>, a2: array<obj>): boolean;
			hashCode(seed: int, hashcode: int): int;
			hashCode(seed: int, b: boolean): int;
			hashCode(seed: int, obj: obj): int;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.NetUtils
	 * @since 4.3
	 */
	export interface NetUtils extends Java.Object {
	}
	export module NetUtils {
		/**
		 * Corresponding Java class: org.apache.http.util.NetUtils
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.NetUtils;
			formatAddress(buffer: Java.StringBuilder, socketAddress: Java.SocketAddress): void;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.TextUtils
	 * @since 4.3
	 */
	export interface TextUtils extends Java.Object {
	}
	export module TextUtils {
		/**
		 * Corresponding Java class: org.apache.http.util.TextUtils
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.TextUtils;
			/**
			 * @since 4.4
			 */
			containsBlanks(s: string): boolean;
			/**
			 * Returns true if the parameter is null or contains only whitespace
			 */
			isBlank(s: string): boolean;
			/**
			 * Returns true if the parameter is null or of zero length
			 */
			isEmpty(s: string): boolean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.VersionInfo
	 * Provides access to version information for HTTP components.
	 * Static methods are used to extract version information from property
	 * files that are automatically packaged with HTTP component release JARs.
	 * 
	 * All available version information is provided in strings, where
	 * the string format is informal and subject to change without notice.
	 * Version information is provided for debugging output and interpretation
	 * by humans, not for automated processing in applications.
	 * 
	 *
	 * @since 4.0
	 */
	export interface VersionInfo extends Java.Object {
		/**
		 * Obtains the classloader used to read the version information.
		 * This is just the {@code toString} output of the classloader,
		 * since the version information should not keep a reference to
		 * the classloader itself. That could prevent garbage collection.
		 *
		 * @return  the classloader description, never {@code null}
		 */
		getClassloader(): string;
		/**
		 * Obtains the name of the versioned module or informal unit.
		 * This data is read from the version information for the package.
		 *
		 * @return  the module name, never {@code null}
		 */
		getModule(): string;
		/**
		 * Obtains the package name.
		 * The package name identifies the module or informal unit.
		 *
		 * @return  the package name, never {@code null}
		 */
		getPackage(): string;
		/**
		 * Obtains the release of the versioned module or informal unit.
		 * This data is read from the version information for the package.
		 *
		 * @return  the release version, never {@code null}
		 */
		getRelease(): string;
		/**
		 * Obtains the timestamp of the versioned module or informal unit.
		 * This data is read from the version information for the package.
		 *
		 * @return  the timestamp, never {@code null}
		 */
		getTimestamp(): string;
		/**
		 * Provides the version information in human-readable format.
		 *
		 * @return  a string holding this version information
		 */
		toString(): string;
	}
	export module VersionInfo {
		/**
		 * Corresponding Java class: org.apache.http.util.VersionInfo
		 * Provides access to version information for HTTP components.
		 * Static methods are used to extract version information from property
		 * files that are automatically packaged with HTTP component release JARs.
		 * 
		 * All available version information is provided in strings, where
		 * the string format is informal and subject to change without notice.
		 * Version information is provided for debugging output and interpretation
		 * by humans, not for automated processing in applications.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.VersionInfo;
			/**
			 A string constant for unavailable information.
			 */
			UNAVAILABLE?: string;
			/**
			 The filename of the version information files.
			 */
			VERSION_PROPERTY_FILE?: string;
			PROPERTY_MODULE?: string;
			PROPERTY_RELEASE?: string;
			PROPERTY_TIMESTAMP?: string;
			/**
			 * Sets the user agent to {@code "/ (Java/)"}.
			 * 
			 * For example:
			 * "Apache-HttpClient/4.3 (Java/1.6.0_35)"
			 *
			 * @param name the component name, like "Apache-HttpClient".
			 * @param pkg
			 *            the package for which to load version information, for example "org.apache.http". The package name
			 *            should NOT end with a dot.
			 * @param cls
			 *            the class' class loader to load from, or {@code null} for the thread context class loader
			 * @since 4.3
			 */
			getUserAgent(name: string, pkg: string, cls: Java.Class<any>): string;
			/**
			 * Loads version information for a list of packages.
			 *
			 * @param pckgs     the packages for which to load version info
			 * @param clsldr    the classloader to load from, or
			 *                  {@code null} for the thread context classloader
			 *
			 * @return  the version information for all packages found,
			 *          never {@code null}
			 */
			loadVersionInfo(pckgs: array<string>, clsldr: Java.ClassLoader): array<Http.VersionInfo>;
			/**
			 * Loads version information for a package.
			 *
			 * @param pckg      the package for which to load version information,
			 *                  for example "org.apache.http".
			 *                  The package name should NOT end with a dot.
			 * @param clsldr    the classloader to load from, or
			 *                  {@code null} for the thread context classloader
			 *
			 * @return  the version information for the argument package, or
			 *          {@code null} if not available
			 */
			loadVersionInfo(pckg: string, clsldr: Java.ClassLoader): Http.VersionInfo;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.bootstrap.WorkerPoolExecutor
	 * @since 4.4
	 */
	export interface WorkerPoolExecutor extends Java.ThreadPoolExecutor {
		getWorkers(): Java.Set<Java.ThreadPoolExecutor$Worker>;
	}
	export module WorkerPoolExecutor {
		/**
		 * Corresponding Java class: org.apache.http.impl.bootstrap.WorkerPoolExecutor
		 * @since 4.4
		 */
		export interface Static extends Java.ThreadPoolExecutor.Static {
			new(corePoolSize: int, maximumPoolSize: int, keepAliveTime: long, unit: Java.TimeUnit, workQueue: Java.BlockingQueue<Java.Runnable>, threadFactory: Java.ThreadFactory): Http.WorkerPoolExecutor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.DefaultBHttpClientConnection
	 * Default implementation of {@link HttpClientConnection}.
	 *
	 * @since 4.3
	 */
	export interface DefaultBHttpClientConnection extends Http.BHttpConnectionBase, Http.HttpClientConnection {
		bind(socket: Java.Socket): void;
		flush(): void;
		isResponseAvailable(timeout: int): boolean;
		receiveResponseEntity(response: Http.HttpResponse): void;
		receiveResponseHeader(): Http.HttpResponse;
		sendRequestEntity(request: Http.HttpEntityEnclosingRequest): void;
		sendRequestHeader(request: Http.HttpRequest): void;
	}
	export module DefaultBHttpClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.DefaultBHttpClientConnection
		 * Default implementation of {@link HttpClientConnection}.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.BHttpConnectionBase.Static, Http.HttpClientConnection.Static {
			/**
			 * Creates new instance of DefaultBHttpClientConnection.
			 *
			 * @param buffersize buffer size. Must be a positive number.
			 * @param fragmentSizeHint fragment size hint.
			 * @param chardecoder decoder to be used for decoding HTTP protocol elements.
			 *   If {@code null} simple type cast will be used for byte to char conversion.
			 * @param charencoder encoder to be used for encoding HTTP protocol elements.
			 *   If {@code null} simple type cast will be used for char to byte conversion.
			 * @param constraints Message constraints. If {@code null}
			 *   {@link MessageConstraints#DEFAULT} will be used.
			 * @param incomingContentStrategy incoming content length strategy. If {@code null}
			 *   {@link org.apache.http.impl.entity.LaxContentLengthStrategy#INSTANCE} will be used.
			 * @param outgoingContentStrategy outgoing content length strategy. If {@code null}
			 *   {@link org.apache.http.impl.entity.StrictContentLengthStrategy#INSTANCE} will be used.
			 * @param requestWriterFactory request writer factory. If {@code null}
			 *   {@link DefaultHttpRequestWriterFactory#INSTANCE} will be used.
			 * @param responseParserFactory response parser factory. If {@code null}
			 *   {@link DefaultHttpResponseParserFactory#INSTANCE} will be used.
			 */
			new(buffersize: int, fragmentSizeHint: int, chardecoder: Java.CharsetDecoder, charencoder: Java.CharsetEncoder, constraints: Http.MessageConstraints, incomingContentStrategy: Http.ContentLengthStrategy, outgoingContentStrategy: Http.ContentLengthStrategy, requestWriterFactory: Http.HttpMessageWriterFactory<Http.HttpRequest>, responseParserFactory: Http.HttpMessageParserFactory<Http.HttpResponse>): Http.DefaultBHttpClientConnection;
			new(buffersize: int, chardecoder: Java.CharsetDecoder, charencoder: Java.CharsetEncoder, constraints: Http.MessageConstraints): Http.DefaultBHttpClientConnection;
			new(buffersize: int): Http.DefaultBHttpClientConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.DefaultBHttpServerConnection
	 * Default implementation of {@link HttpServerConnection}.
	 *
	 * @since 4.3
	 */
	export interface DefaultBHttpServerConnection extends Http.BHttpConnectionBase, Http.HttpServerConnection {
		bind(socket: Java.Socket): void;
		flush(): void;
		receiveRequestEntity(request: Http.HttpEntityEnclosingRequest): void;
		receiveRequestHeader(): Http.HttpRequest;
		sendResponseEntity(response: Http.HttpResponse): void;
		sendResponseHeader(response: Http.HttpResponse): void;
	}
	export module DefaultBHttpServerConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.DefaultBHttpServerConnection
		 * Default implementation of {@link HttpServerConnection}.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.BHttpConnectionBase.Static, Http.HttpServerConnection.Static {
			/**
			 * Creates new instance of DefaultBHttpServerConnection.
			 *
			 * @param buffersize buffer size. Must be a positive number.
			 * @param fragmentSizeHint fragment size hint.
			 * @param chardecoder decoder to be used for decoding HTTP protocol elements.
			 *   If {@code null} simple type cast will be used for byte to char conversion.
			 * @param charencoder encoder to be used for encoding HTTP protocol elements.
			 *   If {@code null} simple type cast will be used for char to byte conversion.
			 * @param constraints Message constraints. If {@code null}
			 *   {@link MessageConstraints#DEFAULT} will be used.
			 * @param incomingContentStrategy incoming content length strategy. If {@code null}
			 *   {@link DisallowIdentityContentLengthStrategy#INSTANCE} will be used.
			 * @param outgoingContentStrategy outgoing content length strategy. If {@code null}
			 *   {@link org.apache.http.impl.entity.StrictContentLengthStrategy#INSTANCE} will be used.
			 * @param requestParserFactory request parser factory. If {@code null}
			 *   {@link DefaultHttpRequestParserFactory#INSTANCE} will be used.
			 * @param responseWriterFactory response writer factory. If {@code null}
			 *   {@link DefaultHttpResponseWriterFactory#INSTANCE} will be used.
			 */
			new(buffersize: int, fragmentSizeHint: int, chardecoder: Java.CharsetDecoder, charencoder: Java.CharsetEncoder, constraints: Http.MessageConstraints, incomingContentStrategy: Http.ContentLengthStrategy, outgoingContentStrategy: Http.ContentLengthStrategy, requestParserFactory: Http.HttpMessageParserFactory<Http.HttpRequest>, responseWriterFactory: Http.HttpMessageWriterFactory<Http.HttpResponse>): Http.DefaultBHttpServerConnection;
			new(buffersize: int, chardecoder: Java.CharsetDecoder, charencoder: Java.CharsetEncoder, constraints: Http.MessageConstraints): Http.DefaultBHttpServerConnection;
			new(buffersize: int): Http.DefaultBHttpServerConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.DefaultBHttpServerConnectionFactory
	 * Default factory for {@link org.apache.http.HttpServerConnection}s.
	 *
	 * @since 4.3
	 */
	export interface DefaultBHttpServerConnectionFactory extends Java.Object, Http.HttpConnectionFactory<Http.DefaultBHttpServerConnection> {
		createConnection(socket: Java.Socket): Http.DefaultBHttpServerConnection;
	}
	export module DefaultBHttpServerConnectionFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.DefaultBHttpServerConnectionFactory
		 * Default factory for {@link org.apache.http.HttpServerConnection}s.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpConnectionFactory.Static {
			new(cconfig: Http.ConnectionConfig, incomingContentStrategy: Http.ContentLengthStrategy, outgoingContentStrategy: Http.ContentLengthStrategy, requestParserFactory: Http.HttpMessageParserFactory<Http.HttpRequest>, responseWriterFactory: Http.HttpMessageWriterFactory<Http.HttpResponse>): Http.DefaultBHttpServerConnectionFactory;
			new(cconfig: Http.ConnectionConfig, requestParserFactory: Http.HttpMessageParserFactory<Http.HttpRequest>, responseWriterFactory: Http.HttpMessageWriterFactory<Http.HttpResponse>): Http.DefaultBHttpServerConnectionFactory;
			new(cconfig: Http.ConnectionConfig): Http.DefaultBHttpServerConnectionFactory;
			new(): Http.DefaultBHttpServerConnectionFactory;
			INSTANCE?: Http.DefaultBHttpServerConnectionFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.MalformedChunkCodingException
	 * Signals a malformed chunked stream.
	 *
	 * @since 4.0
	 */
	export interface MalformedChunkCodingException extends Java.IOException {
	}
	export module MalformedChunkCodingException {
		/**
		 * Corresponding Java class: org.apache.http.MalformedChunkCodingException
		 * Signals a malformed chunked stream.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.IOException.Static {
			/**
			 * Creates a MalformedChunkCodingException without a detail message.
			 */
			new(): Http.MalformedChunkCodingException;
			/**
			 * Creates a MalformedChunkCodingException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.MalformedChunkCodingException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicHeaderElementIterator
	 * Basic implementation of a {@link HeaderElementIterator}.
	 *
	 * @since 4.0
	 */
	export interface BasicHeaderElementIterator extends Java.Object, Http.HeaderElementIterator {
		hasNext(): boolean;
		next(): obj;
		nextElement(): Http.HeaderElement;
		remove(): void;
	}
	export module BasicHeaderElementIterator {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicHeaderElementIterator
		 * Basic implementation of a {@link HeaderElementIterator}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HeaderElementIterator.Static {
			/**
			 * Creates a new instance of BasicHeaderElementIterator
			 */
			new(headerIterator: Http.HeaderIterator, parser: Http.HeaderValueParser): Http.BasicHeaderElementIterator;
			new(headerIterator: Http.HeaderIterator): Http.BasicHeaderElementIterator;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicHttpEntityEnclosingRequest
	 * Basic implementation of {@link HttpEntityEnclosingRequest}.
	 *
	 * @since 4.0
	 */
	export interface BasicHttpEntityEnclosingRequest extends Http.BasicHttpRequest, Http.HttpEntityEnclosingRequest {
		expectContinue(): boolean;
		getEntity(): Http.HttpEntity;
		setEntity(entity: Http.HttpEntity): void;
	}
	export module BasicHttpEntityEnclosingRequest {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicHttpEntityEnclosingRequest
		 * Basic implementation of {@link HttpEntityEnclosingRequest}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.BasicHttpRequest.Static, Http.HttpEntityEnclosingRequest.Static {
			new(method: string, uri: string): Http.BasicHttpEntityEnclosingRequest;
			new(method: string, uri: string, ver: Http.ProtocolVersion): Http.BasicHttpEntityEnclosingRequest;
			new(requestline: Http.RequestLine): Http.BasicHttpEntityEnclosingRequest;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicLineFormatter
	 * Interface for formatting elements of the HEAD section of an HTTP message.
	 * This is the complement to {@link LineParser}.
	 * There are individual methods for formatting a request line, a
	 * status line, or a header line. The formatting does not include the
	 * trailing line break sequence CR-LF.
	 * The formatted lines are returned in memory, the formatter does not depend
	 * on any specific IO mechanism.
	 * Instances of this interface are expected to be stateless and thread-safe.
	 *
	 * @since 4.0
	 */
	export interface BasicLineFormatter extends Java.Object, Http.LineFormatter {
		appendProtocolVersion(buffer: Http.CharArrayBuffer, version: Http.ProtocolVersion): Http.CharArrayBuffer;
		formatHeader(buffer: Http.CharArrayBuffer, header: Http.Header): Http.CharArrayBuffer;
		formatRequestLine(buffer: Http.CharArrayBuffer, reqline: Http.RequestLine): Http.CharArrayBuffer;
		formatStatusLine(buffer: Http.CharArrayBuffer, statline: Http.StatusLine): Http.CharArrayBuffer;
	}
	export module BasicLineFormatter {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicLineFormatter
		 * Interface for formatting elements of the HEAD section of an HTTP message.
		 * This is the complement to {@link LineParser}.
		 * There are individual methods for formatting a request line, a
		 * status line, or a header line. The formatting does not include the
		 * trailing line break sequence CR-LF.
		 * The formatted lines are returned in memory, the formatter does not depend
		 * on any specific IO mechanism.
		 * Instances of this interface are expected to be stateless and thread-safe.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.LineFormatter.Static {
			new(): Http.BasicLineFormatter;
			INSTANCE?: Http.BasicLineFormatter;
			/**
			 * Formats a header.
			 *
			 * @param header            the header to format
			 * @param formatter         the formatter to use, or
			 *                          {@code null} for the
			 *                          {@link #INSTANCE default}
			 *
			 * @return  the formatted header
			 */
			formatHeader(header: Http.Header, formatter: Http.LineFormatter): string;
			/**
			 * Formats a protocol version.
			 *
			 * @param version           the protocol version to format
			 * @param formatter         the formatter to use, or
			 *                          {@code null} for the
			 *                          {@link #INSTANCE default}
			 *
			 * @return  the formatted protocol version
			 */
			formatProtocolVersion(version: Http.ProtocolVersion, formatter: Http.LineFormatter): string;
			/**
			 * Formats a request line.
			 *
			 * @param reqline           the request line to format
			 * @param formatter         the formatter to use, or
			 *                          {@code null} for the
			 *                          {@link #INSTANCE default}
			 *
			 * @return  the formatted request line
			 */
			formatRequestLine(reqline: Http.RequestLine, formatter: Http.LineFormatter): string;
			/**
			 * Formats a status line.
			 *
			 * @param statline          the status line to format
			 * @param formatter         the formatter to use, or
			 *                          {@code null} for the
			 *                          {@link #INSTANCE default}
			 *
			 * @return  the formatted status line
			 */
			formatStatusLine(statline: Http.StatusLine, formatter: Http.LineFormatter): string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicRequestLine
	 * Basic implementation of {@link RequestLine}.
	 *
	 * @since 4.0
	 */
	export interface BasicRequestLine extends Java.Object, Http.RequestLine, Java.Cloneable, Java.Serializable {
		clone(): obj;
		getMethod(): string;
		getProtocolVersion(): Http.ProtocolVersion;
		getUri(): string;
		toString(): string;
	}
	export module BasicRequestLine {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicRequestLine
		 * Basic implementation of {@link RequestLine}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.RequestLine.Static, Java.Cloneable.Static, Java.Serializable.Static {
			new(method: string, uri: string, version: Http.ProtocolVersion): Http.BasicRequestLine;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.HeaderGroup
	 * A class for combining a set of headers.
	 * This class allows for multiple headers with the same name and
	 * keeps track of the order in which headers were added.
	 *
	 *
	 * @since 4.0
	 */
	export interface HeaderGroup extends Java.Object, Java.Cloneable, Java.Serializable {
		/**
		 * Adds the given header to the group.  The order in which this header was
		 * added is preserved.
		 *
		 * @param header the header to add
		 */
		addHeader(header: Http.Header): void;
		/**
		 * Removes any contained headers.
		 */
		clear(): void;
		clone(): obj;
		/**
		 * Tests if headers with the given name are contained within this group.
		 *
		 * Header name comparison is case insensitive.
		 *
		 * @param name the header name to test for
		 * @return {@code true} if at least one header with the name is
		 * contained, {@code false} otherwise
		 */
		containsHeader(name: string): boolean;
		/**
		 * Returns a copy of this object
		 *
		 * @return copy of this object
		 *
		 * @since 4.0
		 */
		copy(): Http.HeaderGroup;
		/**
		 * Gets all of the headers contained within this group.
		 *
		 * @return an array of length &ge; 0
		 */
		getAllHeaders(): array<Http.Header>;
		/**
		 * Gets a header representing all of the header values with the given name.
		 * If more that one header with the given name exists the values will be
		 * combined with a "," as per RFC 2616.
		 *
		 * Header name comparison is case insensitive.
		 *
		 * @param name the name of the header(s) to get
		 * @return a header with a condensed value or {@code null} if no
		 * headers by the given name are present
		 */
		getCondensedHeader(name: string): Http.Header;
		/**
		 * Gets the first header with the given name.
		 *
		 * Header name comparison is case insensitive.
		 *
		 * @param name the name of the header to get
		 * @return the first header or {@code null}
		 */
		getFirstHeader(name: string): Http.Header;
		/**
		 * Gets all of the headers with the given name.  The returned array
		 * maintains the relative order in which the headers were added.
		 *
		 * Header name comparison is case insensitive.
		 *
		 * @param name the name of the header(s) to get
		 *
		 * @return an array of length &ge; 0
		 */
		getHeaders(name: string): array<Http.Header>;
		/**
		 * Gets the last header with the given name.
		 *
		 * Header name comparison is case insensitive.
		 *
		 * @param name the name of the header to get
		 * @return the last header or {@code null}
		 */
		getLastHeader(name: string): Http.Header;
		/**
		 * Returns an iterator over this group of headers.
		 *
		 * @return iterator over this group of headers.
		 *
		 * @since 4.0
		 */
		iterator(): Http.HeaderIterator;
		/**
		 * Returns an iterator over the headers with a given name in this group.
		 *
		 * @param name      the name of the headers over which to iterate, or
		 *                  {@code null} for all headers
		 *
		 * @return iterator over some headers in this group.
		 *
		 * @since 4.0
		 */
		iterator(name: string): Http.HeaderIterator;
		/**
		 * Removes the given header.
		 *
		 * @param header the header to remove
		 */
		removeHeader(header: Http.Header): void;
		/**
		 * Sets all of the headers contained within this group overriding any
		 * existing headers. The headers are added in the order in which they appear
		 * in the array.
		 *
		 * @param headers the headers to set
		 */
		setHeaders(headers: array<Http.Header>): void;
		toString(): string;
		/**
		 * Replaces the first occurence of the header with the same name. If no header with
		 * the same name is found the given header is added to the end of the list.
		 *
		 * @param header the new header that should replace the first header with the same
		 * name if present in the list.
		 */
		updateHeader(header: Http.Header): void;
	}
	export module HeaderGroup {
		/**
		 * Corresponding Java class: org.apache.http.message.HeaderGroup
		 * A class for combining a set of headers.
		 * This class allows for multiple headers with the same name and
		 * keeps track of the order in which headers were added.
		 *
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Java.Cloneable.Static, Java.Serializable.Static {
			/**
			 * Constructor for HeaderGroup.
			 */
			new(): Http.HeaderGroup;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.ParserCursor
	 * This class represents a context of a parsing operation:
	 * 
	 *  the current position the parsing operation is expected to start at
	 *  the bounds limiting the scope of the parsing operation
	 * 
	 *
	 * @since 4.0
	 */
	export interface ParserCursor extends Java.Object {
		atEnd(): boolean;
		getLowerBound(): int;
		getPos(): int;
		getUpperBound(): int;
		toString(): string;
		updatePos(pos: int): void;
	}
	export module ParserCursor {
		/**
		 * Corresponding Java class: org.apache.http.message.ParserCursor
		 * This class represents a context of a parsing operation:
		 * 
		 *  the current position the parsing operation is expected to start at
		 *  the bounds limiting the scope of the parsing operation
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new(lowerBound: int, upperBound: int): Http.ParserCursor;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.MethodNotSupportedException
	 * Signals that an HTTP method is not supported.
	 *
	 * @since 4.0
	 */
	export interface MethodNotSupportedException extends Http.HttpException {
	}
	export module MethodNotSupportedException {
		/**
		 * Corresponding Java class: org.apache.http.MethodNotSupportedException
		 * Signals that an HTTP method is not supported.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpException.Static {
			/**
			 * Creates a new MethodNotSupportedException with the specified detail message.
			 *
			 * @param message The exception detail message
			 */
			new(message: string): Http.MethodNotSupportedException;
			/**
			 * Creates a new MethodNotSupportedException with the specified detail message and cause.
			 *
			 * @param message the exception detail message
			 * @param cause the {@code Throwable} that caused this exception, or {@code null}
			 * if the cause is unavailable, unknown, or not a {@code Throwable}
			 */
			new(message: string, cause: Java.Throwable): Http.MethodNotSupportedException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.NoHttpResponseException
	 * Signals that the target server failed to respond with a valid HTTP response.
	 *
	 * @since 4.0
	 */
	export interface NoHttpResponseException extends Java.IOException {
	}
	export module NoHttpResponseException {
		/**
		 * Corresponding Java class: org.apache.http.NoHttpResponseException
		 * Signals that the target server failed to respond with a valid HTTP response.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.IOException.Static {
			/**
			 * Creates a new NoHttpResponseException with the specified detail message.
			 *
			 * @param message exception message
			 */
			new(message: string): Http.NoHttpResponseException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.BasicHttpParams
	 * Default implementation of {@link HttpParams} interface.
	 * 
	 * Please note access to the internal structures of this class is not
	 * synchronized and therefore this class may be thread-unsafe.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface BasicHttpParams extends Http.AbstractHttpParams, Java.Serializable, Java.Cloneable {
	}
	export module BasicHttpParams {
		/**
		 * Corresponding Java class: org.apache.http.params.BasicHttpParams
		 * Default implementation of {@link HttpParams} interface.
		 * 
		 * Please note access to the internal structures of this class is not
		 * synchronized and therefore this class may be thread-unsafe.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Http.AbstractHttpParams.Static, Java.Serializable.Static, Java.Cloneable.Static {
			new(): Http.BasicHttpParams;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.CoreProtocolPNames
	 * Defines parameter names for protocol execution in HttpCore.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface CoreProtocolPNames extends Java.Object {
	}
	export module CoreProtocolPNames {
		/**
		 * Corresponding Java class: org.apache.http.params.CoreProtocolPNames
		 * Defines parameter names for protocol execution in HttpCore.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.HttpAbstractParamBean
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface HttpAbstractParamBean extends Java.Object {
	}
	export module HttpAbstractParamBean {
		/**
		 * Corresponding Java class: org.apache.http.params.HttpAbstractParamBean
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.HttpAbstractParamBean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.HttpConnectionParams
	 * Utility class for accessing connection parameters in {@link HttpParams}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface HttpConnectionParams extends Java.Object, Http.CoreConnectionPNames {
	}
	export module HttpConnectionParams {
		/**
		 * Corresponding Java class: org.apache.http.params.HttpConnectionParams
		 * Utility class for accessing connection parameters in {@link HttpParams}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Java.Object.Static, Http.CoreConnectionPNames.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.HttpParams
	 * HttpParams interface represents a collection of immutable values that define
	 * a runtime behavior of a component. HTTP parameters should be simple objects:
	 * integers, doubles, strings, collections and objects that remain immutable
	 * at runtime. HttpParams is expected to be used in 'write once - read many' mode.
	 * Once initialized, HTTP parameters are not expected to mutate in
	 * the course of HTTP message processing.
	 * 
	 * The purpose of this interface is to define a behavior of other components.
	 * Usually each complex component has its own HTTP parameter collection.
	 * 
	 * Instances of this interface can be linked together to form a hierarchy.
	 * In the simplest form one set of parameters can use content of another one
	 * to obtain default values of parameters not present in the local set.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface HttpParams extends Java.Object {
	}
	export module HttpParams {
		/**
		 * Corresponding Java class: org.apache.http.params.HttpParams
		 * HttpParams interface represents a collection of immutable values that define
		 * a runtime behavior of a component. HTTP parameters should be simple objects:
		 * integers, doubles, strings, collections and objects that remain immutable
		 * at runtime. HttpParams is expected to be used in 'write once - read many' mode.
		 * Once initialized, HTTP parameters are not expected to mutate in
		 * the course of HTTP message processing.
		 * 
		 * The purpose of this interface is to define a behavior of other components.
		 * Usually each complex component has its own HTTP parameter collection.
		 * 
		 * Instances of this interface can be linked together to form a hierarchy.
		 * In the simplest form one set of parameters can use content of another one
		 * to obtain default values of parameters not present in the local set.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.SyncBasicHttpParams
	 * Thread-safe extension of the {@link BasicHttpParams}.
	 *
	 * @since 4.1
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface SyncBasicHttpParams extends Http.BasicHttpParams {
	}
	export module SyncBasicHttpParams {
		/**
		 * Corresponding Java class: org.apache.http.params.SyncBasicHttpParams
		 * Thread-safe extension of the {@link BasicHttpParams}.
		 *
		 * @since 4.1
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Http.BasicHttpParams.Static {
			new(): Http.SyncBasicHttpParams;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.pool.ConnPool
	 * {@code ConnPool} represents a shared pool connections can be leased from
	 * and released back to.
	 *
	 * @param  the route type that represents the opposite endpoint of a pooled
	 *   connection.
	 * @param  the type of the pool entry containing a pooled connection.
	 * @since 4.2
	 */
	export interface ConnPool<T = any, E = any> extends Java.Object {
		/**
		 * Attempts to lease a connection for the given route and with the given
		 * state from the pool.
		 *
		 * @param route route of the connection.
		 * @param state arbitrary object that represents a particular state
		 *  (usually a security principal or a unique token identifying
		 *  the user whose credentials have been used while establishing the connection).
		 *  May be {@code null}.
		 * @param callback operation completion callback.
		 *
		 * @return future for a leased pool entry.
		 */
		lease(route: T, state: obj, callback: Http.FutureCallback<E>): Java.Future<E>;
		/**
		 * Releases the pool entry back to the pool.
		 *
		 * @param entry pool entry leased from the pool
		 * @param reusable flag indicating whether or not the released connection
		 *   is in a consistent state and is safe for further use.
		 */
		release(entry: E, reusable: boolean): void;
	}
	export module ConnPool {
		/**
		 * Corresponding Java class: org.apache.http.pool.ConnPool
		 * {@code ConnPool} represents a shared pool connections can be leased from
		 * and released back to.
		 *
		 * @param  the route type that represents the opposite endpoint of a pooled
		 *   connection.
		 * @param  the type of the pool entry containing a pooled connection.
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.pool.PoolStats
	 * Pool statistics.
	 * 
	 * The total number of connections in the pool is equal to {@code available} plus {@code leased}.
	 * 
	 *
	 * @since 4.2
	 */
	export interface PoolStats extends Java.Object, Java.Serializable {
		/**
		 * Gets the number idle persistent connections.
		 * 
		 * The total number of connections in the pool is equal to {@code available} plus {@code leased}.
		 * 
		 *
		 * @return number idle persistent connections.
		 */
		getAvailable(): int;
		/**
		 * Gets the number of persistent connections tracked by the connection manager currently being used to execute
		 * requests.
		 * 
		 * The total number of connections in the pool is equal to {@code available} plus {@code leased}.
		 * 
		 *
		 * @return the number of persistent connections.
		 */
		getLeased(): int;
		/**
		 * Gets the maximum number of allowed persistent connections.
		 *
		 * @return the maximum number of allowed persistent connections.
		 */
		getMax(): int;
		/**
		 * Gets the number of connection requests being blocked awaiting a free connection. This can happen only if there
		 * are more worker threads contending for fewer connections.
		 *
		 * @return the number of connection requests being blocked awaiting a free connection.
		 */
		getPending(): int;
		toString(): string;
	}
	export module PoolStats {
		/**
		 * Corresponding Java class: org.apache.http.pool.PoolStats
		 * Pool statistics.
		 * 
		 * The total number of connections in the pool is equal to {@code available} plus {@code leased}.
		 * 
		 *
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static, Java.Serializable.Static {
			new(leased: int, pending: int, free: int, max: int): Http.PoolStats;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.ChainBuilder
	 * Builder class to build a linked list (chain) of unique class instances. Each class can have
	 * only one instance in the list. Useful for building lists of protocol interceptors.
	 *
	 * @see ImmutableHttpProcessor
	 *
	 * @since 4.3
	 */
	export interface ChainBuilder<E = any> extends Java.Object {
		addAllFirst(c: Java.Collection<E>): Http.ChainBuilder<E>;
		addAllFirst(...c: E[]): Http.ChainBuilder<E>;
		addAllFirst(c: array<E>): Http.ChainBuilder<E>;
		addAllLast(c: Java.Collection<E>): Http.ChainBuilder<E>;
		addAllLast(...c: E[]): Http.ChainBuilder<E>;
		addAllLast(c: array<E>): Http.ChainBuilder<E>;
		addFirst(e: E): Http.ChainBuilder<E>;
		addLast(e: E): Http.ChainBuilder<E>;
		build(): Java.LinkedList<E>;
	}
	export module ChainBuilder {
		/**
		 * Corresponding Java class: org.apache.http.protocol.ChainBuilder
		 * Builder class to build a linked list (chain) of unique class instances. Each class can have
		 * only one instance in the list. Useful for building lists of protocol interceptors.
		 *
		 * @see ImmutableHttpProcessor
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			new <E>(): Http.ChainBuilder<E>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpContext
	 * HttpContext represents execution state of an HTTP process. It is a structure
	 * that can be used to map an attribute name to an attribute value.
	 * 
	 * The primary purpose of the HTTP context is to facilitate information sharing
	 * among various  logically related components. HTTP context can be used
	 * to store a processing state for one message or several consecutive messages.
	 * Multiple logically related messages can participate in a logical session
	 * if the same context is reused between consecutive messages.
	 * /
	 * IMPORTANT: Please note HTTP context implementation, even when thread safe,
	 * may not be used concurrently by multiple threads, as the context may contain
	 * thread unsafe attributes.
	 *
	 * @since 4.0
	 */
	export interface HttpContext extends Java.Object {
		/**
		 * Obtains attribute with the given name.
		 *
		 * @param id the attribute name.
		 * @return attribute value, or {@code null} if not set.
		 */
		getAttribute(id: string): obj;
		/**
		 * Removes attribute with the given name from the context.
		 *
		 * @param id the attribute name.
		 * @return attribute value, or {@code null} if not set.
		 */
		removeAttribute(id: string): obj;
		/**
		 * Sets value of the attribute with the given name.
		 *
		 * @param id the attribute name.
		 * @param obj the attribute value.
		 */
		setAttribute(id: string, obj: obj): void;
	}
	export module HttpContext {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpContext
		 * HttpContext represents execution state of an HTTP process. It is a structure
		 * that can be used to map an attribute name to an attribute value.
		 * 
		 * The primary purpose of the HTTP context is to facilitate information sharing
		 * among various  logically related components. HTTP context can be used
		 * to store a processing state for one message or several consecutive messages.
		 * Multiple logically related messages can participate in a logical session
		 * if the same context is reused between consecutive messages.
		 * /
		 * IMPORTANT: Please note HTTP context implementation, even when thread safe,
		 * may not be used concurrently by multiple threads, as the context may contain
		 * thread unsafe attributes.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 The prefix reserved for use by HTTP components. "http."
			 */
			RESERVED_PREFIX?: string;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpProcessor
	 * HTTP protocol processor is a collection of protocol interceptors that
	 * implements the 'Chain of Responsibility' pattern, where each individual
	 * protocol interceptor is expected to work on a particular aspect of the HTTP
	 * protocol the interceptor is responsible for.
	 * 
	 * Usually the order in which interceptors are executed should not matter as
	 * long as they do not depend on a particular state of the execution context.
	 * If protocol interceptors have interdependencies and therefore must be
	 * executed in a particular order, they should be added to the protocol
	 * processor in the same sequence as their expected execution order.
	 * 
	 * Protocol interceptors must be implemented as thread-safe. Similarly to
	 * servlets, protocol interceptors should not use instance variables unless
	 * access to those variables is synchronized.
	 *
	 * @since 4.0
	 */
	export interface HttpProcessor extends Http.HttpRequestInterceptor, Http.HttpResponseInterceptor {
		/**
		 * Processes a request.
		 * On the client side, this step is performed before the request is
		 * sent to the server. On the server side, this step is performed
		 * on incoming messages before the message body is evaluated.
		 *
		 * @param request   the request to preprocess
		 * @param context   the context for the request
		 *
		 * @throws HttpException in case of an HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
		/**
		 * Processes a response.
		 * On the server side, this step is performed before the response is
		 * sent to the client. On the client side, this step is performed
		 * on incoming messages before the message body is evaluated.
		 *
		 * @param response  the response to postprocess
		 * @param context   the context for the request
		 *
		 * @throws HttpException in case of an HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		process(response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module HttpProcessor {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpProcessor
		 * HTTP protocol processor is a collection of protocol interceptors that
		 * implements the 'Chain of Responsibility' pattern, where each individual
		 * protocol interceptor is expected to work on a particular aspect of the HTTP
		 * protocol the interceptor is responsible for.
		 * 
		 * Usually the order in which interceptors are executed should not matter as
		 * long as they do not depend on a particular state of the execution context.
		 * If protocol interceptors have interdependencies and therefore must be
		 * executed in a particular order, they should be added to the protocol
		 * processor in the same sequence as their expected execution order.
		 * 
		 * Protocol interceptors must be implemented as thread-safe. Similarly to
		 * servlets, protocol interceptors should not use instance variables unless
		 * access to those variables is synchronized.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpRequestInterceptor.Static, Http.HttpResponseInterceptor.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpRequestHandlerMapper
	 * HttpRequestHandlerMapper can be used to resolve an instance of
	 * {@link HttpRequestHandler} matching a particular {@link HttpRequest}. Usually the
	 * mapped request handler will be used to process the request.
	 *
	 * @since 4.3
	 */
	export interface HttpRequestHandlerMapper extends Java.Object {
		/**
		 * Looks up a handler matching the given request.
		 *
		 * @param request the request to map to a handler
		 * @return HTTP request handler or {@code null} if no match
		 * is found.
		 */
		lookup(request: Http.HttpRequest): Http.HttpRequestHandler;
	}
	export module HttpRequestHandlerMapper {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpRequestHandlerMapper
		 * HttpRequestHandlerMapper can be used to resolve an instance of
		 * {@link HttpRequestHandler} matching a particular {@link HttpRequest}. Usually the
		 * mapped request handler will be used to process the request.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpResponseInterceptorList
	 * Provides access to an ordered list of response interceptors.
	 * Lists are expected to be built upfront and used read-only afterwards
	 * for {@link HttpProcessor processing}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3)
	 */
	export interface HttpResponseInterceptorList extends Java.Object {
	}
	export module HttpResponseInterceptorList {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpResponseInterceptorList
		 * Provides access to an ordered list of response interceptors.
		 * Lists are expected to be built upfront and used read-only afterwards
		 * for {@link HttpProcessor processing}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3)
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.RequestConnControl
	 * RequestConnControl is responsible for adding {@code Connection} header
	 * to the outgoing requests, which is essential for managing persistence of
	 * {@code HTTP/1.0} connections. This interceptor is recommended for
	 * client side protocol processors.
	 *
	 * @since 4.0
	 */
	export interface RequestConnControl extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestConnControl {
		/**
		 * Corresponding Java class: org.apache.http.protocol.RequestConnControl
		 * RequestConnControl is responsible for adding {@code Connection} header
		 * to the outgoing requests, which is essential for managing persistence of
		 * {@code HTTP/1.0} connections. This interceptor is recommended for
		 * client side protocol processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			new(): Http.RequestConnControl;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.RequestTargetHost
	 * RequestTargetHost is responsible for adding {@code Host} header. This
	 * interceptor is required for client side protocol processors.
	 *
	 * @since 4.0
	 */
	export interface RequestTargetHost extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestTargetHost {
		/**
		 * Corresponding Java class: org.apache.http.protocol.RequestTargetHost
		 * RequestTargetHost is responsible for adding {@code Host} header. This
		 * interceptor is required for client side protocol processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			new(): Http.RequestTargetHost;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.ResponseDate
	 * ResponseDate is responsible for adding {@code Date} header to the
	 * outgoing responses. This interceptor is recommended for server side protocol
	 * processors.
	 *
	 * @since 4.0
	 */
	export interface ResponseDate extends Java.Object, Http.HttpResponseInterceptor {
		process(response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module ResponseDate {
		/**
		 * Corresponding Java class: org.apache.http.protocol.ResponseDate
		 * ResponseDate is responsible for adding {@code Date} header to the
		 * outgoing responses. This interceptor is recommended for server side protocol
		 * processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpResponseInterceptor.Static {
			new(): Http.ResponseDate;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.UriPatternMatcher
	 * Maintains a map of objects keyed by a request URI pattern.
	 * 
	 * Patterns may have three formats:
	 * 
	 *   {@code *}
	 *   {@code *&lt;uri&gt;}
	 *   {@code &lt;uri&gt;*}
	 * 
	 * 
	 * This class can be used to resolve an object matching a particular request
	 * URI.
	 *
	 * @since 4.0
	 */
	export interface UriPatternMatcher<T = any> extends Java.Object {
		/**
		 * Looks up an object matching the given request path.
		 *
		 * @param path the request path
		 * @return object or {@code null} if no match is found.
		 */
		lookup(path: string): T;
		/**
		 * Registers the given object for URIs matching the given pattern.
		 *
		 * @param pattern the pattern to register the handler for.
		 * @param obj the object.
		 */
		register(pattern: string, obj: T): void;
		toString(): string;
		/**
		 * Removes registered object, if exists, for the given pattern.
		 *
		 * @param pattern the pattern to unregister.
		 */
		unregister(pattern: string): void;
	}
	export module UriPatternMatcher {
		/**
		 * Corresponding Java class: org.apache.http.protocol.UriPatternMatcher
		 * Maintains a map of objects keyed by a request URI pattern.
		 * 
		 * Patterns may have three formats:
		 * 
		 *   {@code *}
		 *   {@code *&lt;uri&gt;}
		 *   {@code &lt;uri&gt;*}
		 * 
		 * 
		 * This class can be used to resolve an object matching a particular request
		 * URI.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			new <T>(): Http.UriPatternMatcher<T>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.RequestLine
	 * The Request-Line begins with a method token, followed by the
	 * Request-URI and the protocol version, and ending with CRLF. The
	 * elements are separated by SP characters. No CR or LF is allowed
	 * except in the final CRLF sequence.
	 * 
	 *      Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
	 * 
	 *
	 * @since 4.0
	 */
	export interface RequestLine extends Java.Object {
		getMethod(): string;
		getProtocolVersion(): Http.ProtocolVersion;
		getUri(): string;
	}
	export module RequestLine {
		/**
		 * Corresponding Java class: org.apache.http.RequestLine
		 * The Request-Line begins with a method token, followed by the
		 * Request-URI and the protocol version, and ending with CRLF. The
		 * elements are separated by SP characters. No CR or LF is allowed
		 * except in the final CRLF sequence.
		 * 
		 *      Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ssl.SSLContextBuilder
	 * Builder for {@link javax.net.ssl.SSLContext} instances.
	 * 
	 * Please note: the default Oracle JSSE implementation of {@link SSLContext#init(KeyManager[], TrustManager[], SecureRandom)}
	 * accepts multiple key and trust managers, however only only first matching type is ever used.
	 * See for example:
	 * 
	 * SSLContext.html#init
	 * 
	 * 
	 * TODO Specify which Oracle JSSE versions the above has been verified.
	 *  
	 * @since 4.4
	 */
	export interface SSLContextBuilder extends Java.Object {
		build(): Java.SSLContext;
		loadKeyMaterial(keystore: Java.KeyStore, keyPassword: array<char>, aliasStrategy: Http.PrivateKeyStrategy): Http.SSLContextBuilder;
		loadKeyMaterial(keystore: Java.KeyStore, keyPassword: array<char>): Http.SSLContextBuilder;
		loadKeyMaterial(file: Java.File, storePassword: array<char>, keyPassword: array<char>, aliasStrategy: Http.PrivateKeyStrategy): Http.SSLContextBuilder;
		loadKeyMaterial(file: Java.File, storePassword: array<char>, keyPassword: array<char>): Http.SSLContextBuilder;
		loadKeyMaterial(url: Java.URL, storePassword: array<char>, keyPassword: array<char>, aliasStrategy: Http.PrivateKeyStrategy): Http.SSLContextBuilder;
		loadKeyMaterial(url: Java.URL, storePassword: array<char>, keyPassword: array<char>): Http.SSLContextBuilder;
		loadTrustMaterial(truststore: Java.KeyStore, trustStrategy: Http.TrustStrategy): Http.SSLContextBuilder;
		loadTrustMaterial(trustStrategy: Http.TrustStrategy): Http.SSLContextBuilder;
		loadTrustMaterial(file: Java.File, storePassword: array<char>, trustStrategy: Http.TrustStrategy): Http.SSLContextBuilder;
		loadTrustMaterial(file: Java.File, storePassword: array<char>): Http.SSLContextBuilder;
		loadTrustMaterial(file: Java.File): Http.SSLContextBuilder;
		loadTrustMaterial(url: Java.URL, storePassword: array<char>, trustStrategy: Http.TrustStrategy): Http.SSLContextBuilder;
		loadTrustMaterial(url: Java.URL, storePassword: array<char>): Http.SSLContextBuilder;
		/**
		 * Sets the key manager factory algorithm name.
		 *
		 * @param keyManagerFactoryAlgorithm
		 *            the key manager factory algorithm name of the requested protocol. See
		 *            the KeyManagerFactory section in the <a href=
		 *            "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#KeyManagerFactory">Java
		 *            Cryptography Architecture Standard Algorithm Name
		 *            Documentation for more information.
		 * @return this builder
		 * @see <a href=
		 *      "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#KeyManagerFactory">Java
		 *      Cryptography Architecture Standard Algorithm Name Documentation
		 * @since 4.4.7
		 */
		setKeyManagerFactoryAlgorithm(keyManagerFactoryAlgorithm: string): Http.SSLContextBuilder;
		/**
		 * Sets the key store type.
		 *
		 * @param keyStoreType
		 *            the SSLkey store type. See
		 *            the KeyStore section in the <a href=
		 *            "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#KeyStore">Java
		 *            Cryptography Architecture Standard Algorithm Name
		 *            Documentation for more information.
		 * @return this builder
		 * @see <a href=
		 *      "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#KeyStore">Java
		 *      Cryptography Architecture Standard Algorithm Name Documentation
		 * @since 4.4.7
		 */
		setKeyStoreType(keyStoreType: string): Http.SSLContextBuilder;
		/**
		 * Sets the SSLContext protocol algorithm name.
		 *
		 * @param protocol
		 *            the SSLContext protocol algorithm name of the requested protocol. See
		 *            the SSLContext section in the <a href=
		 *            "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SSLContext">Java
		 *            Cryptography Architecture Standard Algorithm Name
		 *            Documentation for more information.
		 * @return this builder
		 * @see <a href=
		 *      "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SSLContext">Java
		 *      Cryptography Architecture Standard Algorithm Name Documentation
		 * @since 4.4.7
		 */
		setProtocol(protocol: string): Http.SSLContextBuilder;
		setProvider(provider: Java.Provider): Http.SSLContextBuilder;
		setProvider(name: string): Http.SSLContextBuilder;
		setSecureRandom(secureRandom: Java.SecureRandom): Http.SSLContextBuilder;
		/**
		 * Sets the trust manager factory algorithm name.
		 *
		 * @param trustManagerFactoryAlgorithm
		 *            the trust manager algorithm name of the requested protocol. See
		 *            the TrustManagerFactory section in the <a href=
		 *            "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#TrustManagerFactory">Java
		 *            Cryptography Architecture Standard Algorithm Name
		 *            Documentation for more information.
		 * @return this builder
		 * @see <a href=
		 *      "https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#TrustManagerFactory">Java
		 *      Cryptography Architecture Standard Algorithm Name Documentation
		 * @since 4.4.7
		 */
		setTrustManagerFactoryAlgorithm(trustManagerFactoryAlgorithm: string): Http.SSLContextBuilder;
		toString(): string;
	}
	export module SSLContextBuilder {
		/**
		 * Corresponding Java class: org.apache.http.ssl.SSLContextBuilder
		 * Builder for {@link javax.net.ssl.SSLContext} instances.
		 * 
		 * Please note: the default Oracle JSSE implementation of {@link SSLContext#init(KeyManager[], TrustManager[], SecureRandom)}
		 * accepts multiple key and trust managers, however only only first matching type is ever used.
		 * See for example:
		 * 
		 * SSLContext.html#init
		 * 
		 * 
		 * TODO Specify which Oracle JSSE versions the above has been verified.
		 *  
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			TrustManagerDelegate: SSLContextBuilder$TrustManagerDelegate.Static;
			KeyManagerDelegate: SSLContextBuilder$KeyManagerDelegate.Static;
			new(): Http.SSLContextBuilder;
			create(): Http.SSLContextBuilder;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.ssl.SSLContextBuilder.TrustManagerDelegate
	 */
	export interface SSLContextBuilder$TrustManagerDelegate extends Java.Object, Java.X509TrustManager {
		checkClientTrusted(chain: array<Java.X509Certificate>, authType: string): void;
		checkServerTrusted(chain: array<Java.X509Certificate>, authType: string): void;
		getAcceptedIssuers(): array<Java.X509Certificate>;
	}
	export module SSLContextBuilder$TrustManagerDelegate {
		/**
		 * Corresponding Java class: org.apache.http.ssl.SSLContextBuilder.TrustManagerDelegate
		 */
		export interface Static extends Java.Object.Static, Java.X509TrustManager.Static {
			new(): Http.SSLContextBuilder$TrustManagerDelegate;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.ssl.SSLContextBuilder.KeyManagerDelegate
	 */
	export interface SSLContextBuilder$KeyManagerDelegate extends Java.X509ExtendedKeyManager {
		chooseClientAlias(keyTypes: array<string>, issuers: array<Java.Principal>, socket: Java.Socket): string;
		chooseEngineClientAlias(keyTypes: array<string>, issuers: array<Java.Principal>, sslEngine: Java.SSLEngine): string;
		chooseEngineServerAlias(keyType: string, issuers: array<Java.Principal>, sslEngine: Java.SSLEngine): string;
		chooseServerAlias(keyType: string, issuers: array<Java.Principal>, socket: Java.Socket): string;
		getCertificateChain(alias: string): array<Java.X509Certificate>;
		getClientAliasMap(keyTypes: array<string>, issuers: array<Java.Principal>): Java.Map<string, Http.PrivateKeyDetails>;
		getClientAliases(keyType: string, issuers: array<Java.Principal>): array<string>;
		getPrivateKey(alias: string): Java.PrivateKey;
		getServerAliasMap(keyType: string, issuers: array<Java.Principal>): Java.Map<string, Http.PrivateKeyDetails>;
		getServerAliases(keyType: string, issuers: array<Java.Principal>): array<string>;
	}
	export module SSLContextBuilder$KeyManagerDelegate {
		/**
		 * Corresponding Java class: org.apache.http.ssl.SSLContextBuilder.KeyManagerDelegate
		 */
		export interface Static extends Java.X509ExtendedKeyManager.Static {
			new(): Http.SSLContextBuilder$KeyManagerDelegate;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ssl.SSLContexts
	 * {@link javax.net.ssl.SSLContext} factory methods.
	 *
	 * @since 4.4
	 */
	export interface SSLContexts extends Java.Object {
	}
	export module SSLContexts {
		/**
		 * Corresponding Java class: org.apache.http.ssl.SSLContexts
		 * {@link javax.net.ssl.SSLContext} factory methods.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.SSLContexts;
			/**
			 * Creates default factory based on the standard JSSE trust material
			 * ({@code cacerts} file in the security properties directory). System properties
			 * are not taken into consideration.
			 *
			 * @return the default SSL socket factory
			 */
			createDefault(): Java.SSLContext;
			/**
			 * Creates default SSL context based on system properties. This method obtains
			 * default SSL context by calling {@code SSLContext.getInstance("Default")}.
			 * Please note that {@code Default} algorithm is supported as of Java 6.
			 * This method will fall back onto {@link #createDefault()} when
			 * {@code Default} algorithm is not available.
			 *
			 * @return default system SSL context
			 */
			createSystemDefault(): Java.SSLContext;
			/**
			 * Creates custom SSL context.
			 *
			 * @return default system SSL context
			 */
			custom(): Http.SSLContextBuilder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpServerConnection
	 * A server-side HTTP connection, which can be used for receiving
	 * requests and sending responses.
	 *
	 * @since 4.0
	 */
	export interface HttpServerConnection extends Http.HttpConnection {
		/**
		 * Sends all pending buffered data over this connection.
		 * @throws IOException in case of an I/O error
		 */
		flush(): void;
		/**
		 * Receives the next request entity available from this connection and attaches it to
		 * an existing request.
		 * @param request the request to attach the entity to.
		 * @throws HttpException in case of HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		receiveRequestEntity(request: Http.HttpEntityEnclosingRequest): void;
		/**
		 * Receives the request line and all headers available from this connection.
		 * The caller should examine the returned request and decide if to receive a
		 * request entity as well.
		 *
		 * @return a new HttpRequest object whose request line and headers are
		 *         initialized.
		 * @throws HttpException in case of HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		receiveRequestHeader(): Http.HttpRequest;
		/**
		 * Sends the response entity of a response over this connection.
		 * @param response the response whose entity to send.
		 * @throws HttpException in case of HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		sendResponseEntity(response: Http.HttpResponse): void;
		/**
		 * Sends the response line and headers of a response over this connection.
		 * @param response the response whose headers to send.
		 * @throws HttpException in case of HTTP protocol violation
		 * @throws IOException in case of an I/O error
		 */
		sendResponseHeader(response: Http.HttpResponse): void;
	}
	export module HttpServerConnection {
		/**
		 * Corresponding Java class: org.apache.http.HttpServerConnection
		 * A server-side HTTP connection, which can be used for receiving
		 * requests and sending responses.
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.HttpConnection.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpStatus
	 * Constants enumerating the HTTP status codes.
	 * All status codes defined in RFC1945 (HTTP/1.0), RFC2616 (HTTP/1.1), and
	 * RFC2518 (WebDAV) are listed.
	 *
	 * @see StatusLine
	 * @see RFC1945 (HTTP/1.0)
	 * @see RFC2616 (HTTP/1.1)
	 * @see RFC2518 (WebDAV)
	 * @since 4.0
	 */
	export interface HttpStatus extends Java.Object {
	}
	export module HttpStatus {
		/**
		 * Corresponding Java class: org.apache.http.HttpStatus
		 * Constants enumerating the HTTP status codes.
		 * All status codes defined in RFC1945 (HTTP/1.0), RFC2616 (HTTP/1.1), and
		 * RFC2518 (WebDAV) are listed.
		 *
		 * @see StatusLine
		 * @see RFC1945 (HTTP/1.0)
		 * @see RFC2616 (HTTP/1.1)
		 * @see RFC2518 (WebDAV)
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 {@code 100 Continue} (HTTP/1.1 - RFC 2616)
			 */
			SC_CONTINUE?: int;
			/**
			 {@code 101 Switching Protocols} (HTTP/1.1 - RFC 2616)
			 */
			SC_SWITCHING_PROTOCOLS?: int;
			/**
			 {@code 102 Processing} (WebDAV - RFC 2518)
			 */
			SC_PROCESSING?: int;
			/**
			 {@code 200 OK} (HTTP/1.0 - RFC 1945)
			 */
			SC_OK?: int;
			/**
			 {@code 201 Created} (HTTP/1.0 - RFC 1945)
			 */
			SC_CREATED?: int;
			/**
			 {@code 202 Accepted} (HTTP/1.0 - RFC 1945)
			 */
			SC_ACCEPTED?: int;
			/**
			 {@code 203 Non Authoritative Information} (HTTP/1.1 - RFC 2616)
			 */
			SC_NON_AUTHORITATIVE_INFORMATION?: int;
			/**
			 {@code 204 No Content} (HTTP/1.0 - RFC 1945)
			 */
			SC_NO_CONTENT?: int;
			/**
			 {@code 205 Reset Content} (HTTP/1.1 - RFC 2616)
			 */
			SC_RESET_CONTENT?: int;
			/**
			 {@code 206 Partial Content} (HTTP/1.1 - RFC 2616)
			 */
			SC_PARTIAL_CONTENT?: int;
			/**
			 * {@code 207 Multi-Status} (WebDAV - RFC 2518)
			 * or
			 * {@code 207 Partial Update OK} (HTTP/1.1 - draft-ietf-http-v11-spec-rev-01?)
			 */
			SC_MULTI_STATUS?: int;
			/**
			 {@code 300 Mutliple Choices} (HTTP/1.1 - RFC 2616)
			 */
			SC_MULTIPLE_CHOICES?: int;
			/**
			 {@code 301 Moved Permanently} (HTTP/1.0 - RFC 1945)
			 */
			SC_MOVED_PERMANENTLY?: int;
			/**
			 {@code 302 Moved Temporarily} (Sometimes {@code Found}) (HTTP/1.0 - RFC 1945)
			 */
			SC_MOVED_TEMPORARILY?: int;
			/**
			 {@code 303 See Other} (HTTP/1.1 - RFC 2616)
			 */
			SC_SEE_OTHER?: int;
			/**
			 {@code 304 Not Modified} (HTTP/1.0 - RFC 1945)
			 */
			SC_NOT_MODIFIED?: int;
			/**
			 {@code 305 Use Proxy} (HTTP/1.1 - RFC 2616)
			 */
			SC_USE_PROXY?: int;
			/**
			 {@code 307 Temporary Redirect} (HTTP/1.1 - RFC 2616)
			 */
			SC_TEMPORARY_REDIRECT?: int;
			/**
			 {@code 400 Bad Request} (HTTP/1.1 - RFC 2616)
			 */
			SC_BAD_REQUEST?: int;
			/**
			 {@code 401 Unauthorized} (HTTP/1.0 - RFC 1945)
			 */
			SC_UNAUTHORIZED?: int;
			/**
			 {@code 402 Payment Required} (HTTP/1.1 - RFC 2616)
			 */
			SC_PAYMENT_REQUIRED?: int;
			/**
			 {@code 403 Forbidden} (HTTP/1.0 - RFC 1945)
			 */
			SC_FORBIDDEN?: int;
			/**
			 {@code 404 Not Found} (HTTP/1.0 - RFC 1945)
			 */
			SC_NOT_FOUND?: int;
			/**
			 {@code 405 Method Not Allowed} (HTTP/1.1 - RFC 2616)
			 */
			SC_METHOD_NOT_ALLOWED?: int;
			/**
			 {@code 406 Not Acceptable} (HTTP/1.1 - RFC 2616)
			 */
			SC_NOT_ACCEPTABLE?: int;
			/**
			 {@code 407 Proxy Authentication Required} (HTTP/1.1 - RFC 2616)
			 */
			SC_PROXY_AUTHENTICATION_REQUIRED?: int;
			/**
			 {@code 408 Request Timeout} (HTTP/1.1 - RFC 2616)
			 */
			SC_REQUEST_TIMEOUT?: int;
			/**
			 {@code 409 Conflict} (HTTP/1.1 - RFC 2616)
			 */
			SC_CONFLICT?: int;
			/**
			 {@code 410 Gone} (HTTP/1.1 - RFC 2616)
			 */
			SC_GONE?: int;
			/**
			 {@code 411 Length Required} (HTTP/1.1 - RFC 2616)
			 */
			SC_LENGTH_REQUIRED?: int;
			/**
			 {@code 412 Precondition Failed} (HTTP/1.1 - RFC 2616)
			 */
			SC_PRECONDITION_FAILED?: int;
			/**
			 {@code 413 Request Entity Too Large} (HTTP/1.1 - RFC 2616)
			 */
			SC_REQUEST_TOO_LONG?: int;
			/**
			 {@code 414 Request-URI Too Long} (HTTP/1.1 - RFC 2616)
			 */
			SC_REQUEST_URI_TOO_LONG?: int;
			/**
			 {@code 415 Unsupported Media Type} (HTTP/1.1 - RFC 2616)
			 */
			SC_UNSUPPORTED_MEDIA_TYPE?: int;
			/**
			 {@code 416 Requested Range Not Satisfiable} (HTTP/1.1 - RFC 2616)
			 */
			SC_REQUESTED_RANGE_NOT_SATISFIABLE?: int;
			/**
			 {@code 417 Expectation Failed} (HTTP/1.1 - RFC 2616)
			 */
			SC_EXPECTATION_FAILED?: int;
			/**
			 * Static constant for a 419 error.
			 * {@code 419 Insufficient Space on Resource}
			 * (WebDAV - draft-ietf-webdav-protocol-05?)
			 * or {@code 419 Proxy Reauthentication Required}
			 * (HTTP/1.1 drafts?)
			 */
			SC_INSUFFICIENT_SPACE_ON_RESOURCE?: int;
			/**
			 * Static constant for a 420 error.
			 * {@code 420 Method Failure}
			 * (WebDAV - draft-ietf-webdav-protocol-05?)
			 */
			SC_METHOD_FAILURE?: int;
			/**
			 {@code 422 Unprocessable Entity} (WebDAV - RFC 2518)
			 */
			SC_UNPROCESSABLE_ENTITY?: int;
			/**
			 {@code 423 Locked} (WebDAV - RFC 2518)
			 */
			SC_LOCKED?: int;
			/**
			 {@code 424 Failed Dependency} (WebDAV - RFC 2518)
			 */
			SC_FAILED_DEPENDENCY?: int;
			/**
			 {@code 500 Server Error} (HTTP/1.0 - RFC 1945)
			 */
			SC_INTERNAL_SERVER_ERROR?: int;
			/**
			 {@code 501 Not Implemented} (HTTP/1.0 - RFC 1945)
			 */
			SC_NOT_IMPLEMENTED?: int;
			/**
			 {@code 502 Bad Gateway} (HTTP/1.0 - RFC 1945)
			 */
			SC_BAD_GATEWAY?: int;
			/**
			 {@code 503 Service Unavailable} (HTTP/1.0 - RFC 1945)
			 */
			SC_SERVICE_UNAVAILABLE?: int;
			/**
			 {@code 504 Gateway Timeout} (HTTP/1.1 - RFC 2616)
			 */
			SC_GATEWAY_TIMEOUT?: int;
			/**
			 {@code 505 HTTP Version Not Supported} (HTTP/1.1 - RFC 2616)
			 */
			SC_HTTP_VERSION_NOT_SUPPORTED?: int;
			/**
			 {@code 507 Insufficient Storage} (WebDAV - RFC 2518)
			 */
			SC_INSUFFICIENT_STORAGE?: int;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.HttpVersion
	 * Represents an HTTP version. HTTP uses a "major.minor" numbering
	 * scheme to indicate versions of the protocol.
	 * 
	 * The version of an HTTP message is indicated by an HTTP-Version field
	 * in the first line of the message.
	 * 
	 * 
	 *     HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
	 * 
	 *
	 * @since 4.0
	 */
	export interface HttpVersion extends Http.ProtocolVersion, Java.Serializable {
		/**
		 * Obtains a specific HTTP version.
		 *
		 * @param major     the major version
		 * @param minor     the minor version
		 *
		 * @return  an instance of {@link HttpVersion} with the argument version
		 */
		forVersion(major: int, minor: int): Http.ProtocolVersion;
	}
	export module HttpVersion {
		/**
		 * Corresponding Java class: org.apache.http.HttpVersion
		 * Represents an HTTP version. HTTP uses a "major.minor" numbering
		 * scheme to indicate versions of the protocol.
		 * 
		 * The version of an HTTP message is indicated by an HTTP-Version field
		 * in the first line of the message.
		 * 
		 * 
		 *     HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Http.ProtocolVersion.Static, Java.Serializable.Static {
			/**
			 * Create an HTTP protocol version designator.
			 *
			 * @param major   the major version number of the HTTP protocol
			 * @param minor   the minor version number of the HTTP protocol
			 *
			 * @throws IllegalArgumentException if either major or minor version number is negative
			 */
			new(major: int, minor: int): Http.HttpVersion;
			/**
			 The protocol name.
			 */
			HTTP?: string;
			/**
			 HTTP protocol version 0.9
			 */
			HTTP_0_9?: Http.HttpVersion;
			/**
			 HTTP protocol version 1.0
			 */
			HTTP_1_0?: Http.HttpVersion;
			/**
			 HTTP protocol version 1.1
			 */
			HTTP_1_1?: Http.HttpVersion;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.AbstractHttpServerConnection
	 * Abstract server-side HTTP connection capable of transmitting and receiving
	 * data using arbitrary {@link SessionInputBuffer} and
	 * {@link SessionOutputBuffer} implementations.
	 * 
	 * The following parameters can be used to customize the behavior of this
	 * class:
	 * 
	 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
	 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
	 * 
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link DefaultBHttpServerConnection}
	 */
	export interface AbstractHttpServerConnection extends Java.Object, Http.HttpServerConnection {
	}
	export module AbstractHttpServerConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.AbstractHttpServerConnection
		 * Abstract server-side HTTP connection capable of transmitting and receiving
		 * data using arbitrary {@link SessionInputBuffer} and
		 * {@link SessionOutputBuffer} implementations.
		 * 
		 * The following parameters can be used to customize the behavior of this
		 * class:
		 * 
		 *  {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}
		 *  {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH}
		 * 
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link DefaultBHttpServerConnection}
		 */
		export interface Static extends Java.Object.Static, Http.HttpServerConnection.Static {
			new(): Http.AbstractHttpServerConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.bootstrap.HttpServer
	 * @since 4.4
	 */
	export interface HttpServer extends Java.Object {
		awaitTermination(timeout: long, timeUnit: Java.TimeUnit): void;
		getInetAddress(): Java.InetAddress;
		getLocalPort(): int;
		shutdown(gracePeriod: long, timeUnit: Java.TimeUnit): void;
		start(): void;
		stop(): void;
	}
	export module HttpServer {
		/**
		 * Corresponding Java class: org.apache.http.impl.bootstrap.HttpServer
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.HttpServer;
		}
	}
	/**
	 * Corresponding Java class: org.apache.http.impl.bootstrap.HttpServer.Status
	 */
	export interface HttpServer$Status extends Java.Enum<HttpServer$Status> {
	}
	export module HttpServer$Status {
		/**
		 * Corresponding Java class: org.apache.http.impl.bootstrap.HttpServer.Status
		 */
		export interface Static extends Java.Enum.Static {
			READY?: Http.HttpServer$Status;
			ACTIVE?: Http.HttpServer$Status;
			STOPPING?: Http.HttpServer$Status;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.bootstrap.ServerBootstrap
	 * @since 4.4
	 */
	export interface ServerBootstrap extends Java.Object {
		/**
		 * Adds this protocol interceptor to the head of the protocol processing list.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		addInterceptorFirst(itcp: Http.HttpResponseInterceptor): Http.ServerBootstrap;
		/**
		 * Adds this protocol interceptor to the head of the protocol processing list.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		addInterceptorFirst(itcp: Http.HttpRequestInterceptor): Http.ServerBootstrap;
		/**
		 * Adds this protocol interceptor to the tail of the protocol processing list.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		addInterceptorLast(itcp: Http.HttpResponseInterceptor): Http.ServerBootstrap;
		/**
		 * Adds this protocol interceptor to the tail of the protocol processing list.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		addInterceptorLast(itcp: Http.HttpRequestInterceptor): Http.ServerBootstrap;
		create(): Http.HttpServer;
		/**
		 * Registers the given {@link HttpRequestHandler} as a handler for URIs
		 * matching the given pattern.
		 * 
		 * Please note this value can be overridden by the {@link #setHandlerMapper(
		 *   org.apache.http.protocol.HttpRequestHandlerMapper)} method.
		 *
		 * @param pattern the pattern to register the handler for.
		 * @param handler the handler.
		 */
		registerHandler(pattern: string, handler: Http.HttpRequestHandler): Http.ServerBootstrap;
		/**
		 * Sets connection configuration.
		 * 
		 * Please note this value can be overridden by the {@link #setConnectionFactory(
		 * org.apache.http.HttpConnectionFactory)} method.
		 */
		setConnectionConfig(connectionConfig: Http.ConnectionConfig): Http.ServerBootstrap;
		/**
		 * Assigns {@link HttpConnectionFactory} instance.
		 */
		setConnectionFactory(connectionFactory: Http.HttpConnectionFactory<Http.DefaultBHttpServerConnection>): Http.ServerBootstrap;
		/**
		 * Assigns {@link ConnectionReuseStrategy} instance.
		 */
		setConnectionReuseStrategy(connStrategy: Http.ConnectionReuseStrategy): Http.ServerBootstrap;
		/**
		 * Assigns {@link org.apache.http.ExceptionLogger} instance.
		 */
		setExceptionLogger(exceptionLogger: Http.ExceptionLogger): Http.ServerBootstrap;
		/**
		 * Assigns {@link HttpExpectationVerifier} instance.
		 */
		setExpectationVerifier(expectationVerifier: Http.HttpExpectationVerifier): Http.ServerBootstrap;
		/**
		 * Assigns {@link HttpRequestHandlerMapper} instance.
		 */
		setHandlerMapper(handlerMapper: Http.HttpRequestHandlerMapper): Http.ServerBootstrap;
		/**
		 * Assigns {@link HttpProcessor} instance.
		 */
		setHttpProcessor(httpProcessor: Http.HttpProcessor): Http.ServerBootstrap;
		/**
		 * Sets listener port number.
		 */
		setListenerPort(listenerPort: int): Http.ServerBootstrap;
		/**
		 * Assigns local interface for the listener.
		 */
		setLocalAddress(localAddress: Java.InetAddress): Http.ServerBootstrap;
		/**
		 * Assigns {@link HttpResponseFactory} instance.
		 */
		setResponseFactory(responseFactory: Http.HttpResponseFactory): Http.ServerBootstrap;
		/**
		 * Assigns {@code Server} response header value.
		 * 
		 * Please note this value can be overridden by the {@link #setHttpProcessor(
		 * org.apache.http.protocol.HttpProcessor)} method.
		 */
		setServerInfo(serverInfo: string): Http.ServerBootstrap;
		/**
		 * Assigns {@link javax.net.ServerSocketFactory} instance.
		 */
		setServerSocketFactory(serverSocketFactory: Java.ServerSocketFactory): Http.ServerBootstrap;
		/**
		 * Sets socket configuration.
		 */
		setSocketConfig(socketConfig: Http.SocketConfig): Http.ServerBootstrap;
		/**
		 * Assigns {@link javax.net.ssl.SSLContext} instance.
		 * 
		 * Please note this value can be overridden by the {@link #setServerSocketFactory(
		 *   javax.net.ServerSocketFactory)} method.
		 */
		setSslContext(sslContext: Java.SSLContext): Http.ServerBootstrap;
		/**
		 * Assigns {@link org.apache.http.impl.bootstrap.SSLServerSetupHandler} instance.
		 */
		setSslSetupHandler(sslSetupHandler: Http.SSLServerSetupHandler): Http.ServerBootstrap;
	}
	export module ServerBootstrap {
		/**
		 * Corresponding Java class: org.apache.http.impl.bootstrap.ServerBootstrap
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			bootstrap(): Http.ServerBootstrap;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.bootstrap.ThreadFactoryImpl
	 * @since 4.4
	 */
	export interface ThreadFactoryImpl extends Java.Object, Java.ThreadFactory {
		newThread(target: Java.Runnable): Java.Thread;
	}
	export module ThreadFactoryImpl {
		/**
		 * Corresponding Java class: org.apache.http.impl.bootstrap.ThreadFactoryImpl
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Java.ThreadFactory.Static {
			new(): Http.ThreadFactoryImpl;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.bootstrap.Worker
	 * @since 4.4
	 */
	export interface Worker extends Java.Object, Java.Runnable {
		getConnection(): Http.HttpServerConnection;
		run(): void;
	}
	export module Worker {
		/**
		 * Corresponding Java class: org.apache.http.impl.bootstrap.Worker
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static, Java.Runnable.Static {
			new(): Http.Worker;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.ConnSupport
	 * Connection support methods.
	 *
	 * @since 4.3
	 */
	export interface ConnSupport extends Java.Object {
	}
	export module ConnSupport {
		/**
		 * Corresponding Java class: org.apache.http.impl.ConnSupport
		 * Connection support methods.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.ConnSupport;
			createDecoder(cconfig: Http.ConnectionConfig): Java.CharsetDecoder;
			createEncoder(cconfig: Http.ConnectionConfig): Java.CharsetEncoder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.DefaultBHttpClientConnectionFactory
	 * Default factory for {@link org.apache.http.HttpClientConnection}s.
	 *
	 * @since 4.3
	 */
	export interface DefaultBHttpClientConnectionFactory extends Java.Object, Http.HttpConnectionFactory<Http.DefaultBHttpClientConnection> {
		createConnection(socket: Java.Socket): Http.DefaultBHttpClientConnection;
	}
	export module DefaultBHttpClientConnectionFactory {
		/**
		 * Corresponding Java class: org.apache.http.impl.DefaultBHttpClientConnectionFactory
		 * Default factory for {@link org.apache.http.HttpClientConnection}s.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpConnectionFactory.Static {
			new(cconfig: Http.ConnectionConfig, incomingContentStrategy: Http.ContentLengthStrategy, outgoingContentStrategy: Http.ContentLengthStrategy, requestWriterFactory: Http.HttpMessageWriterFactory<Http.HttpRequest>, responseParserFactory: Http.HttpMessageParserFactory<Http.HttpResponse>): Http.DefaultBHttpClientConnectionFactory;
			new(cconfig: Http.ConnectionConfig, requestWriterFactory: Http.HttpMessageWriterFactory<Http.HttpRequest>, responseParserFactory: Http.HttpMessageParserFactory<Http.HttpResponse>): Http.DefaultBHttpClientConnectionFactory;
			new(cconfig: Http.ConnectionConfig): Http.DefaultBHttpClientConnectionFactory;
			new(): Http.DefaultBHttpClientConnectionFactory;
			INSTANCE?: Http.DefaultBHttpClientConnectionFactory;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpResponseWriter
	 * HTTP response writer that serializes its output to an instance of {@link SessionOutputBuffer}.
	 *
	 * @since 4.3
	 */
	export interface DefaultHttpResponseWriter extends Http.AbstractMessageWriter<Http.HttpResponse> {
	}
	export module DefaultHttpResponseWriter {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.DefaultHttpResponseWriter
		 * HTTP response writer that serializes its output to an instance of {@link SessionOutputBuffer}.
		 *
		 * @since 4.3
		 */
		export interface Static extends Http.AbstractMessageWriter.Static {
			/**
			 * Creates an instance of DefaultHttpResponseWriter.
			 *
			 * @param buffer the session output buffer.
			 * @param formatter the line formatter If {@code null}
			 *  {@link org.apache.http.message.BasicLineFormatter#INSTANCE}
			 *   will be used.
			 */
			new(buffer: Http.SessionOutputBuffer, formatter: Http.LineFormatter): Http.DefaultHttpResponseWriter;
			new(buffer: Http.SessionOutputBuffer): Http.DefaultHttpResponseWriter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.EmptyInputStream
	 * @since 4.4
	 */
	export interface EmptyInputStream extends Java.InputStream {
		available(): int;
		close(): void;
		mark(readLimit: int): void;
		markSupported(): boolean;
		read(): int;
		read(buf: array<byte>): int;
		read(buf: array<byte>, off: int, len: int): int;
		reset(): void;
		skip(n: long): long;
	}
	export module EmptyInputStream {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.EmptyInputStream
		 * @since 4.4
		 */
		export interface Static extends Java.InputStream.Static {
			INSTANCE?: Http.EmptyInputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.HttpRequestWriter
	 * HTTP request writer that serializes its output to an instance
	 * of {@link SessionOutputBuffer}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link DefaultHttpRequestWriter}
	 */
	export interface HttpRequestWriter extends Http.AbstractMessageWriter<Http.HttpRequest> {
	}
	export module HttpRequestWriter {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.HttpRequestWriter
		 * HTTP request writer that serializes its output to an instance
		 * of {@link SessionOutputBuffer}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link DefaultHttpRequestWriter}
		 */
		export interface Static extends Http.AbstractMessageWriter.Static {
			new(): Http.HttpRequestWriter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.HttpResponseWriter
	 * HTTP response writer that serializes its output to an instance
	 * of {@link SessionOutputBuffer}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link DefaultHttpResponseWriter}
	 */
	export interface HttpResponseWriter extends Http.AbstractMessageWriter<Http.HttpResponse> {
	}
	export module HttpResponseWriter {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.HttpResponseWriter
		 * HTTP response writer that serializes its output to an instance
		 * of {@link SessionOutputBuffer}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link DefaultHttpResponseWriter}
		 */
		export interface Static extends Http.AbstractMessageWriter.Static {
			new(): Http.HttpResponseWriter;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.util.Asserts
	 */
	export interface Asserts extends Java.Object {
	}
	export module Asserts {
		/**
		 * Corresponding Java class: org.apache.http.util.Asserts
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.Asserts;
			check(expression: boolean, message: string): void;
			check(expression: boolean, message: string, ...args: obj[]): void;
			check(expression: boolean, message: string, args: array<obj>): void;
			check(expression: boolean, message: string, arg: obj): void;
			notBlank(s: string, name: string): void;
			notEmpty(s: string, name: string): void;
			notNull(object: obj, name: string): void;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.IdentityInputStream
	 * Input stream that reads data without any transformation. The end of the
	 * content entity is demarcated by closing the underlying connection
	 * (EOF condition). Entities transferred using this input stream can be of
	 * unlimited length.
	 * 
	 * Note that this class NEVER closes the underlying stream, even when close
	 * gets called.  Instead, it will read until the end of the stream (until
	 * {@code -1} is returned).
	 *
	 * @since 4.0
	 */
	export interface IdentityInputStream extends Java.InputStream {
		available(): int;
		close(): void;
		read(): int;
		read(b: array<byte>, off: int, len: int): int;
	}
	export module IdentityInputStream {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.IdentityInputStream
		 * Input stream that reads data without any transformation. The end of the
		 * content entity is demarcated by closing the underlying connection
		 * (EOF condition). Entities transferred using this input stream can be of
		 * unlimited length.
		 * 
		 * Note that this class NEVER closes the underlying stream, even when close
		 * gets called.  Instead, it will read until the end of the stream (until
		 * {@code -1} is returned).
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.InputStream.Static {
			/**
			 * Wraps session input stream and reads input until the the end of stream.
			 *
			 * @param in The session input buffer
			 */
			new(in_: Http.SessionInputBuffer): Http.IdentityInputStream;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.SocketHttpClientConnection
	 * Implementation of a client-side HTTP connection that can be bound to an
	 * arbitrary {@link Socket} for receiving data from and transmitting data to
	 * a remote server.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use {@link DefaultBHttpClientConnection}
	 */
	export interface SocketHttpClientConnection extends Http.AbstractHttpClientConnection, Http.HttpInetConnection {
	}
	export module SocketHttpClientConnection {
		/**
		 * Corresponding Java class: org.apache.http.impl.SocketHttpClientConnection
		 * Implementation of a client-side HTTP connection that can be bound to an
		 * arbitrary {@link Socket} for receiving data from and transmitting data to
		 * a remote server.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use {@link DefaultBHttpClientConnection}
		 */
		export interface Static extends Http.AbstractHttpClientConnection.Static, Http.HttpInetConnection.Static {
			new(): Http.SocketHttpClientConnection;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.io.BufferInfo
	 * Basic buffer properties.
	 *
	 * @since 4.1
	 */
	export interface BufferInfo extends Java.Object {
		/**
		 * Returns available space in the buffer.
		 *
		 * @return available space.
		 */
		available(): int;
		/**
		 * Returns total capacity of the buffer
		 *
		 * @return total capacity
		 */
		capacity(): int;
		/**
		 * Return length data stored in the buffer
		 *
		 * @return data length
		 */
		length(): int;
	}
	export module BufferInfo {
		/**
		 * Corresponding Java class: org.apache.http.io.BufferInfo
		 * Basic buffer properties.
		 *
		 * @since 4.1
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.io.EofSensor
	 * EOF sensor.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) no longer used.
	 */
	export interface EofSensor extends Java.Object {
	}
	export module EofSensor {
		/**
		 * Corresponding Java class: org.apache.http.io.EofSensor
		 * EOF sensor.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) no longer used.
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.io.HttpMessageParser
	 * Abstract message parser intended to build HTTP messages from an arbitrary data source.
	 *
	 * @param 
	 *            {@link HttpMessage} or a subclass
	 *
	 * @since 4.0
	 */
	export interface HttpMessageParser<T extends HttpMessage = any> extends Java.Object {
		/**
		 * Generates an instance of {@link HttpMessage} from the underlying data
		 * source.
		 *
		 * @return HTTP message
		 * @throws IOException in case of an I/O error
		 * @throws HttpException in case of HTTP protocol violation
		 */
		parse(): T;
	}
	export module HttpMessageParser {
		/**
		 * Corresponding Java class: org.apache.http.io.HttpMessageParser
		 * Abstract message parser intended to build HTTP messages from an arbitrary data source.
		 *
		 * @param 
		 *            {@link HttpMessage} or a subclass
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.impl.io.SessionInputBufferImpl
	 * Abstract base class for session input buffers that stream data from
	 * an arbitrary {@link InputStream}. This class buffers input data in
	 * an internal byte array for optimal input performance.
	 * 
	 * {@link #readLine(CharArrayBuffer)} and {@link #readLine()} methods of this
	 * class treat a lone LF as valid line delimiters in addition to CR-LF required
	 * by the HTTP specification.
	 *
	 * @since 4.3
	 */
	export interface SessionInputBufferImpl extends Java.Object, Http.SessionInputBuffer, Http.BufferInfo {
		available(): int;
		bind(instream: Java.InputStream): void;
		capacity(): int;
		clear(): void;
		fillBuffer(): int;
		getMetrics(): Http.HttpTransportMetrics;
		hasBufferedData(): boolean;
		isBound(): boolean;
		isDataAvailable(timeout: int): boolean;
		length(): int;
		read(): int;
		read(b: array<byte>, off: int, len: int): int;
		read(b: array<byte>): int;
		/**
		 * Reads a complete line of characters up to a line delimiter from this
		 * session buffer into the given line buffer. The number of chars actually
		 * read is returned as an integer. The line delimiter itself is discarded.
		 * If no char is available because the end of the stream has been reached,
		 * the value {@code -1} is returned. This method blocks until input
		 * data is available, end of file is detected, or an exception is thrown.
		 * 
		 * This method treats a lone LF as a valid line delimiters in addition
		 * to CR-LF required by the HTTP specification.
		 *
		 * @param      charbuffer   the line buffer.
		 * @return     one line of characters
		 * @throws  IOException  if an I/O error occurs.
		 */
		readLine(charbuffer: Http.CharArrayBuffer): int;
		readLine(): string;
	}
	export module SessionInputBufferImpl {
		/**
		 * Corresponding Java class: org.apache.http.impl.io.SessionInputBufferImpl
		 * Abstract base class for session input buffers that stream data from
		 * an arbitrary {@link InputStream}. This class buffers input data in
		 * an internal byte array for optimal input performance.
		 * 
		 * {@link #readLine(CharArrayBuffer)} and {@link #readLine()} methods of this
		 * class treat a lone LF as valid line delimiters in addition to CR-LF required
		 * by the HTTP specification.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.SessionInputBuffer.Static, Http.BufferInfo.Static {
			/**
			 * Creates new instance of SessionInputBufferImpl.
			 *
			 * @param metrics HTTP transport metrics.
			 * @param buffersize buffer size. Must be a positive number.
			 * @param minChunkLimit size limit below which data chunks should be buffered in memory
			 *   in order to minimize native method invocations on the underlying network socket.
			 *   The optimal value of this parameter can be platform specific and defines a trade-off
			 *   between performance of memory copy operations and that of native method invocation.
			 *   If negative default chunk limited will be used.
			 * @param constraints Message constraints. If {@code null}
			 *   {@link MessageConstraints#DEFAULT} will be used.
			 * @param chardecoder chardecoder to be used for decoding HTTP protocol elements.
			 *   If {@code null} simple type cast will be used for byte to char conversion.
			 */
			new(metrics: Http.HttpTransportMetricsImpl, buffersize: int, minChunkLimit: int, constraints: Http.MessageConstraints, chardecoder: Java.CharsetDecoder): Http.SessionInputBufferImpl;
			new(metrics: Http.HttpTransportMetricsImpl, buffersize: int): Http.SessionInputBufferImpl;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.io.HttpMessageWriter
	 * Abstract message writer intended to serialize HTTP messages to an arbitrary
	 * data sink.
	 *
	 * @since 4.0
	 */
	export interface HttpMessageWriter<T extends HttpMessage = any> extends Java.Object {
		/**
		 * Serializes an instance of {@link HttpMessage} to the underlying data
		 * sink.
		 *
		 * @param message HTTP message
		 * @throws IOException in case of an I/O error
		 * @throws HttpException in case of HTTP protocol violation
		 */
		write(message: T): void;
	}
	export module HttpMessageWriter {
		/**
		 * Corresponding Java class: org.apache.http.io.HttpMessageWriter
		 * Abstract message writer intended to serialize HTTP messages to an arbitrary
		 * data sink.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.io.HttpMessageWriterFactory
	 * Factory for {@link HttpMessageWriter} instances.
	 *
	 * @since 4.3
	 */
	export interface HttpMessageWriterFactory<T extends HttpMessage = any> extends Java.Object {
		create(buffer: Http.SessionOutputBuffer): Http.HttpMessageWriter<T>;
	}
	export module HttpMessageWriterFactory {
		/**
		 * Corresponding Java class: org.apache.http.io.HttpMessageWriterFactory
		 * Factory for {@link HttpMessageWriter} instances.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.io.HttpTransportMetrics
	 * The point of access to the statistics of {@link SessionInputBuffer} or
	 * {@link SessionOutputBuffer}.
	 *
	 * @since 4.0
	 */
	export interface HttpTransportMetrics extends Java.Object {
		/**
		 * Returns the number of bytes transferred.
		 */
		getBytesTransferred(): long;
		/**
		 * Resets the counts
		 */
		reset(): void;
	}
	export module HttpTransportMetrics {
		/**
		 * Corresponding Java class: org.apache.http.io.HttpTransportMetrics
		 * The point of access to the statistics of {@link SessionInputBuffer} or
		 * {@link SessionOutputBuffer}.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.io.HttpMessageParserFactory
	 * Factory for {@link HttpMessageParser} instances.
	 *
	 * @since 4.3
	 */
	export interface HttpMessageParserFactory<T extends HttpMessage = any> extends Java.Object {
		create(buffer: Http.SessionInputBuffer, constraints: Http.MessageConstraints): Http.HttpMessageParser<T>;
	}
	export module HttpMessageParserFactory {
		/**
		 * Corresponding Java class: org.apache.http.io.HttpMessageParserFactory
		 * Factory for {@link HttpMessageParser} instances.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.io.SessionInputBuffer
	 * Session input buffer for blocking connections. This interface is similar to
	 * InputStream class, but it also provides methods for reading lines of text.
	 * 
	 * Implementing classes are also expected to manage intermediate data buffering
	 * for optimal input performance.
	 *
	 * @since 4.0
	 */
	export interface SessionInputBuffer extends Java.Object {
		/**
		 * Returns {@link HttpTransportMetrics} for this session buffer.
		 *
		 * @return transport metrics.
		 */
		getMetrics(): Http.HttpTransportMetrics;
		/**
		 * Reads up to {@code len} bytes of data from the session buffer into
		 * an array of bytes.  An attempt is made to read as many as
		 * {@code len} bytes, but a smaller number may be read, possibly
		 * zero. The number of bytes actually read is returned as an integer.
		 *
		 *  This method blocks until input data is available, end of file is
		 * detected, or an exception is thrown.
		 *
		 *  If {@code off} is negative, or {@code len} is negative, or
		 * {@code off+len} is greater than the length of the array
		 * {@code b}, then an {@code IndexOutOfBoundsException} is
		 * thrown.
		 *
		 * @param      b     the buffer into which the data is read.
		 * @param      off   the start offset in array {@code b}
		 *                   at which the data is written.
		 * @param      len   the maximum number of bytes to read.
		 * @return     the total number of bytes read into the buffer, or
		 *             {@code -1} if there is no more data because the end of
		 *             the stream has been reached.
		 * @throws  IOException  if an I/O error occurs.
		 */
		read(b: array<byte>, off: int, len: int): int;
		/**
		 * Reads some number of bytes from the session buffer and stores them into
		 * the buffer array {@code b}. The number of bytes actually read is
		 * returned as an integer.  This method blocks until input data is
		 * available, end of file is detected, or an exception is thrown.
		 *
		 * @param      b   the buffer into which the data is read.
		 * @return     the total number of bytes read into the buffer, or
		 *             {@code -1} is there is no more data because the end of
		 *             the stream has been reached.
		 * @throws  IOException  if an I/O error occurs.
		 */
		read(b: array<byte>): int;
		/**
		 * Reads the next byte of data from this session buffer. The value byte is
		 * returned as an {@code int} in the range {@code 0} to
		 * {@code 255}. If no byte is available because the end of the stream
		 * has been reached, the value {@code -1} is returned. This method
		 * blocks until input data is available, the end of the stream is detected,
		 * or an exception is thrown.
		 *
		 * @return     the next byte of data, or {@code -1} if the end of the
		 *             stream is reached.
		 * @throws  IOException  if an I/O error occurs.
		 */
		read(): int;
		/**
		 * Reads a complete line of characters up to a line delimiter from this
		 * session buffer into the given line buffer. The number of chars actually
		 * read is returned as an integer. The line delimiter itself is discarded.
		 * If no char is available because the end of the stream has been reached,
		 * the value {@code -1} is returned. This method blocks until input
		 * data is available, end of file is detected, or an exception is thrown.
		 * 
		 * The choice of a char encoding and line delimiter sequence is up to the
		 * specific implementations of this interface.
		 *
		 * @param      buffer   the line buffer.
		 * @return     one line of characters
		 * @throws  IOException  if an I/O error occurs.
		 */
		readLine(buffer: Http.CharArrayBuffer): int;
		/**
		 * Reads a complete line of characters up to a line delimiter from this
		 * session buffer. The line delimiter itself is discarded. If no char is
		 * available because the end of the stream has been reached,
		 * {@code null} is returned. This method blocks until input data is
		 * available, end of file is detected, or an exception is thrown.
		 * 
		 * The choice of a char encoding and line delimiter sequence is up to the
		 * specific implementations of this interface.
		 *
		 * @return HTTP line as a string
		 * @throws  IOException  if an I/O error occurs.
		 */
		readLine(): string;
	}
	export module SessionInputBuffer {
		/**
		 * Corresponding Java class: org.apache.http.io.SessionInputBuffer
		 * Session input buffer for blocking connections. This interface is similar to
		 * InputStream class, but it also provides methods for reading lines of text.
		 * 
		 * Implementing classes are also expected to manage intermediate data buffering
		 * for optimal input performance.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicHeaderElement
	 * Basic implementation of {@link HeaderElement}
	 *
	 * @since 4.0
	 */
	export interface BasicHeaderElement extends Java.Object, Http.HeaderElement, Java.Cloneable {
		clone(): obj;
		equals(object: obj): boolean;
		getName(): string;
		getParameter(index: int): Http.NameValuePair;
		getParameterByName(name: string): Http.NameValuePair;
		getParameterCount(): int;
		getParameters(): array<Http.NameValuePair>;
		getValue(): string;
		hashCode(): int;
		toString(): string;
	}
	export module BasicHeaderElement {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicHeaderElement
		 * Basic implementation of {@link HeaderElement}
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HeaderElement.Static, Java.Cloneable.Static {
			/**
			 * Constructor with name, value and parameters.
			 *
			 * @param name header element name
			 * @param value header element value. May be {@code null}
			 * @param parameters header element parameters. May be {@code null}.
			 *   Parameters are copied by reference, not by value
			 */
			new(name: string, value: string, parameters: array<Http.NameValuePair>): Http.BasicHeaderElement;
			/**
			 * Constructor with name and value.
			 *
			 * @param name header element name
			 * @param value header element value. May be {@code null}
			 */
			new(name: string, value: string): Http.BasicHeaderElement;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicHeaderValueParser
	 * Basic implementation for parsing header values into elements.
	 * Instances of this class are stateless and thread-safe.
	 * Derived classes are expected to maintain these properties.
	 *
	 * @since 4.0
	 */
	export interface BasicHeaderValueParser extends Java.Object, Http.HeaderValueParser {
		parseElements(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): array<Http.HeaderElement>;
		parseHeaderElement(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.HeaderElement;
		parseNameValuePair(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.NameValuePair;
		parseParameters(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): array<Http.NameValuePair>;
	}
	export module BasicHeaderValueParser {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicHeaderValueParser
		 * Basic implementation for parsing header values into elements.
		 * Instances of this class are stateless and thread-safe.
		 * Derived classes are expected to maintain these properties.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HeaderValueParser.Static {
			new(): Http.BasicHeaderValueParser;
			INSTANCE?: Http.BasicHeaderValueParser;
			/**
			 * Parses elements with the given parser.
			 *
			 * @param value     the header value to parse
			 * @param parser    the parser to use, or {@code null} for default
			 *
			 * @return  array holding the header elements, never {@code null}
			 * @throws ParseException in case of a parsing error
			 */
			parseElements(value: string, parser: Http.HeaderValueParser): array<Http.HeaderElement>;
			/**
			 * Parses an element with the given parser.
			 *
			 * @param value     the header element to parse
			 * @param parser    the parser to use, or {@code null} for default
			 *
			 * @return  the parsed header element
			 */
			parseHeaderElement(value: string, parser: Http.HeaderValueParser): Http.HeaderElement;
			/**
			 * Parses a name-value-pair with the given parser.
			 *
			 * @param value     the NVP to parse
			 * @param parser    the parser to use, or {@code null} for default
			 *
			 * @return  the parsed name-value pair
			 */
			parseNameValuePair(value: string, parser: Http.HeaderValueParser): Http.NameValuePair;
			/**
			 * Parses parameters with the given parser.
			 *
			 * @param value     the parameter list to parse
			 * @param parser    the parser to use, or {@code null} for default
			 *
			 * @return  array holding the parameters, never {@code null}
			 */
			parseParameters(value: string, parser: Http.HeaderValueParser): array<Http.NameValuePair>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicLineParser
	 * Basic parser for lines in the head section of an HTTP message.
	 * There are individual methods for parsing a request line, a
	 * status line, or a header line.
	 * The lines to parse are passed in memory, the parser does not depend
	 * on any specific IO mechanism.
	 * Instances of this class are stateless and thread-safe.
	 * Derived classes MUST maintain these properties.
	 *
	 * 
	 * Note: This class was created by refactoring parsing code located in
	 * various other classes. The author tags from those other classes have
	 * been replicated here, although the association with the parsing code
	 * taken from there has not been traced.
	 * 
	 *
	 * @since 4.0
	 */
	export interface BasicLineParser extends Java.Object, Http.LineParser {
		hasProtocolVersion(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): boolean;
		parseHeader(buffer: Http.CharArrayBuffer): Http.Header;
		parseProtocolVersion(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.ProtocolVersion;
		/**
		 * Parses a request line.
		 *
		 * @param buffer    a buffer holding the line to parse
		 *
		 * @return  the parsed request line
		 *
		 * @throws ParseException        in case of a parse error
		 */
		parseRequestLine(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.RequestLine;
		parseStatusLine(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.StatusLine;
	}
	export module BasicLineParser {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicLineParser
		 * Basic parser for lines in the head section of an HTTP message.
		 * There are individual methods for parsing a request line, a
		 * status line, or a header line.
		 * The lines to parse are passed in memory, the parser does not depend
		 * on any specific IO mechanism.
		 * Instances of this class are stateless and thread-safe.
		 * Derived classes MUST maintain these properties.
		 *
		 * 
		 * Note: This class was created by refactoring parsing code located in
		 * various other classes. The author tags from those other classes have
		 * been replicated here, although the association with the parsing code
		 * taken from there has not been traced.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.LineParser.Static {
			/**
			 * Creates a new line parser for the given HTTP-like protocol.
			 *
			 * @param proto     a version of the protocol to parse, or
			 *                  {@code null} for HTTP. The actual version
			 *                  is not relevant, only the protocol name.
			 */
			new(proto: Http.ProtocolVersion): Http.BasicLineParser;
			/**
			 * Creates a new line parser for HTTP.
			 */
			new(): Http.BasicLineParser;
			INSTANCE?: Http.BasicLineParser;
			parseHeader(value: string, parser: Http.LineParser): Http.Header;
			parseProtocolVersion(value: string, parser: Http.LineParser): Http.ProtocolVersion;
			parseRequestLine(value: string, parser: Http.LineParser): Http.RequestLine;
			parseStatusLine(value: string, parser: Http.LineParser): Http.StatusLine;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.BasicStatusLine
	 * Basic implementation of {@link StatusLine}
	 *
	 * @since 4.0
	 */
	export interface BasicStatusLine extends Java.Object, Http.StatusLine, Java.Cloneable, Java.Serializable {
		clone(): obj;
		getProtocolVersion(): Http.ProtocolVersion;
		getReasonPhrase(): string;
		getStatusCode(): int;
		toString(): string;
	}
	export module BasicStatusLine {
		/**
		 * Corresponding Java class: org.apache.http.message.BasicStatusLine
		 * Basic implementation of {@link StatusLine}
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.StatusLine.Static, Java.Cloneable.Static, Java.Serializable.Static {
			/**
			 * Creates a new status line with the given version, status, and reason.
			 *
			 * @param version           the protocol version of the response
			 * @param statusCode        the status code of the response
			 * @param reasonPhrase      the reason phrase to the status code, or
			 *                          {@code null}
			 */
			new(version: Http.ProtocolVersion, statusCode: int, reasonPhrase: string): Http.BasicStatusLine;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.HeaderValueFormatter
	 * Interface for formatting elements of a header value.
	 * This is the complement to {@link HeaderValueParser}.
	 * Instances of this interface are expected to be stateless and thread-safe.
	 *
	 * 
	 * All formatting methods accept an optional buffer argument.
	 * If a buffer is passed in, the formatted element will be appended
	 * and the modified buffer is returned. If no buffer is passed in,
	 * a new buffer will be created and filled with the formatted element.
	 * In both cases, the caller is allowed to modify the returned buffer.
	 * 
	 *
	 * @since 4.0
	 */
	export interface HeaderValueFormatter extends Java.Object {
		/**
		 * Formats an array of header elements.
		 *
		 * @param buffer    the buffer to append to, or
		 *                  {@code null} to create a new buffer
		 * @param elems     the header elements to format
		 * @param quote     {@code true} to always format with quoted values,
		 *                  {@code false} to use quotes only when necessary
		 *
		 * @return  a buffer with the formatted header elements.
		 *          If the {@code buffer} argument was not {@code null},
		 *          that buffer will be used and returned.
		 */
		formatElements(buffer: Http.CharArrayBuffer, elems: array<Http.HeaderElement>, quote: boolean): Http.CharArrayBuffer;
		/**
		 * Formats one header element.
		 *
		 * @param buffer    the buffer to append to, or
		 *                  {@code null} to create a new buffer
		 * @param elem      the header element to format
		 * @param quote     {@code true} to always format with quoted values,
		 *                  {@code false} to use quotes only when necessary
		 *
		 * @return  a buffer with the formatted header element.
		 *          If the {@code buffer} argument was not {@code null},
		 *          that buffer will be used and returned.
		 */
		formatHeaderElement(buffer: Http.CharArrayBuffer, elem: Http.HeaderElement, quote: boolean): Http.CharArrayBuffer;
		/**
		 * Formats one name-value pair, where the value is optional.
		 *
		 * @param buffer    the buffer to append to, or
		 *                  {@code null} to create a new buffer
		 * @param nvp       the name-value pair to format
		 * @param quote     {@code true} to always format with a quoted value,
		 *                  {@code false} to use quotes only when necessary
		 *
		 * @return  a buffer with the formatted name-value pair.
		 *          If the {@code buffer} argument was not {@code null},
		 *          that buffer will be used and returned.
		 */
		formatNameValuePair(buffer: Http.CharArrayBuffer, nvp: Http.NameValuePair, quote: boolean): Http.CharArrayBuffer;
		/**
		 * Formats the parameters of a header element.
		 * That's a list of name-value pairs, to be separated by semicolons.
		 * This method will not generate a leading semicolon.
		 *
		 * @param buffer    the buffer to append to, or
		 *                  {@code null} to create a new buffer
		 * @param nvps      the parameters (name-value pairs) to format
		 * @param quote     {@code true} to always format with quoted values,
		 *                  {@code false} to use quotes only when necessary
		 *
		 * @return  a buffer with the formatted parameters.
		 *          If the {@code buffer} argument was not {@code null},
		 *          that buffer will be used and returned.
		 */
		formatParameters(buffer: Http.CharArrayBuffer, nvps: array<Http.NameValuePair>, quote: boolean): Http.CharArrayBuffer;
	}
	export module HeaderValueFormatter {
		/**
		 * Corresponding Java class: org.apache.http.message.HeaderValueFormatter
		 * Interface for formatting elements of a header value.
		 * This is the complement to {@link HeaderValueParser}.
		 * Instances of this interface are expected to be stateless and thread-safe.
		 *
		 * 
		 * All formatting methods accept an optional buffer argument.
		 * If a buffer is passed in, the formatted element will be appended
		 * and the modified buffer is returned. If no buffer is passed in,
		 * a new buffer will be created and filled with the formatted element.
		 * In both cases, the caller is allowed to modify the returned buffer.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.HeaderValueParser
	 * Interface for parsing header values into elements.
	 * Instances of this interface are expected to be stateless and thread-safe.
	 *
	 * @since 4.0
	 */
	export interface HeaderValueParser extends Java.Object {
		/**
		 * Parses a header value into elements.
		 * Parse errors are indicated as {@code RuntimeException}.
		 * 
		 * Some HTTP headers (such as the set-cookie header) have values that
		 * can be decomposed into multiple elements. In order to be processed
		 * by this parser, such headers must be in the following form:
		 * 
		 * 
		 * header  = [ element ] *( "," [ element ] )
		 * element = name [ "=" [ value ] ] *( ";" [ param ] )
		 * param   = name [ "=" [ value ] ]
		 *
		 * name    = token
		 * value   = ( token | quoted-string )
		 *
		 * token         = 1*&lt;any char except "=", ",", ";", &lt;"&gt; and
		 *                       white space&gt;
		 * quoted-string = &lt;"&gt; *( text | quoted-char ) &lt;"&gt;
		 * text          = any char except &lt;"&gt;
		 * quoted-char   = "\" char
		 * 
		 * 
		 * Any amount of white space is allowed between any part of the
		 * header, element or param and is ignored. A missing value in any
		 * element or param will be stored as the empty {@link String};
		 * if the "=" is also missing null will be stored instead.
		 * 
		 *
		 * @param buffer    buffer holding the header value to parse
		 * @param cursor    the parser cursor containing the current position and
		 *                  the bounds within the buffer for the parsing operation
		 *
		 * @return  an array holding all elements of the header value
		 *
		 * @throws ParseException        in case of a parsing error
		 */
		parseElements(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): array<Http.HeaderElement>;
		/**
		 * Parses a single header element.
		 * A header element consist of a semicolon-separate list
		 * of name=value definitions.
		 *
		 * @param buffer    buffer holding the element to parse
		 * @param cursor    the parser cursor containing the current position and
		 *                  the bounds within the buffer for the parsing operation
		 *
		 * @return  the parsed element
		 *
		 * @throws ParseException        in case of a parse error
		 */
		parseHeaderElement(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.HeaderElement;
		/**
		 * Parses a name=value specification, where the = and value are optional.
		 *
		 * @param buffer    the buffer holding the name-value pair to parse
		 * @param cursor    the parser cursor containing the current position and
		 *                  the bounds within the buffer for the parsing operation
		 *
		 * @return  the name-value pair, where the value is {@code null}
		 *          if no value is specified
		 */
		parseNameValuePair(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): Http.NameValuePair;
		/**
		 * Parses a list of name-value pairs.
		 * These lists are used to specify parameters to a header element.
		 * Parse errors are indicated as {@code ParseException}.
		 *
		 * @param buffer    buffer holding the name-value list to parse
		 * @param cursor    the parser cursor containing the current position and
		 *                  the bounds within the buffer for the parsing operation
		 *
		 * @return  an array holding all items of the name-value list
		 *
		 * @throws ParseException        in case of a parse error
		 */
		parseParameters(buffer: Http.CharArrayBuffer, cursor: Http.ParserCursor): array<Http.NameValuePair>;
	}
	export module HeaderValueParser {
		/**
		 * Corresponding Java class: org.apache.http.message.HeaderValueParser
		 * Interface for parsing header values into elements.
		 * Instances of this interface are expected to be stateless and thread-safe.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.message.TokenParser
	 * Low level parser for header field elements. The parsing routines of this class are designed
	 * to produce near zero intermediate garbage and make no intermediate copies of input data.
	 * 
	 * This class is immutable and thread safe.
	 *
	 * @since 4.4
	 */
	export interface TokenParser extends Java.Object {
		/**
		 * Transfers content into the destination buffer until a whitespace character or any of
		 * the given delimiters is encountered.
		 *
		 * @param buf buffer with the sequence of chars to be parsed
		 * @param cursor defines the bounds and current position of the buffer
		 * @param delimiters set of delimiting characters. Can be {@code null} if the value
		 *  is delimited by a whitespace only.
		 * @param dst destination buffer
		 */
		copyContent(buf: Http.CharArrayBuffer, cursor: Http.ParserCursor, delimiters: Java.BitSet, dst: Java.StringBuilder): void;
		/**
		 * Transfers content enclosed with quote marks into the destination buffer.
		 *
		 * @param buf buffer with the sequence of chars to be parsed
		 * @param cursor defines the bounds and current position of the buffer
		 * @param dst destination buffer
		 */
		copyQuotedContent(buf: Http.CharArrayBuffer, cursor: Http.ParserCursor, dst: Java.StringBuilder): void;
		/**
		 * Transfers content into the destination buffer until a whitespace character,  a quote,
		 * or any of the given delimiters is encountered.
		 *
		 * @param buf buffer with the sequence of chars to be parsed
		 * @param cursor defines the bounds and current position of the buffer
		 * @param delimiters set of delimiting characters. Can be {@code null} if the value
		 *  is delimited by a whitespace or a quote only.
		 * @param dst destination buffer
		 */
		copyUnquotedContent(buf: Http.CharArrayBuffer, cursor: Http.ParserCursor, delimiters: Java.BitSet, dst: Java.StringBuilder): void;
		/**
		 * Extracts from the sequence of chars a token terminated with any of the given delimiters
		 * discarding semantically insignificant whitespace characters.
		 *
		 * @param buf buffer with the sequence of chars to be parsed
		 * @param cursor defines the bounds and current position of the buffer
		 * @param delimiters set of delimiting characters. Can be {@code null} if the token
		 *  is not delimited by any character.
		 */
		parseToken(buf: Http.CharArrayBuffer, cursor: Http.ParserCursor, delimiters: Java.BitSet): string;
		/**
		 * Extracts from the sequence of chars a value which can be enclosed in quote marks and
		 * terminated with any of the given delimiters discarding semantically insignificant
		 * whitespace characters.
		 *
		 * @param buf buffer with the sequence of chars to be parsed
		 * @param cursor defines the bounds and current position of the buffer
		 * @param delimiters set of delimiting characters. Can be {@code null} if the value
		 *  is not delimited by any character.
		 */
		parseValue(buf: Http.CharArrayBuffer, cursor: Http.ParserCursor, delimiters: Java.BitSet): string;
		/**
		 * Skips semantically insignificant whitespace characters and moves the cursor to the closest
		 * non-whitespace character.
		 *
		 * @param buf buffer with the sequence of chars to be parsed
		 * @param cursor defines the bounds and current position of the buffer
		 */
		skipWhiteSpace(buf: Http.CharArrayBuffer, cursor: Http.ParserCursor): void;
	}
	export module TokenParser {
		/**
		 * Corresponding Java class: org.apache.http.message.TokenParser
		 * Low level parser for header field elements. The parsing routines of this class are designed
		 * to produce near zero intermediate garbage and make no intermediate copies of input data.
		 * 
		 * This class is immutable and thread safe.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.TokenParser;
			/**
			 US-ASCII CR, carriage return (13)
			 */
			CR?: char;
			/**
			 US-ASCII LF, line feed (10)
			 */
			LF?: char;
			/**
			 US-ASCII SP, space (32)
			 */
			SP?: char;
			/**
			 US-ASCII HT, horizontal-tab (9)
			 */
			HT?: char;
			/**
			 Double quote
			 */
			DQUOTE?: char;
			/**
			 Backward slash / escape character
			 */
			ESCAPE?: char;
			INSTANCE?: Http.TokenParser;
			INIT_BITSET(...b: int[]): Java.BitSet;
			INIT_BITSET(b: array<int>): Java.BitSet;
			isWhitespace(ch: char): boolean;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.CoreConnectionPNames
	 * Defines parameter names for connections in HttpCore.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface CoreConnectionPNames extends Java.Object {
	}
	export module CoreConnectionPNames {
		/**
		 * Corresponding Java class: org.apache.http.params.CoreConnectionPNames
		 * Defines parameter names for connections in HttpCore.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.DefaultedHttpParams
	 * {@link HttpParams} implementation that delegates resolution of a parameter
	 * to the given default {@link HttpParams} instance if the parameter is not
	 * present in the local one. The state of the local collection can be mutated,
	 * whereas the default collection is treated as read-only.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface DefaultedHttpParams extends Http.AbstractHttpParams {
	}
	export module DefaultedHttpParams {
		/**
		 * Corresponding Java class: org.apache.http.params.DefaultedHttpParams
		 * {@link HttpParams} implementation that delegates resolution of a parameter
		 * to the given default {@link HttpParams} instance if the parameter is not
		 * present in the local one. The state of the local collection can be mutated,
		 * whereas the default collection is treated as read-only.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Http.AbstractHttpParams.Static {
			new(): Http.DefaultedHttpParams;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.params.HttpParamsNames
	 * Gives access to the full set of parameter names.
	 *
	 * @see HttpParams
	 *
	 * @since 4.2
	 *
	 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
	 *  and 'org.apache.http.client.config'
	 */
	export interface HttpParamsNames extends Java.Object {
	}
	export module HttpParamsNames {
		/**
		 * Corresponding Java class: org.apache.http.params.HttpParamsNames
		 * Gives access to the full set of parameter names.
		 *
		 * @see HttpParams
		 *
		 * @since 4.2
		 *
		 * @deprecated (4.3) use configuration classes provided 'org.apache.http.config'
		 *  and 'org.apache.http.client.config'
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ParseException
	 * Signals a parse error.
	 * Parse errors when receiving a message will typically trigger
	 * {@link ProtocolException}. Parse errors that do not occur during
	 * protocol execution may be handled differently.
	 * This is an unchecked exception, since there are cases where
	 * the data to be parsed has been generated and is therefore
	 * known to be parseable.
	 *
	 * @since 4.0
	 */
	export interface ParseException extends Java.RuntimeException {
	}
	export module ParseException {
		/**
		 * Corresponding Java class: org.apache.http.ParseException
		 * Signals a parse error.
		 * Parse errors when receiving a message will typically trigger
		 * {@link ProtocolException}. Parse errors that do not occur during
		 * protocol execution may be handled differently.
		 * This is an unchecked exception, since there are cases where
		 * the data to be parsed has been generated and is therefore
		 * known to be parseable.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.RuntimeException.Static {
			/**
			 * Creates a {@link ParseException} without details.
			 */
			new(): Http.ParseException;
			/**
			 * Creates a {@link ParseException} with a detail message.
			 *
			 * @param message the exception detail message, or {@code null}
			 */
			new(message: string): Http.ParseException;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.pool.ConnPoolControl
	 * Interface to control runtime properties of a {@link ConnPool} such as
	 * maximum total number of connections or maximum connections per route
	 * allowed.
	 *
	 * @param  the route type that represents the opposite endpoint of a pooled
	 *   connection.
	 * @since 4.2
	 */
	export interface ConnPoolControl<T = any> extends Java.Object {
		getDefaultMaxPerRoute(): int;
		getMaxPerRoute(route: T): int;
		getMaxTotal(): int;
		getStats(route: T): Http.PoolStats;
		getTotalStats(): Http.PoolStats;
		setDefaultMaxPerRoute(max: int): void;
		setMaxPerRoute(route: T, max: int): void;
		setMaxTotal(max: int): void;
	}
	export module ConnPoolControl {
		/**
		 * Corresponding Java class: org.apache.http.pool.ConnPoolControl
		 * Interface to control runtime properties of a {@link ConnPool} such as
		 * maximum total number of connections or maximum connections per route
		 * allowed.
		 *
		 * @param  the route type that represents the opposite endpoint of a pooled
		 *   connection.
		 * @since 4.2
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.pool.RouteSpecificPool
	 */
	export interface RouteSpecificPool<T = any, C = any, E extends PoolEntry<T, C> = any> extends Java.Object {
		add(conn: C): E;
		free(entry: E, reusable: boolean): void;
		getAllocatedCount(): int;
		getAvailableCount(): int;
		getFree(state: obj): E;
		getLastUsed(): E;
		getLeasedCount(): int;
		getPendingCount(): int;
		getRoute(): T;
		nextPending(): Java.Future<E>;
		queue(future: Java.Future<E>): void;
		remove(entry: E): boolean;
		shutdown(): void;
		toString(): string;
		unqueue(future: Java.Future<E>): void;
	}
	export module RouteSpecificPool {
		/**
		 * Corresponding Java class: org.apache.http.pool.RouteSpecificPool
		 */
		export interface Static extends Java.Object.Static {
			new <T, C, E extends PoolEntry<T, C>>(): Http.RouteSpecificPool<T, C, E>;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.DefaultedHttpContext
	 * {@link HttpContext} implementation that delegates resolution of an attribute
	 * to the given default {@link HttpContext} instance if the attribute is not
	 * present in the local one. The state of the local context can be mutated,
	 * whereas the default context is treated as read-only.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.3) no longer used.
	 */
	export interface DefaultedHttpContext extends Java.Object, Http.HttpContext {
	}
	export module DefaultedHttpContext {
		/**
		 * Corresponding Java class: org.apache.http.protocol.DefaultedHttpContext
		 * {@link HttpContext} implementation that delegates resolution of an attribute
		 * to the given default {@link HttpContext} instance if the attribute is not
		 * present in the local one. The state of the local context can be mutated,
		 * whereas the default context is treated as read-only.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.3) no longer used.
		 */
		export interface Static extends Java.Object.Static, Http.HttpContext.Static {
			new(): Http.DefaultedHttpContext;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpCoreContext
	 * Implementation of {@link HttpContext} that provides convenience
	 * setters for user assignable attributes and getter for readable attributes.
	 *
	 * @since 4.3
	 */
	export interface HttpCoreContext extends Java.Object, Http.HttpContext {
		getAttribute(id: string): obj;
		getAttribute<T>(attribname: string, clazz: Java.Class<T>): T;
		getConnection<T extends Http.HttpConnection>(clazz: Java.Class<T>): T;
		getConnection(): Http.HttpConnection;
		getRequest(): Http.HttpRequest;
		getResponse(): Http.HttpResponse;
		getTargetHost(): Http.HttpHost;
		isRequestSent(): boolean;
		removeAttribute(id: string): obj;
		setAttribute(id: string, obj: obj): void;
		setTargetHost(host: Http.HttpHost): void;
	}
	export module HttpCoreContext {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpCoreContext
		 * Implementation of {@link HttpContext} that provides convenience
		 * setters for user assignable attributes and getter for readable attributes.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static, Http.HttpContext.Static {
			new(context: Http.HttpContext): Http.HttpCoreContext;
			new(): Http.HttpCoreContext;
			/**
			 * Attribute name of a {@link org.apache.http.HttpConnection} object that
			 * represents the actual HTTP connection.
			 */
			HTTP_CONNECTION?: string;
			/**
			 * Attribute name of a {@link org.apache.http.HttpRequest} object that
			 * represents the actual HTTP request.
			 */
			HTTP_REQUEST?: string;
			/**
			 * Attribute name of a {@link org.apache.http.HttpResponse} object that
			 * represents the actual HTTP response.
			 */
			HTTP_RESPONSE?: string;
			/**
			 * Attribute name of a {@link org.apache.http.HttpHost} object that
			 * represents the connection target.
			 */
			HTTP_TARGET_HOST?: string;
			/**
			 * Attribute name of a {@link Boolean} object that represents the
			 * the flag indicating whether the actual request has been fully transmitted
			 * to the target host.
			 */
			HTTP_REQ_SENT?: string;
			adapt(context: Http.HttpContext): Http.HttpCoreContext;
			create(): Http.HttpCoreContext;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpProcessorBuilder
	 * Builder for {@link HttpProcessor} instances.
	 *
	 * @since 4.3
	 */
	export interface HttpProcessorBuilder extends Java.Object {
		add(e: Http.HttpRequestInterceptor): Http.HttpProcessorBuilder;
		add(e: Http.HttpResponseInterceptor): Http.HttpProcessorBuilder;
		addAll(...e: Http.HttpRequestInterceptor[]): Http.HttpProcessorBuilder;
		addAll(e: array<Http.HttpRequestInterceptor>): Http.HttpProcessorBuilder;
		addAll(...e: Http.HttpResponseInterceptor[]): Http.HttpProcessorBuilder;
		addAll(e: array<Http.HttpResponseInterceptor>): Http.HttpProcessorBuilder;
		addAllFirst(...e: Http.HttpRequestInterceptor[]): Http.HttpProcessorBuilder;
		addAllFirst(e: array<Http.HttpRequestInterceptor>): Http.HttpProcessorBuilder;
		addAllFirst(...e: Http.HttpResponseInterceptor[]): Http.HttpProcessorBuilder;
		addAllFirst(e: array<Http.HttpResponseInterceptor>): Http.HttpProcessorBuilder;
		addAllLast(...e: Http.HttpRequestInterceptor[]): Http.HttpProcessorBuilder;
		addAllLast(e: array<Http.HttpRequestInterceptor>): Http.HttpProcessorBuilder;
		addAllLast(...e: Http.HttpResponseInterceptor[]): Http.HttpProcessorBuilder;
		addAllLast(e: array<Http.HttpResponseInterceptor>): Http.HttpProcessorBuilder;
		addFirst(e: Http.HttpRequestInterceptor): Http.HttpProcessorBuilder;
		addFirst(e: Http.HttpResponseInterceptor): Http.HttpProcessorBuilder;
		addLast(e: Http.HttpRequestInterceptor): Http.HttpProcessorBuilder;
		addLast(e: Http.HttpResponseInterceptor): Http.HttpProcessorBuilder;
		build(): Http.HttpProcessor;
	}
	export module HttpProcessorBuilder {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpProcessorBuilder
		 * Builder for {@link HttpProcessor} instances.
		 *
		 * @since 4.3
		 */
		export interface Static extends Java.Object.Static {
			new(): Http.HttpProcessorBuilder;
			create(): Http.HttpProcessorBuilder;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpRequestHandlerRegistry
	 * Maintains a map of HTTP request handlers keyed by a request URI pattern.
	 * 
	 * Patterns may have three formats:
	 * 
	 *   {@code *}
	 *   {@code *&lt;uri&gt;}
	 *   {@code &lt;uri&gt;*}
	 * 
	 * 
	 * This class can be used to resolve an instance of
	 * {@link HttpRequestHandler} matching a particular request URI. Usually the
	 * resolved request handler will be used to process the request with the
	 * specified request URI.
	 *
	 * @since 4.0
	 * @deprecated (4.3) use {@link UriHttpRequestHandlerMapper}
	 */
	export interface HttpRequestHandlerRegistry extends Java.Object, Http.HttpRequestHandlerResolver {
	}
	export module HttpRequestHandlerRegistry {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpRequestHandlerRegistry
		 * Maintains a map of HTTP request handlers keyed by a request URI pattern.
		 * 
		 * Patterns may have three formats:
		 * 
		 *   {@code *}
		 *   {@code *&lt;uri&gt;}
		 *   {@code &lt;uri&gt;*}
		 * 
		 * 
		 * This class can be used to resolve an instance of
		 * {@link HttpRequestHandler} matching a particular request URI. Usually the
		 * resolved request handler will be used to process the request with the
		 * specified request URI.
		 *
		 * @since 4.0
		 * @deprecated (4.3) use {@link UriHttpRequestHandlerMapper}
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestHandlerResolver.Static {
			new(): Http.HttpRequestHandlerRegistry;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.HttpService
	 * {@code HttpService} is a server side HTTP protocol handler based on
	 * the classic (blocking) I/O model.
	 * 
	 * {@code HttpService} relies on {@link HttpProcessor} to generate mandatory
	 * protocol headers for all outgoing messages and apply common, cross-cutting
	 * message transformations to all incoming and outgoing messages, whereas
	 * individual {@link HttpRequestHandler}s are expected to implement
	 * application specific content generation and processing.
	 * 
	 * {@code HttpService} uses {@link HttpRequestHandlerMapper} to map
	 * matching request handler for a particular request URI of an incoming HTTP
	 * request.
	 * 
	 * {@code HttpService} can use optional {@link HttpExpectationVerifier}
	 * to ensure that incoming requests meet server's expectations.
	 *
	 * @since 4.0
	 */
	export interface HttpService extends Java.Object {
		/**
		 * Handles receives one HTTP request over the given connection within the
		 * given execution context and sends a response back to the client.
		 *
		 * @param conn the active connection to the client
		 * @param context the actual execution context.
		 * @throws IOException in case of an I/O error.
		 * @throws HttpException in case of HTTP protocol violation or a processing
		 *   problem.
		 */
		handleRequest(conn: Http.HttpServerConnection, context: Http.HttpContext): void;
	}
	export module HttpService {
		/**
		 * Corresponding Java class: org.apache.http.protocol.HttpService
		 * {@code HttpService} is a server side HTTP protocol handler based on
		 * the classic (blocking) I/O model.
		 * 
		 * {@code HttpService} relies on {@link HttpProcessor} to generate mandatory
		 * protocol headers for all outgoing messages and apply common, cross-cutting
		 * message transformations to all incoming and outgoing messages, whereas
		 * individual {@link HttpRequestHandler}s are expected to implement
		 * application specific content generation and processing.
		 * 
		 * {@code HttpService} uses {@link HttpRequestHandlerMapper} to map
		 * matching request handler for a particular request URI of an incoming HTTP
		 * request.
		 * 
		 * {@code HttpService} can use optional {@link HttpExpectationVerifier}
		 * to ensure that incoming requests meet server's expectations.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
			/**
			 * Create a new HTTP service.
			 *
			 * @param processor the processor to use on requests and responses
			 * @param connStrategy the connection reuse strategy. If {@code null}
			 *   {@link DefaultConnectionReuseStrategy#INSTANCE} will be used.
			 * @param responseFactory  the response factory. If {@code null}
			 *   {@link DefaultHttpResponseFactory#INSTANCE} will be used.
			 * @param handlerMapper  the handler mapper. May be null.
			 * @param expectationVerifier the expectation verifier. May be null.
			 *
			 * @since 4.3
			 */
			new(processor: Http.HttpProcessor, connStrategy: Http.ConnectionReuseStrategy, responseFactory: Http.HttpResponseFactory, handlerMapper: Http.HttpRequestHandlerMapper, expectationVerifier: Http.HttpExpectationVerifier): Http.HttpService;
			/**
			 * Create a new HTTP service.
			 *
			 * @param processor the processor to use on requests and responses
			 * @param connStrategy the connection reuse strategy. If {@code null}
			 *   {@link DefaultConnectionReuseStrategy#INSTANCE} will be used.
			 * @param responseFactory  the response factory. If {@code null}
			 *   {@link DefaultHttpResponseFactory#INSTANCE} will be used.
			 * @param handlerMapper  the handler mapper. May be null.
			 *
			 * @since 4.3
			 */
			new(processor: Http.HttpProcessor, connStrategy: Http.ConnectionReuseStrategy, responseFactory: Http.HttpResponseFactory, handlerMapper: Http.HttpRequestHandlerMapper): Http.HttpService;
			/**
			 * Create a new HTTP service.
			 *
			 * @param processor the processor to use on requests and responses
			 * @param handlerMapper  the handler mapper. May be null.
			 *
			 * @since 4.3
			 */
			new(processor: Http.HttpProcessor, handlerMapper: Http.HttpRequestHandlerMapper): Http.HttpService;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.RequestDate
	 * RequestDate interceptor is responsible for adding {@code Date} header
	 * to the outgoing requests This interceptor is optional for client side
	 * protocol processors.
	 *
	 * @since 4.0
	 */
	export interface RequestDate extends Java.Object, Http.HttpRequestInterceptor {
		process(request: Http.HttpRequest, context: Http.HttpContext): void;
	}
	export module RequestDate {
		/**
		 * Corresponding Java class: org.apache.http.protocol.RequestDate
		 * RequestDate interceptor is responsible for adding {@code Date} header
		 * to the outgoing requests This interceptor is optional for client side
		 * protocol processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpRequestInterceptor.Static {
			new(): Http.RequestDate;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.ResponseConnControl
	 * ResponseConnControl is responsible for adding {@code Connection} header
	 * to the outgoing responses, which is essential for managing persistence of
	 * {@code HTTP/1.0} connections. This interceptor is recommended for
	 * server side protocol processors.
	 *
	 * @since 4.0
	 */
	export interface ResponseConnControl extends Java.Object, Http.HttpResponseInterceptor {
		process(response: Http.HttpResponse, context: Http.HttpContext): void;
	}
	export module ResponseConnControl {
		/**
		 * Corresponding Java class: org.apache.http.protocol.ResponseConnControl
		 * ResponseConnControl is responsible for adding {@code Connection} header
		 * to the outgoing responses, which is essential for managing persistence of
		 * {@code HTTP/1.0} connections. This interceptor is recommended for
		 * server side protocol processors.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Http.HttpResponseInterceptor.Static {
			new(): Http.ResponseConnControl;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.protocol.SyncBasicHttpContext
	 * Thread-safe extension of the {@link BasicHttpContext}.
	 *
	 * @since 4.0
	 *
	 * @deprecated (4.2) HttpContext instances may not be shared by multiple threads
	 */
	export interface SyncBasicHttpContext extends Http.BasicHttpContext {
	}
	export module SyncBasicHttpContext {
		/**
		 * Corresponding Java class: org.apache.http.protocol.SyncBasicHttpContext
		 * Thread-safe extension of the {@link BasicHttpContext}.
		 *
		 * @since 4.0
		 *
		 * @deprecated (4.2) HttpContext instances may not be shared by multiple threads
		 */
		export interface Static extends Http.BasicHttpContext.Static {
			new(): Http.SyncBasicHttpContext;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ProtocolVersion
	 * Represents a protocol version. The "major.minor" numbering
	 * scheme is used to indicate versions of the protocol.
	 * 
	 * This class defines a protocol version as a combination of
	 * protocol name, major version number, and minor version number.
	 * Note that {@link #equals} and {@link #hashCode} are defined as
	 * final here, they cannot be overridden in derived classes.
	 * 
	 *
	 * @since 4.0
	 */
	export interface ProtocolVersion extends Java.Object, Java.Serializable, Java.Cloneable {
		clone(): obj;
		/**
		 * Compares this protocol version with another one.
		 * Only protocol versions with the same protocol name can be compared.
		 * This method does not define a total ordering, as it would be
		 * required for {@link java.lang.Comparable}.
		 *
		 * @param that      the protocol version to compare with
		 *
		 * @return   a negative integer, zero, or a positive integer
		 *           as this version is less than, equal to, or greater than
		 *           the argument version.
		 *
		 * @throws IllegalArgumentException
		 *         if the argument has a different protocol name than this object,
		 *         or if the argument is {@code null}
		 */
		compareToVersion(that: Http.ProtocolVersion): int;
		/**
		 * Checks equality of this protocol version with an object.
		 * The object is equal if it is a protocl version with the same
		 * protocol name, major version number, and minor version number.
		 * The specific class of the object is not relevant,
		 * instances of derived classes with identical attributes are
		 * equal to instances of the base class and vice versa.
		 *
		 * @param obj       the object to compare with
		 *
		 * @return  {@code true} if the argument is the same protocol version,
		 *          {@code false} otherwise
		 */
		equals(obj: obj): boolean;
		/**
		 * Obtains a specific version of this protocol.
		 * This can be used by derived classes to instantiate themselves instead
		 * of the base class, and to define constants for commonly used versions.
		 * 
		 * The default implementation in this class returns {@code this}
		 * if the version matches, and creates a new {@link ProtocolVersion}
		 * otherwise.
		 * 
		 *
		 * @param major     the major version
		 * @param minor     the minor version
		 *
		 * @return  a protocol version with the same protocol name
		 *          and the argument version
		 */
		forVersion(major: int, minor: int): Http.ProtocolVersion;
		/**
		 * Returns the major version number of the protocol.
		 *
		 * @return the major version number.
		 */
		getMajor(): int;
		/**
		 * Returns the minor version number of the HTTP protocol.
		 *
		 * @return the minor version number.
		 */
		getMinor(): int;
		/**
		 * Returns the name of the protocol.
		 *
		 * @return the protocol name
		 */
		getProtocol(): string;
		/**
		 * Tests if this protocol version is greater or equal to the given one.
		 *
		 * @param version   the version against which to check this version
		 *
		 * @return  {@code true} if this protocol version is
		 *          {@link #isComparable comparable} to the argument
		 *          and {@link #compareToVersion compares} as greater or equal,
		 *          {@code false} otherwise
		 */
		greaterEquals(version: Http.ProtocolVersion): boolean;
		/**
		 * Obtains a hash code consistent with {@link #equals}.
		 *
		 * @return  the hashcode of this protocol version
		 */
		hashCode(): int;
		/**
		 * Checks whether this protocol can be compared to another one.
		 * Only protocol versions with the same protocol name can be
		 * {@link #compareToVersion compared}.
		 *
		 * @param that      the protocol version to consider
		 *
		 * @return  {@code true} if {@link #compareToVersion compareToVersion}
		 *          can be called with the argument, {@code false} otherwise
		 */
		isComparable(that: Http.ProtocolVersion): boolean;
		/**
		 * Tests if this protocol version is less or equal to the given one.
		 *
		 * @param version   the version against which to check this version
		 *
		 * @return  {@code true} if this protocol version is
		 *          {@link #isComparable comparable} to the argument
		 *          and {@link #compareToVersion compares} as less or equal,
		 *          {@code false} otherwise
		 */
		lessEquals(version: Http.ProtocolVersion): boolean;
		/**
		 * Converts this protocol version to a string.
		 *
		 * @return  a protocol version string, like "HTTP/1.1"
		 */
		toString(): string;
	}
	export module ProtocolVersion {
		/**
		 * Corresponding Java class: org.apache.http.ProtocolVersion
		 * Represents a protocol version. The "major.minor" numbering
		 * scheme is used to indicate versions of the protocol.
		 * 
		 * This class defines a protocol version as a combination of
		 * protocol name, major version number, and minor version number.
		 * Note that {@link #equals} and {@link #hashCode} are defined as
		 * final here, they cannot be overridden in derived classes.
		 * 
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static, Java.Serializable.Static, Java.Cloneable.Static {
			/**
			 * Create a protocol version designator.
			 *
			 * @param protocol   the name of the protocol, for example "HTTP"
			 * @param major      the major version number of the protocol
			 * @param minor      the minor version number of the protocol
			 */
			new(protocol: string, major: int, minor: int): Http.ProtocolVersion;
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.ssl.PrivateKeyStrategy
	 * A strategy allowing for a choice of an alias during SSL authentication.
	 *
	 * @since 4.4
	 */
	export interface PrivateKeyStrategy extends Java.Object {
		/**
		 * Determines what key material to use for SSL authentication.
		 *
		 * @param aliases available private key material
		 * @param socket socket used for the connection. Please note this parameter can be {@code null}
		 * if key material is applicable to any socket.
		 */
		chooseAlias(aliases: Java.Map<string, Http.PrivateKeyDetails>, socket: Java.Socket): string;
	}
	export module PrivateKeyStrategy {
		/**
		 * Corresponding Java class: org.apache.http.ssl.PrivateKeyStrategy
		 * A strategy allowing for a choice of an alias during SSL authentication.
		 *
		 * @since 4.4
		 */
		export interface Static extends Java.Object.Static {
		}
	}

	/**
	 * Corresponding Java class: org.apache.http.io.SessionOutputBuffer
	 * Session output buffer for blocking connections. This interface is similar to
	 * OutputStream class, but it also provides methods for writing lines of text.
	 * 
	 * Implementing classes are also expected to manage intermediate data buffering
	 * for optimal output performance.
	 *
	 * @since 4.0
	 */
	export interface SessionOutputBuffer extends Java.Object {
		/**
		 * Flushes this session buffer and forces any buffered output bytes
		 * to be written out. The general contract of {@code flush} is
		 * that calling it is an indication that, if any bytes previously
		 * written have been buffered by the implementation of the output
		 * stream, such bytes should immediately be written to their
		 * intended destination.
		 *
		 * @throws  IOException  if an I/O error occurs.
		 */
		flush(): void;
		/**
		 * Returns {@link HttpTransportMetrics} for this session buffer.
		 *
		 * @return transport metrics.
		 */
		getMetrics(): Http.HttpTransportMetrics;
		/**
		 * Writes {@code len} bytes from the specified byte array
		 * starting at offset {@code off} to this session buffer.
		 * 
		 * If {@code off} is negative, or {@code len} is negative, or
		 * {@code off+len} is greater than the length of the array
		 * {@code b}, then an {@code IndexOutOfBoundsException} is thrown.
		 *
		 * @param      b     the data.
		 * @param      off   the start offset in the data.
		 * @param      len   the number of bytes to write.
		 * @throws  IOException  if an I/O error occurs.
		 */
		write(b: array<byte>, off: int, len: int): void;
		/**
		 * Writes {@code b.length} bytes from the specified byte array
		 * to this session buffer.
		 *
		 * @param      b   the data.
		 * @throws  IOException  if an I/O error occurs.
		 */
		write(b: array<byte>): void;
		/**
		 * Writes the specified byte to this session buffer.
		 *
		 * @param      b   the {@code byte}.
		 * @throws  IOException  if an I/O error occurs.
		 */
		write(b: int): void;
		/**
		 * Writes characters from the specified string followed by a line delimiter
		 * to this session buffer.
		 * 
		 * The choice of a char encoding and line delimiter sequence is up to the
		 * specific implementations of this interface.
		 *
		 * @param      s   the line.
		 * @throws  IOException  if an I/O error occurs.
		 */
		writeLine(s: string): void;
		/**
		 * Writes characters from the specified char array followed by a line
		 * delimiter to this session buffer.
		 * 
		 * The choice of a char encoding and line delimiter sequence is up to the
		 * specific implementations of this interface.
		 *
		 * @param      buffer   the buffer containing chars of the line.
		 * @throws  IOException  if an I/O error occurs.
		 */
		writeLine(buffer: Http.CharArrayBuffer): void;
	}
	export module SessionOutputBuffer {
		/**
		 * Corresponding Java class: org.apache.http.io.SessionOutputBuffer
		 * Session output buffer for blocking connections. This interface is similar to
		 * OutputStream class, but it also provides methods for writing lines of text.
		 * 
		 * Implementing classes are also expected to manage intermediate data buffering
		 * for optimal output performance.
		 *
		 * @since 4.0
		 */
		export interface Static extends Java.Object.Static {
		}
	}
}

module Commons.Logging {
	export interface Log {
	}
	export module Log {
		export interface Static {
		}
	}
}

module JGSS {
	/**
	 * Corresponding Java class: org.ietf.jgss.GSSCredential
	 */
	export interface GSSCredential extends Java.Cloneable {
		add(name: JGSS.GSSName, initLifetime: int, acceptLifetime: int, mech: JGSS.Oid, usage: int): void;
		dispose(): void;
		equals(another: obj): boolean;
		getMechs(): array<JGSS.Oid>;
		getName(): JGSS.GSSName;
		getName(mech: JGSS.Oid): JGSS.GSSName;
		getRemainingAcceptLifetime(mech: JGSS.Oid): int;
		getRemainingInitLifetime(mech: JGSS.Oid): int;
		getRemainingLifetime(): int;
		getUsage(): int;
		getUsage(mech: JGSS.Oid): int;
		hashCode(): int;
	}
	export module GSSCredential {
		/**
		 * Corresponding Java class: org.ietf.jgss.GSSCredential
		 */
		export interface Static extends Java.Cloneable.Static {
			INITIATE_AND_ACCEPT?: int;
			INITIATE_ONLY?: int;
			ACCEPT_ONLY?: int;
			DEFAULT_LIFETIME?: int;
			INDEFINITE_LIFETIME?: int;
		}
	}

	/**
	 * Corresponding Java class: org.ietf.jgss.GSSName
	 */
	export interface GSSName extends Java.Object {
		canonicalize(mech: JGSS.Oid): JGSS.GSSName;
		equals(another: JGSS.GSSName): boolean;
		equals(another: obj): boolean;
		export(): array<byte>;
		getStringNameType(): JGSS.Oid;
		hashCode(): int;
		isAnonymous(): boolean;
		isMN(): boolean;
		toString(): string;
	}
	export module GSSName {
		/**
		 * Corresponding Java class: org.ietf.jgss.GSSName
		 */
		export interface Static extends Java.Object.Static {
			NT_HOSTBASED_SERVICE?: JGSS.Oid;
			NT_USER_NAME?: JGSS.Oid;
			NT_MACHINE_UID_NAME?: JGSS.Oid;
			NT_STRING_UID_NAME?: JGSS.Oid;
			NT_ANONYMOUS?: JGSS.Oid;
			NT_EXPORT_NAME?: JGSS.Oid;
		}
	}

	/**
	 * Corresponding Java class: org.ietf.jgss.Oid
	 */
	export interface Oid extends Java.Object {
		containedIn(oids: array<JGSS.Oid>): boolean;
		equals(other: obj): boolean;
		getDER(): array<byte>;
		hashCode(): int;
		toString(): string;
	}
	export module Oid {
		/**
		 * Corresponding Java class: org.ietf.jgss.Oid
		 */
		export interface Static extends Java.Object.Static {
			new(strOid: string): JGSS.Oid;
			new(derOid: Java.InputStream): JGSS.Oid;
			new(data: array<byte>): JGSS.Oid;
		}
	}
}

declare namespace Java {
	function type(className: "java.lang.Object"): Java.Object.Static;
	function type(className: "java.io.Serializable"): Java.Serializable.Static;
	function type(className: "java.lang.String"): Java.String.Static;
	function type(className: "java.util.Map"): Java.Map.Static;
	function type(className: "java.util.Map.Entry"): Java.Map$Entry.Static;
	function type(className: "java.util.Queue"): Java.Queue.Static;
	function type(className: "java.net.URI"): Java.URI.Static;
	function type(className: "java.util.List"): Java.List.Static;
	function type(className: "java.lang.Class"): Java.Class.Static;
	function type(className: "java.lang.Class.MethodArray"): Java.Class$MethodArray.Static;
	function type(className: "java.lang.Cloneable"): Java.Cloneable.Static;
	function type(className: "java.net.InetAddress"): Java.InetAddress.Static;
	function type(className: "java.net.InetAddress.InetAddressHolder"): Java.InetAddress$InetAddressHolder.Static;
	function type(className: "java.net.InetAddress.CacheEntry"): Java.InetAddress$CacheEntry.Static;
	function type(className: "java.net.InetAddress.Cache"): Java.InetAddress$Cache.Static;
	function type(className: "java.util.Collection"): Java.Collection.Static;
	function type(className: "java.lang.Throwable"): Java.Throwable.Static;
	function type(className: "java.io.InputStream"): Java.InputStream.Static;
	function type(className: "java.io.IOException"): Java.IOException.Static;
	function type(className: "java.io.File"): Java.File.Static;
	function type(className: "javax.net.ssl.HostnameVerifier"): Java.HostnameVerifier.Static;
	function type(className: "javax.net.ssl.SSLSession"): Java.SSLSession.Static;
	function type(className: "java.lang.IllegalStateException"): Java.IllegalStateException.Static;
	function type(className: "java.lang.Enum"): Java.Enum.Static;
	function type(className: "java.util.Random"): Java.Random.Static;
	function type(className: "java.util.Random.RandomIntsSpliterator"): Java.Random$RandomIntsSpliterator.Static;
	function type(className: "java.util.Random.RandomLongsSpliterator"): Java.Random$RandomLongsSpliterator.Static;
	function type(className: "java.util.Random.RandomDoublesSpliterator"): Java.Random$RandomDoublesSpliterator.Static;
	function type(className: "java.nio.charset.Charset"): Java.Charset.Static;
	function type(className: "java.util.AbstractList"): Java.AbstractList.Static;
	function type(className: "java.util.concurrent.ThreadFactory"): Java.ThreadFactory.Static;
	function type(className: "java.util.concurrent.TimeUnit"): Java.TimeUnit.Static;
	function type(className: "java.lang.Thread"): Java.Thread.Static;
	function type(className: "java.lang.Thread.UncaughtExceptionHandler"): Java.Thread$UncaughtExceptionHandler.Static;
	function type(className: "java.lang.Thread.WeakClassKey"): Java.Thread$WeakClassKey.Static;
	function type(className: "java.lang.Runnable"): Java.Runnable.Static;
	function type(className: "java.util.Date"): Java.Date.Static;
	function type(className: "java.io.OutputStream"): Java.OutputStream.Static;
	function type(className: "java.net.InetSocketAddress"): Java.InetSocketAddress.Static;
	function type(className: "java.nio.charset.CharsetDecoder"): Java.CharsetDecoder.Static;
	function type(className: "java.nio.charset.CharsetEncoder"): Java.CharsetEncoder.Static;
	function type(className: "java.net.Socket"): Java.Socket.Static;
	function type(className: "java.util.Comparator"): Java.Comparator.Static;
	function type(className: "java.util.Set"): Java.Set.Static;
	function type(className: "java.util.TimeZone"): Java.TimeZone.Static;
	function type(className: "java.security.Principal"): Java.Principal.Static;
	function type(className: "java.lang.RuntimeException"): Java.RuntimeException.Static;
	function type(className: "java.text.SimpleDateFormat"): Java.SimpleDateFormat.Static;
	function type(className: "java.io.Closeable"): Java.Closeable.Static;
	function type(className: "javax.net.ssl.SSLContext"): Java.SSLContext.Static;
	function type(className: "java.net.ProxySelector"): Java.ProxySelector.Static;
	function type(className: "java.lang.ref.WeakReference"): Java.WeakReference.Static;
	function type(className: "java.security.cert.X509Certificate"): Java.X509Certificate.Static;
	function type(className: "java.util.zip.Inflater"): Java.Inflater.Static;
	function type(className: "java.io.InterruptedIOException"): Java.InterruptedIOException.Static;
	function type(className: "javax.net.ssl.SSLSocketFactory"): Java.SSLSocketFactory.Static;
	function type(className: "java.net.URL"): Java.URL.Static;
	function type(className: "java.net.ConnectException"): Java.ConnectException.Static;
	function type(className: "java.io.Reader"): Java.Reader.Static;
	function type(className: "java.lang.Exception"): Java.Exception.Static;
	function type(className: "java.lang.Iterable"): Java.Iterable.Static;
	function type(className: "java.util.zip.InflaterInputStream"): Java.InflaterInputStream.Static;
	function type(className: "java.util.concurrent.ExecutorService"): Java.ExecutorService.Static;
	function type(className: "java.util.concurrent.FutureTask"): Java.FutureTask.Static;
	function type(className: "java.util.concurrent.FutureTask.WaitNode"): Java.FutureTask$WaitNode.Static;
	function type(className: "java.util.concurrent.Callable"): Java.Callable.Static;
	function type(className: "java.util.Locale"): Java.Locale.Static;
	function type(className: "java.util.Locale.Builder"): Java.Locale$Builder.Static;
	function type(className: "java.util.Locale.LanguageRange"): Java.Locale$LanguageRange.Static;
	function type(className: "java.util.concurrent.Future"): Java.Future.Static;
	function type(className: "java.nio.charset.CodingErrorAction"): Java.CodingErrorAction.Static;
	function type(className: "java.util.Iterator"): Java.Iterator.Static;
	function type(className: "java.net.ServerSocket"): Java.ServerSocket.Static;
	function type(className: "javax.net.ssl.SSLServerSocket"): Java.SSLServerSocket.Static;
	function type(className: "javax.net.SocketFactory"): Java.SocketFactory.Static;
	function type(className: "java.nio.charset.CharacterCodingException"): Java.CharacterCodingException.Static;
	function type(className: "java.lang.CharSequence"): Java.CharSequence.Static;
	function type(className: "java.lang.StringBuilder"): Java.StringBuilder.Static;
	function type(className: "java.net.SocketAddress"): Java.SocketAddress.Static;
	function type(className: "java.lang.ClassLoader"): Java.ClassLoader.Static;
	function type(className: "java.lang.ClassLoader.NativeLibrary"): Java.ClassLoader$NativeLibrary.Static;
	function type(className: "java.util.concurrent.ThreadPoolExecutor"): Java.ThreadPoolExecutor.Static;
	function type(className: "java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy"): Java.ThreadPoolExecutor$CallerRunsPolicy.Static;
	function type(className: "java.util.concurrent.ThreadPoolExecutor.AbortPolicy"): Java.ThreadPoolExecutor$AbortPolicy.Static;
	function type(className: "java.util.concurrent.ThreadPoolExecutor.DiscardPolicy"): Java.ThreadPoolExecutor$DiscardPolicy.Static;
	function type(className: "java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy"): Java.ThreadPoolExecutor$DiscardOldestPolicy.Static;
	function type(className: "java.util.concurrent.BlockingQueue"): Java.BlockingQueue.Static;
	function type(className: "java.util.LinkedList"): Java.LinkedList.Static;
	function type(className: "java.util.LinkedList.LLSpliterator"): Java.LinkedList$LLSpliterator.Static;
	function type(className: "java.lang.reflect.InvocationHandler"): Java.InvocationHandler.Static;
	function type(className: "java.security.SecureRandom"): Java.SecureRandom.Static;
	function type(className: "java.security.Provider"): Java.Provider.Static;
	function type(className: "java.security.Provider.Service"): Java.Provider$Service.Static;
	function type(className: "javax.net.ssl.X509TrustManager"): Java.X509TrustManager.Static;
	function type(className: "javax.net.ssl.X509ExtendedKeyManager"): Java.X509ExtendedKeyManager.Static;
	function type(className: "java.security.PrivateKey"): Java.PrivateKey.Static;
	function type(className: "javax.net.ssl.SSLEngine"): Java.SSLEngine.Static;
	function type(className: "javax.net.ServerSocketFactory"): Java.ServerSocketFactory.Static;
	function type(className: "java.util.BitSet"): Java.BitSet.Static;
	function type(className: "java.security.KeyStore"): Java.KeyStore.Static;
	function type(className: "java.security.KeyStore.LoadStoreParameter"): Java.KeyStore$LoadStoreParameter.Static;
	function type(className: "java.security.KeyStore.ProtectionParameter"): Java.KeyStore$ProtectionParameter.Static;
	function type(className: "java.security.KeyStore.PasswordProtection"): Java.KeyStore$PasswordProtection.Static;
	function type(className: "java.security.KeyStore.CallbackHandlerProtection"): Java.KeyStore$CallbackHandlerProtection.Static;
	function type(className: "java.security.KeyStore.Entry"): Java.KeyStore$Entry.Static;
	function type(className: "java.security.KeyStore.Entry.Attribute"): Java.KeyStore$Entry$Attribute.Static;
	function type(className: "java.security.KeyStore.PrivateKeyEntry"): Java.KeyStore$PrivateKeyEntry.Static;
	function type(className: "java.security.KeyStore.SecretKeyEntry"): Java.KeyStore$SecretKeyEntry.Static;
	function type(className: "java.security.KeyStore.TrustedCertificateEntry"): Java.KeyStore$TrustedCertificateEntry.Static;
	function type(className: "java.security.KeyStore.Builder"): Java.KeyStore$Builder.Static;
	function type(className: "java.security.KeyStore.SimpleLoadStoreParameter"): Java.KeyStore$SimpleLoadStoreParameter.Static;
	function type(className: "org.apache.http.auth.params.AuthParams"): Http.AuthParams.Static;
	function type(className: "org.apache.http.auth.AuthSchemeProvider"): Http.AuthSchemeProvider.Static;
	function type(className: "org.apache.http.auth.AuthSchemeFactory"): Http.AuthSchemeFactory.Static;
	function type(className: "org.apache.http.auth.UsernamePasswordCredentials"): Http.UsernamePasswordCredentials.Static;
	function type(className: "org.apache.http.auth.KerberosCredentials"): Http.KerberosCredentials.Static;
	function type(className: "org.apache.http.cookie.CookieSpecRegistry"): Http.CookieSpecRegistry.Static;
	function type(className: "org.apache.http.client.AuthenticationStrategy"): Http.AuthenticationStrategy.Static;
	function type(className: "org.apache.http.client.methods.HttpPatch"): Http.HttpPatch.Static;
	function type(className: "org.apache.http.client.methods.HttpDelete"): Http.HttpDelete.Static;
	function type(className: "org.apache.http.client.methods.HttpHead"): Http.HttpHead.Static;
	function type(className: "org.apache.http.client.methods.Configurable"): Http.Configurable.Static;
	function type(className: "org.apache.http.client.CredentialsProvider"): Http.CredentialsProvider.Static;
	function type(className: "org.apache.http.client.methods.HttpRequestBase"): Http.HttpRequestBase.Static;
	function type(className: "org.apache.http.client.UserTokenHandler"): Http.UserTokenHandler.Static;
	function type(className: "org.apache.http.client.params.ClientParamBean"): Http.ClientParamBean.Static;
	function type(className: "org.apache.http.client.utils.Idn"): Http.Idn.Static;
	function type(className: "org.apache.http.client.params.AllClientPNames"): Http.AllClientPNames.Static;
	function type(className: "org.apache.http.client.utils.HttpClientUtils"): Http.HttpClientUtils.Static;
	function type(className: "org.apache.http.client.protocol.RequestClientConnControl"): Http.RequestClientConnControl.Static;
	function type(className: "org.apache.http.client.protocol.RequestAuthCache"): Http.RequestAuthCache.Static;
	function type(className: "org.apache.http.client.protocol.ClientContextConfigurer"): Http.ClientContextConfigurer.Static;
	function type(className: "org.apache.http.client.protocol.RequestExpectContinue"): Http.ClientRequestExpectContinue.Static;
	function type(className: "org.apache.http.client.protocol.RequestAddCookies"): Http.RequestAddCookies.Static;
	function type(className: "org.apache.http.client.protocol.RequestAuthenticationBase"): Http.RequestAuthenticationBase.Static;
	function type(className: "org.apache.http.client.protocol.ResponseContentEncoding"): Http.ResponseContentEncoding.Static;
	function type(className: "org.apache.http.client.protocol.HttpClientContext"): Http.HttpClientContext.Static;
	function type(className: "org.apache.http.client.config.RequestConfig"): Http.RequestConfig.Static;
	function type(className: "org.apache.http.client.config.RequestConfig.Builder"): Http.RequestConfig$Builder.Static;
	function type(className: "org.apache.http.client.config.CookieSpecs"): Http.CookieSpecs.Static;
	function type(className: "org.apache.http.client.config.AuthSchemes"): Http.AuthSchemes.Static;
	function type(className: "org.apache.http.client.RedirectException"): Http.RedirectException.Static;
	function type(className: "org.apache.http.client.BackoffManager"): Http.BackoffManager.Static;
	function type(className: "org.apache.http.client.entity.InputStreamFactory"): Http.InputStreamFactory.Static;
	function type(className: "org.apache.http.client.entity.DeflateDecompressingEntity"): Http.DeflateDecompressingEntity.Static;
	function type(className: "org.apache.http.client.HttpRequestRetryHandler"): Http.HttpRequestRetryHandler.Static;
	function type(className: "org.apache.http.client.entity.EntityBuilder"): Http.EntityBuilder.Static;
	function type(className: "org.apache.http.conn.OperatedClientConnection"): Http.OperatedClientConnection.Static;
	function type(className: "org.apache.http.conn.EofSensorInputStream"): Http.EofSensorInputStream.Static;
	function type(className: "org.apache.http.conn.ssl.StrictHostnameVerifier"): Http.StrictHostnameVerifier.Static;
	function type(className: "org.apache.http.conn.ssl.SSLSocketFactory"): Http.SSLSocketFactory.Static;
	function type(className: "org.apache.http.conn.ssl.NoopHostnameVerifier"): Http.NoopHostnameVerifier.Static;
	function type(className: "org.apache.http.conn.scheme.PlainSocketFactory"): Http.PlainSocketFactory.Static;
	function type(className: "org.apache.http.conn.scheme.SchemeRegistry"): Http.SchemeRegistry.Static;
	function type(className: "org.apache.http.conn.ssl.SSLInitializationException"): Http.ConnectionSSLInitializationException.Static;
	function type(className: "org.apache.http.conn.scheme.SchemeSocketFactory"): Http.SchemeSocketFactory.Static;
	function type(className: "org.apache.http.conn.UnsupportedSchemeException"): Http.UnsupportedSchemeException.Static;
	function type(className: "org.apache.http.conn.scheme.SchemeLayeredSocketFactoryAdaptor"): Http.SchemeLayeredSocketFactoryAdaptor.Static;
	function type(className: "org.apache.http.impl.auth.KerberosScheme"): Http.KerberosScheme.Static;
	function type(className: "org.apache.http.impl.auth.SPNegoScheme"): Http.SPNegoScheme.Static;
	function type(className: "org.apache.http.impl.auth.NegotiateScheme"): Http.NegotiateScheme.Static;
	function type(className: "org.apache.http.impl.auth.GGSSchemeBase"): Http.GGSSchemeBase.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineImpl"): Http.NTLMEngineImpl.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineImpl.CipherGen"): Http.NTLMEngineImpl$CipherGen.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineImpl.Handle"): Http.NTLMEngineImpl$Handle.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineImpl.NTLMMessage"): Http.NTLMEngineImpl$NTLMMessage.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineImpl.Type1Message"): Http.NTLMEngineImpl$Type1Message.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineImpl.Type2Message"): Http.NTLMEngineImpl$Type2Message.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineImpl.Type3Message"): Http.NTLMEngineImpl$Type3Message.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineImpl.MD4"): Http.NTLMEngineImpl$MD4.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineImpl.HMACMD5"): Http.NTLMEngineImpl$HMACMD5.Static;
	function type(className: "org.apache.http.impl.auth.NegotiateSchemeFactory"): Http.NegotiateSchemeFactory.Static;
	function type(className: "org.apache.http.impl.auth.SpnegoTokenGenerator"): Http.SpnegoTokenGenerator.Static;
	function type(className: "org.apache.http.impl.auth.HttpAuthenticator"): Http.HttpAuthenticator.Static;
	function type(className: "org.apache.http.impl.auth.SPNegoSchemeFactory"): Http.SPNegoSchemeFactory.Static;
	function type(className: "org.apache.http.impl.auth.RFC2617Scheme"): Http.RFC2617Scheme.Static;
	function type(className: "org.apache.http.impl.client.AutoRetryHttpClient"): Http.AutoRetryHttpClient.Static;
	function type(className: "org.apache.http.impl.client.ContentEncodingHttpClient"): Http.ContentEncodingHttpClient.Static;
	function type(className: "org.apache.http.impl.client.RedirectLocations"): Http.RedirectLocations.Static;
	function type(className: "org.apache.http.impl.client.DefaultHttpRequestRetryHandler"): Http.DefaultHttpRequestRetryHandler.Static;
	function type(className: "org.apache.http.impl.client.StandardHttpRequestRetryHandler"): Http.StandardHttpRequestRetryHandler.Static;
	function type(className: "org.apache.http.impl.client.AbstractAuthenticationHandler"): Http.AbstractAuthenticationHandler.Static;
	function type(className: "org.apache.http.impl.client.SystemClock"): Http.SystemClock.Static;
	function type(className: "org.apache.http.impl.client.Clock"): Http.Clock.Static;
	function type(className: "org.apache.http.impl.client.DefaultConnectionKeepAliveStrategy"): Http.DefaultConnectionKeepAliveStrategy.Static;
	function type(className: "org.apache.http.impl.client.AuthenticationStrategyAdaptor"): Http.AuthenticationStrategyAdaptor.Static;
	function type(className: "org.apache.http.impl.client.IdleConnectionEvictor"): Http.IdleConnectionEvictor.Static;
	function type(className: "org.apache.http.impl.client.IdleConnectionEvictor.DefaultThreadFactory"): Http.IdleConnectionEvictor$DefaultThreadFactory.Static;
	function type(className: "org.apache.http.impl.client.SystemDefaultCredentialsProvider"): Http.SystemDefaultCredentialsProvider.Static;
	function type(className: "org.apache.http.impl.client.FutureRequestExecutionMetrics"): Http.FutureRequestExecutionMetrics.Static;
	function type(className: "org.apache.http.impl.client.FutureRequestExecutionMetrics.DurationCounter"): Http.FutureRequestExecutionMetrics$DurationCounter.Static;
	function type(className: "org.apache.http.impl.client.NullBackoffStrategy"): Http.NullBackoffStrategy.Static;
	function type(className: "org.apache.http.impl.client.DefaultBackoffStrategy"): Http.DefaultBackoffStrategy.Static;
	function type(className: "org.apache.http.impl.client.BasicCookieStore"): Http.BasicCookieStore.Static;
	function type(className: "org.apache.http.impl.client.DefaultClientConnectionReuseStrategy"): Http.DefaultClientConnectionReuseStrategy.Static;
	function type(className: "org.apache.http.impl.client.DefaultRedirectHandler"): Http.DefaultRedirectHandler.Static;
	function type(className: "org.apache.http.impl.client.TunnelRefusedException"): Http.ClientTunnelRefusedException.Static;
	function type(className: "org.apache.http.impl.client.MinimalHttpClient"): Http.MinimalHttpClient.Static;
	function type(className: "org.apache.http.impl.client.BasicResponseHandler"): Http.BasicResponseHandler.Static;
	function type(className: "org.apache.http.impl.client.ClientParamsStack"): Http.ClientParamsStack.Static;
	function type(className: "org.apache.http.impl.client.DefaultTargetAuthenticationHandler"): Http.DefaultTargetAuthenticationHandler.Static;
	function type(className: "org.apache.http.impl.client.DefaultHttpClient"): Http.DefaultHttpClient.Static;
	function type(className: "org.apache.http.impl.client.RequestWrapper"): Http.RequestWrapper.Static;
	function type(className: "org.apache.http.impl.execchain.RequestEntityProxy"): Http.RequestEntityProxy.Static;
	function type(className: "org.apache.http.impl.execchain.ResponseEntityProxy"): Http.ResponseEntityProxy.Static;
	function type(className: "org.apache.http.impl.execchain.MainClientExec"): Http.MainClientExec.Static;
	function type(className: "org.apache.http.impl.conn.DefaultClientConnection"): Http.DefaultClientConnection.Static;
	function type(className: "org.apache.http.impl.conn.DefaultHttpRoutePlanner"): Http.DefaultHttpRoutePlanner.Static;
	function type(className: "org.apache.http.impl.conn.DefaultHttpClientConnectionOperator"): Http.DefaultHttpClientConnectionOperator.Static;
	function type(className: "org.apache.http.impl.conn.ConnectionShutdownException"): Http.ConnectionShutdownException.Static;
	function type(className: "org.apache.http.impl.conn.ManagedClientConnectionImpl"): Http.ManagedClientConnectionImpl.Static;
	function type(className: "org.apache.http.impl.conn.DefaultManagedHttpClientConnection"): Http.DefaultManagedHttpClientConnection.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.WaitingThread"): Http.WaitingThread.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.ConnPoolByRoute"): Http.ConnPoolByRoute.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.BasicPooledConnAdapter"): Http.BasicPooledConnAdapter.Static;
	function type(className: "org.apache.http.impl.conn.AbstractPooledConnAdapter"): Http.AbstractPooledConnAdapter.Static;
	function type(className: "org.apache.http.impl.conn.DefaultClientConnectionOperator"): Http.DefaultClientConnectionOperator.Static;
	function type(className: "org.apache.http.impl.conn.CPoolEntry"): Http.CPoolEntry.Static;
	function type(className: "org.apache.http.impl.conn.DefaultRoutePlanner"): Http.DefaultRoutePlanner.Static;
	function type(className: "org.apache.http.impl.conn.DefaultHttpResponseParserFactory"): Http.ConnectionDefaultHttpResponseParserFactory.Static;
	function type(className: "org.apache.http.impl.conn.ProxySelectorRoutePlanner"): Http.ProxySelectorRoutePlanner.Static;
	function type(className: "org.apache.http.auth.AuthSchemeRegistry"): Http.AuthSchemeRegistry.Static;
	function type(className: "org.apache.http.auth.NTCredentials"): Http.NTCredentials.Static;
	function type(className: "org.apache.http.auth.params.AuthPNames"): Http.AuthPNames.Static;
	function type(className: "org.apache.http.auth.BasicUserPrincipal"): Http.BasicUserPrincipal.Static;
	function type(className: "org.apache.http.auth.AuthScope"): Http.AuthScope.Static;
	function type(className: "org.apache.http.auth.AuthOption"): Http.AuthOption.Static;
	function type(className: "org.apache.http.impl.conn.DefaultHttpResponseParser"): Http.ConnectionDefaultHttpResponseParser.Static;
	function type(className: "org.apache.http.cookie.CookieRestrictionViolationException"): Http.CookieRestrictionViolationException.Static;
	function type(className: "org.apache.http.cookie.CookieIdentityComparator"): Http.CookieIdentityComparator.Static;
	function type(className: "org.apache.http.cookie.SM"): Http.SM.Static;
	function type(className: "org.apache.http.cookie.CookieOrigin"): Http.CookieOrigin.Static;
	function type(className: "org.apache.http.cookie.CookieAttributeHandler"): Http.CookieAttributeHandler.Static;
	function type(className: "org.apache.http.cookie.SetCookie2"): Http.SetCookie2.Static;
	function type(className: "org.apache.http.cookie.CookieSpec"): Http.CookieSpec.Static;
	function type(className: "org.apache.http.cookie.params.CookieSpecPNames"): Http.CookieSpecPNames.Static;
	function type(className: "org.apache.http.cookie.MalformedCookieException"): Http.MalformedCookieException.Static;
	function type(className: "org.apache.http.cookie.ClientCookie"): Http.ClientCookie.Static;
	function type(className: "org.apache.http.cookie.CommonCookieAttributeHandler"): Http.CommonCookieAttributeHandler.Static;
	function type(className: "org.apache.http.cookie.CookiePathComparator"): Http.CookiePathComparator.Static;
	function type(className: "org.apache.http.cookie.SetCookie"): Http.SetCookie.Static;
	function type(className: "org.apache.http.cookie.Cookie"): Http.Cookie.Static;
	function type(className: "org.apache.http.cookie.CookieSpecProvider"): Http.CookieSpecProvider.Static;
	function type(className: "org.apache.http.cookie.CookiePriorityComparator"): Http.CookiePriorityComparator.Static;
	function type(className: "org.apache.http.client.ConnectionBackoffStrategy"): Http.ConnectionBackoffStrategy.Static;
	function type(className: "org.apache.http.client.methods.HttpOptions"): Http.HttpOptions.Static;
	function type(className: "org.apache.http.cookie.params.CookieSpecParamBean"): Http.CookieSpecParamBean.Static;
	function type(className: "org.apache.http.client.methods.RequestBuilder"): Http.RequestBuilder.Static;
	function type(className: "org.apache.http.client.methods.RequestBuilder.InternalRequest"): Http.RequestBuilder$InternalRequest.Static;
	function type(className: "org.apache.http.client.methods.RequestBuilder.InternalEntityEclosingRequest"): Http.RequestBuilder$InternalEntityEclosingRequest.Static;
	function type(className: "org.apache.http.client.methods.HttpExecutionAware"): Http.HttpExecutionAware.Static;
	function type(className: "org.apache.http.client.methods.HttpEntityEnclosingRequestBase"): Http.HttpEntityEnclosingRequestBase.Static;
	function type(className: "org.apache.http.client.params.ClientPNames"): Http.ClientPNames.Static;
	function type(className: "org.apache.http.client.utils.Punycode"): Http.Punycode.Static;
	function type(className: "org.apache.http.client.utils.URIUtils"): Http.URIUtils.Static;
	function type(className: "org.apache.http.client.utils.JdkIdn"): Http.JdkIdn.Static;
	function type(className: "org.apache.http.client.utils.CloneUtils"): Http.CloneUtils.Static;
	function type(className: "org.apache.http.client.utils.DateUtils"): Http.DateUtils.Static;
	function type(className: "org.apache.http.client.utils.DateUtils.DateFormatHolder"): Http.DateUtils$DateFormatHolder.Static;
	function type(className: "org.apache.http.client.utils.Rfc3492Idn"): Http.Rfc3492Idn.Static;
	function type(className: "org.apache.http.client.protocol.ResponseProcessCookies"): Http.ResponseProcessCookies.Static;
	function type(className: "org.apache.http.client.protocol.ClientContext"): Http.ClientContext.Static;
	function type(className: "org.apache.http.client.protocol.ResponseAuthCache"): Http.ResponseAuthCache.Static;
	function type(className: "org.apache.http.client.protocol.RequestProxyAuthentication"): Http.RequestProxyAuthentication.Static;
	function type(className: "org.apache.http.client.methods.HttpPost"): Http.HttpPost.Static;
	function type(className: "org.apache.http.conn.BasicManagedEntity"): Http.BasicManagedEntity.Static;
	function type(className: "org.apache.http.conn.ConnectionKeepAliveStrategy"): Http.ConnectionKeepAliveStrategy.Static;
	function type(className: "org.apache.http.conn.HttpClientConnectionOperator"): Http.HttpClientConnectionOperator.Static;
	function type(className: "org.apache.http.conn.BasicEofSensorWatcher"): Http.BasicEofSensorWatcher.Static;
	function type(className: "org.apache.http.conn.HttpClientConnectionManager"): Http.HttpClientConnectionManager.Static;
	function type(className: "org.apache.http.conn.HttpRoutedConnection"): Http.HttpRoutedConnection.Static;
	function type(className: "org.apache.http.conn.EofSensorWatcher"): Http.EofSensorWatcher.Static;
	function type(className: "org.apache.http.conn.ManagedHttpClientConnection"): Http.ManagedHttpClientConnection.Static;
	function type(className: "org.apache.http.conn.routing.BasicRouteDirector"): Http.BasicRouteDirector.Static;
	function type(className: "org.apache.http.conn.routing.RouteInfo"): Http.RouteInfo.Static;
	function type(className: "org.apache.http.conn.routing.HttpRouteDirector"): Http.HttpRouteDirector.Static;
	function type(className: "org.apache.http.conn.routing.HttpRoutePlanner"): Http.HttpRoutePlanner.Static;
	function type(className: "org.apache.http.conn.routing.RouteTracker"): Http.RouteTracker.Static;
	function type(className: "org.apache.http.conn.SchemePortResolver"): Http.SchemePortResolver.Static;
	function type(className: "org.apache.http.conn.ClientConnectionManager"): Http.ClientConnectionManager.Static;
	function type(className: "org.apache.http.conn.routing.HttpRoute"): Http.HttpRoute.Static;
	function type(className: "org.apache.http.conn.params.ConnManagerParamBean"): Http.ConnManagerParamBean.Static;
	function type(className: "org.apache.http.conn.params.ConnManagerPNames"): Http.ConnManagerPNames.Static;
	function type(className: "org.apache.http.conn.params.ConnConnectionParamBean"): Http.ConnConnectionParamBean.Static;
	function type(className: "org.apache.http.conn.params.ConnPerRouteBean"): Http.ConnPerRouteBean.Static;
	function type(className: "org.apache.http.conn.params.ConnPerRoute"): Http.ConnPerRoute.Static;
	function type(className: "org.apache.http.conn.params.ConnRouteParams"): Http.ConnRouteParams.Static;
	function type(className: "org.apache.http.conn.params.ConnRouteParamBean"): Http.ConnRouteParamBean.Static;
	function type(className: "org.apache.http.conn.ssl.X509HostnameVerifier"): Http.X509HostnameVerifier.Static;
	function type(className: "org.apache.http.conn.ssl.AbstractVerifier"): Http.AbstractVerifier.Static;
	function type(className: "org.apache.http.conn.ssl.SubjectName"): Http.SubjectName.Static;
	function type(className: "org.apache.http.conn.ssl.SSLContexts"): Http.ConnectionSSLContexts.Static;
	function type(className: "org.apache.http.conn.ssl.AllowAllHostnameVerifier"): Http.AllowAllHostnameVerifier.Static;
	function type(className: "org.apache.http.conn.socket.LayeredConnectionSocketFactory"): Http.LayeredConnectionSocketFactory.Static;
	function type(className: "org.apache.http.conn.ConnectionPoolTimeoutException"): Http.ConnectionPoolTimeoutException.Static;
	function type(className: "org.apache.http.conn.ConnectionReleaseTrigger"): Http.ConnectionReleaseTrigger.Static;
	function type(className: "org.apache.http.conn.ClientConnectionManagerFactory"): Http.ClientConnectionManagerFactory.Static;
	function type(className: "org.apache.http.conn.scheme.SchemeSocketFactoryAdaptor"): Http.SchemeSocketFactoryAdaptor.Static;
	function type(className: "org.apache.http.conn.scheme.Scheme"): Http.Scheme.Static;
	function type(className: "org.apache.http.conn.scheme.LayeredSchemeSocketFactory"): Http.LayeredSchemeSocketFactory.Static;
	function type(className: "org.apache.http.impl.auth.UnsupportedDigestAlgorithmException"): Http.UnsupportedDigestAlgorithmException.Static;
	function type(className: "org.apache.http.conn.ssl.DefaultHostnameVerifier"): Http.DefaultHostnameVerifier.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2965DiscardAttributeHandler"): Http.RFC2965DiscardAttributeHandler.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2109Spec"): Http.RFC2109Spec.Static;
	function type(className: "org.apache.http.impl.cookie.PublicSuffixFilter"): Http.PublicSuffixFilter.Static;
	function type(className: "org.apache.http.impl.cookie.BasicDomainHandler"): Http.BasicDomainHandler.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2109VersionHandler"): Http.RFC2109VersionHandler.Static;
	function type(className: "org.apache.http.impl.cookie.BasicMaxAgeHandler"): Http.BasicMaxAgeHandler.Static;
	function type(className: "org.apache.http.impl.cookie.LaxExpiresHandler"): Http.LaxExpiresHandler.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2965SpecFactory"): Http.RFC2965SpecFactory.Static;
	function type(className: "org.apache.http.impl.cookie.DefaultCookieSpec"): Http.DefaultCookieSpec.Static;
	function type(className: "org.apache.http.impl.cookie.BrowserCompatVersionAttributeHandler"): Http.BrowserCompatVersionAttributeHandler.Static;
	function type(className: "org.apache.http.impl.cookie.IgnoreSpec"): Http.IgnoreSpec.Static;
	function type(className: "org.apache.http.impl.cookie.BestMatchSpecFactory"): Http.BestMatchSpecFactory.Static;
	function type(className: "org.apache.http.impl.cookie.RFC6265StrictSpec"): Http.RFC6265StrictSpec.Static;
	function type(className: "org.apache.http.impl.cookie.IgnoreSpecProvider"): Http.IgnoreSpecProvider.Static;
	function type(className: "org.apache.http.impl.cookie.BasicClientCookie2"): Http.BasicClientCookie2.Static;
	function type(className: "org.apache.http.impl.cookie.RFC6265CookieSpecBase"): Http.RFC6265CookieSpecBase.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2965SpecProvider"): Http.RFC2965SpecProvider.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2965DomainAttributeHandler"): Http.RFC2965DomainAttributeHandler.Static;
	function type(className: "org.apache.http.impl.cookie.IgnoreSpecFactory"): Http.IgnoreSpecFactory.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2965VersionAttributeHandler"): Http.RFC2965VersionAttributeHandler.Static;
	function type(className: "org.apache.http.impl.cookie.BrowserCompatSpecFactory"): Http.BrowserCompatSpecFactory.Static;
	function type(className: "org.apache.http.impl.cookie.CookieSpecBase"): Http.CookieSpecBase.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2109SpecFactory"): Http.RFC2109SpecFactory.Static;
	function type(className: "org.apache.http.impl.cookie.PublicSuffixListParser"): Http.CookiePublicSuffixListParser.Static;
	function type(className: "org.apache.http.impl.cookie.AbstractCookieSpec"): Http.AbstractCookieSpec.Static;
	function type(className: "org.apache.http.impl.cookie.NetscapeDraftHeaderParser"): Http.NetscapeDraftHeaderParser.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2965CommentUrlAttributeHandler"): Http.RFC2965CommentUrlAttributeHandler.Static;
	function type(className: "org.apache.http.impl.client.TargetAuthenticationStrategy"): Http.TargetAuthenticationStrategy.Static;
	function type(className: "org.apache.http.impl.client.NoopUserTokenHandler"): Http.NoopUserTokenHandler.Static;
	function type(className: "org.apache.http.impl.client.AuthenticationStrategyImpl"): Http.AuthenticationStrategyImpl.Static;
	function type(className: "org.apache.http.impl.client.DefaultRedirectStrategy"): Http.DefaultRedirectStrategy.Static;
	function type(className: "org.apache.http.impl.cookie.BasicCommentHandler"): Http.BasicCommentHandler.Static;
	function type(className: "org.apache.http.impl.client.ProxyAuthenticationStrategy"): Http.ProxyAuthenticationStrategy.Static;
	function type(className: "org.apache.http.impl.execchain.ProtocolExec"): Http.ProtocolExec.Static;
	function type(className: "org.apache.http.impl.execchain.RedirectExec"): Http.RedirectExec.Static;
	function type(className: "org.apache.http.impl.execchain.ConnectionHolder"): Http.ConnectionHolder.Static;
	function type(className: "org.apache.http.impl.execchain.RetryExec"): Http.RetryExec.Static;
	function type(className: "org.apache.http.impl.execchain.BackoffStrategyExec"): Http.BackoffStrategyExec.Static;
	function type(className: "org.apache.http.impl.client.HttpClientBuilder"): Http.HttpClientBuilder.Static;
	function type(className: "org.apache.http.impl.conn.Wire"): Http.Wire.Static;
	function type(className: "org.apache.http.impl.conn.IdleConnectionHandler"): Http.IdleConnectionHandler.Static;
	function type(className: "org.apache.http.impl.conn.ManagedHttpClientConnectionFactory"): Http.ManagedHttpClientConnectionFactory.Static;
	function type(className: "org.apache.http.impl.conn.PoolingClientConnectionManager"): Http.PoolingClientConnectionManager.Static;
	function type(className: "org.apache.http.impl.conn.LoggingInputStream"): Http.LoggingInputStream.Static;
	function type(className: "org.apache.http.impl.conn.SystemDefaultRoutePlanner"): Http.SystemDefaultRoutePlanner.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.PoolEntryRequest"): Http.PoolEntryRequest.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager"): Http.ThreadSafeClientConnManager.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.WaitingThreadAborter"): Http.WaitingThreadAborter.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.BasicPoolEntryRef"): Http.BasicPoolEntryRef.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.BasicPoolEntry"): Http.ConnectionBasicPoolEntry.Static;
	function type(className: "org.apache.http.impl.conn.AbstractPoolEntry"): Http.AbstractPoolEntry.Static;
	function type(className: "org.apache.http.impl.conn.LoggingManagedHttpClientConnection"): Http.LoggingManagedHttpClientConnection.Static;
	function type(className: "org.apache.http.impl.conn.DefaultSchemePortResolver"): Http.DefaultSchemePortResolver.Static;
	function type(className: "org.apache.http.impl.conn.SingleClientConnManager"): Http.SingleClientConnManager.Static;
	function type(className: "org.apache.http.impl.conn.BasicClientConnectionManager"): Http.BasicClientConnectionManager.Static;
	function type(className: "org.apache.http.auth.ChallengeState"): Http.ChallengeState.Static;
	function type(className: "org.apache.http.auth.InvalidCredentialsException"): Http.InvalidCredentialsException.Static;
	function type(className: "org.apache.http.auth.AuthenticationException"): Http.AuthenticationException.Static;
	function type(className: "org.apache.http.auth.AUTH"): Http.AUTH.Static;
	function type(className: "org.apache.http.auth.MalformedChallengeException"): Http.MalformedChallengeException.Static;
	function type(className: "org.apache.http.cookie.CookieSpecFactory"): Http.CookieSpecFactory.Static;
	function type(className: "org.apache.http.client.HttpClient"): Http.HttpClient.Static;
	function type(className: "org.apache.http.client.methods.CloseableHttpResponse"): Http.CloseableHttpResponse.Static;
	function type(className: "org.apache.http.client.methods.AbstractExecutionAwareRequest"): Http.AbstractExecutionAwareRequest.Static;
	function type(className: "org.apache.http.client.methods.HttpTrace"): Http.HttpTrace.Static;
	function type(className: "org.apache.http.client.CookieStore"): Http.CookieStore.Static;
	function type(className: "org.apache.http.client.HttpResponseException"): Http.HttpResponseException.Static;
	function type(className: "org.apache.http.client.ClientProtocolException"): Http.ClientProtocolException.Static;
	function type(className: "org.apache.http.client.AuthenticationHandler"): Http.AuthenticationHandler.Static;
	function type(className: "org.apache.http.client.params.CookiePolicy"): Http.CookiePolicy.Static;
	function type(className: "org.apache.http.client.CircularRedirectException"): Http.CircularRedirectException.Static;
	function type(className: "org.apache.http.client.utils.URIBuilder"): Http.URIBuilder.Static;
	function type(className: "org.apache.http.client.AuthCache"): Http.AuthCache.Static;
	function type(className: "org.apache.http.client.RedirectHandler"): Http.RedirectHandler.Static;
	function type(className: "org.apache.http.client.entity.DeflateInputStream"): Http.DeflateInputStream.Static;
	function type(className: "org.apache.http.client.entity.DeflateInputStream.DeflateStream"): Http.DeflateInputStream$DeflateStream.Static;
	function type(className: "org.apache.http.client.entity.GzipCompressingEntity"): Http.GzipCompressingEntity.Static;
	function type(className: "org.apache.http.client.entity.DecompressingEntity"): Http.DecompressingEntity.Static;
	function type(className: "org.apache.http.client.entity.GZIPInputStreamFactory"): Http.GZIPInputStreamFactory.Static;
	function type(className: "org.apache.http.client.RequestDirector"): Http.RequestDirector.Static;
	function type(className: "org.apache.http.conn.ManagedClientConnection"): Http.ManagedClientConnection.Static;
	function type(className: "org.apache.http.conn.ClientConnectionOperator"): Http.ClientConnectionOperator.Static;
	function type(className: "org.apache.http.conn.socket.ConnectionSocketFactory"): Http.ConnectionSocketFactory.Static;
	function type(className: "org.apache.http.conn.ssl.TrustSelfSignedStrategy"): Http.TrustSelfSignedStrategy.Static;
	function type(className: "org.apache.http.impl.conn.CPool"): Http.CPool.Static;
	function type(className: "org.apache.http.conn.ssl.PrivateKeyStrategy"): Http.ConnectionPrivateKeyStrategy.Static;
	function type(className: "org.apache.http.conn.ssl.TrustStrategy"): Http.ConnectionTrustStrategy.Static;
	function type(className: "org.apache.http.conn.ssl.SSLContextBuilder"): Http.ConnectionSSLContextBuilder.Static;
	function type(className: "org.apache.http.conn.ssl.PrivateKeyDetails"): Http.ConnectionPrivateKeyDetails.Static;
	function type(className: "org.apache.http.conn.scheme.LayeredSocketFactoryAdaptor"): Http.LayeredSocketFactoryAdaptor.Static;
	function type(className: "org.apache.http.conn.scheme.SchemeLayeredSocketFactoryAdaptor2"): Http.SchemeLayeredSocketFactoryAdaptor2.Static;
	function type(className: "org.apache.http.conn.scheme.SocketFactory"): Http.SocketFactory.Static;
	function type(className: "org.apache.http.conn.scheme.LayeredSocketFactory"): Http.LayeredSocketFactory.Static;
	function type(className: "org.apache.http.conn.ConnectTimeoutException"): Http.ConnectTimeoutException.Static;
	function type(className: "org.apache.http.conn.util.DomainType"): Http.DomainType.Static;
	function type(className: "org.apache.http.conn.ssl.SSLConnectionSocketFactory"): Http.SSLConnectionSocketFactory.Static;
	function type(className: "org.apache.http.conn.util.InetAddressUtils"): Http.InetAddressUtils.Static;
	function type(className: "org.apache.http.conn.util.PublicSuffixMatcher"): Http.PublicSuffixMatcher.Static;
	function type(className: "org.apache.http.conn.util.PublicSuffixList"): Http.PublicSuffixList.Static;
	function type(className: "org.apache.http.conn.util.PublicSuffixMatcherLoader"): Http.PublicSuffixMatcherLoader.Static;
	function type(className: "org.apache.http.conn.HttpInetSocketAddress"): Http.HttpInetSocketAddress.Static;
	function type(className: "org.apache.http.conn.HttpConnectionFactory"): Http.ConnectionHttpConnectionFactory.Static;
	function type(className: "org.apache.http.conn.HttpHostConnectException"): Http.HttpHostConnectException.Static;
	function type(className: "org.apache.http.conn.DnsResolver"): Http.DnsResolver.Static;
	function type(className: "org.apache.http.conn.MultihomePlainSocketFactory"): Http.MultihomePlainSocketFactory.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngineException"): Http.NTLMEngineException.Static;
	function type(className: "org.apache.http.impl.auth.KerberosSchemeFactory"): Http.KerberosSchemeFactory.Static;
	function type(className: "org.apache.http.impl.auth.NTLMScheme"): Http.NTLMScheme.Static;
	function type(className: "org.apache.http.impl.auth.HttpEntityDigester"): Http.HttpEntityDigester.Static;
	function type(className: "org.apache.http.impl.auth.BasicSchemeFactory"): Http.BasicSchemeFactory.Static;
	function type(className: "org.apache.http.impl.auth.NTLMSchemeFactory"): Http.NTLMSchemeFactory.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2109DomainHandler"): Http.RFC2109DomainHandler.Static;
	function type(className: "org.apache.http.conn.util.PublicSuffixListParser"): Http.PublicSuffixListParser.Static;
	function type(className: "org.apache.http.impl.cookie.BasicExpiresHandler"): Http.BasicExpiresHandler.Static;
	function type(className: "org.apache.http.impl.cookie.BrowserCompatSpec"): Http.BrowserCompatSpec.Static;
	function type(className: "org.apache.http.impl.cookie.RFC6265CookieSpecProvider"): Http.RFC6265CookieSpecProvider.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2965PortAttributeHandler"): Http.RFC2965PortAttributeHandler.Static;
	function type(className: "org.apache.http.impl.cookie.BasicClientCookie"): Http.BasicClientCookie.Static;
	function type(className: "org.apache.http.impl.cookie.BasicPathHandler"): Http.BasicPathHandler.Static;
	function type(className: "org.apache.http.impl.cookie.LaxMaxAgeHandler"): Http.LaxMaxAgeHandler.Static;
	function type(className: "org.apache.http.impl.cookie.NetscapeDomainHandler"): Http.NetscapeDomainHandler.Static;
	function type(className: "org.apache.http.impl.cookie.PublicSuffixDomainFilter"): Http.PublicSuffixDomainFilter.Static;
	function type(className: "org.apache.http.impl.cookie.AbstractCookieAttributeHandler"): Http.AbstractCookieAttributeHandler.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2109SpecProvider"): Http.RFC2109SpecProvider.Static;
	function type(className: "org.apache.http.impl.cookie.NetscapeDraftSpecFactory"): Http.NetscapeDraftSpecFactory.Static;
	function type(className: "org.apache.http.impl.cookie.RFC6265LaxSpec"): Http.RFC6265LaxSpec.Static;
	function type(className: "org.apache.http.impl.cookie.DateParseException"): Http.DateParseException.Static;
	function type(className: "org.apache.http.impl.client.DefaultRedirectStrategyAdaptor"): Http.DefaultRedirectStrategyAdaptor.Static;
	function type(className: "org.apache.http.impl.client.AbstractHttpClient"): Http.AbstractHttpClient.Static;
	function type(className: "org.apache.http.impl.client.InternalHttpClient"): Http.InternalHttpClient.Static;
	function type(className: "org.apache.http.impl.client.HttpAuthenticator"): Http.ClientHttpAuthenticator.Static;
	function type(className: "org.apache.http.impl.client.EntityEnclosingRequestWrapper"): Http.EntityEnclosingRequestWrapper.Static;
	function type(className: "org.apache.http.impl.cookie.NetscapeDraftSpec"): Http.NetscapeDraftSpec.Static;
	function type(className: "org.apache.http.impl.client.DefaultServiceUnavailableRetryStrategy"): Http.DefaultServiceUnavailableRetryStrategy.Static;
	function type(className: "org.apache.http.impl.client.HttpClients"): Http.HttpClients.Static;
	function type(className: "org.apache.http.impl.client.CloseableHttpClient"): Http.CloseableHttpClient.Static;
	function type(className: "org.apache.http.impl.client.BasicAuthCache"): Http.BasicAuthCache.Static;
	function type(className: "org.apache.http.impl.client.DefaultUserTokenHandler"): Http.DefaultUserTokenHandler.Static;
	function type(className: "org.apache.http.impl.client.DefaultRequestDirector"): Http.DefaultRequestDirector.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.AbstractConnPool"): Http.ConnectionAbstractConnPool.Static;
	function type(className: "org.apache.http.impl.conn.SchemeRegistryFactory"): Http.SchemeRegistryFactory.Static;
	function type(className: "org.apache.http.impl.conn.LoggingSessionOutputBuffer"): Http.LoggingSessionOutputBuffer.Static;
	function type(className: "org.apache.http.impl.conn.DefaultProxyRoutePlanner"): Http.DefaultProxyRoutePlanner.Static;
	function type(className: "org.apache.http.impl.conn.BasicHttpClientConnectionManager"): Http.BasicHttpClientConnectionManager.Static;
	function type(className: "org.apache.http.impl.conn.InMemoryDnsResolver"): Http.InMemoryDnsResolver.Static;
	function type(className: "org.apache.http.impl.conn.HttpConnPool"): Http.HttpConnPool.Static;
	function type(className: "org.apache.http.impl.conn.HttpConnPool.InternalConnFactory"): Http.HttpConnPool$InternalConnFactory.Static;
	function type(className: "org.apache.http.impl.conn.SystemDefaultDnsResolver"): Http.SystemDefaultDnsResolver.Static;
	function type(className: "org.apache.http.auth.NTUserPrincipal"): Http.NTUserPrincipal.Static;
	function type(className: "org.apache.http.auth.AuthScheme"): Http.AuthScheme.Static;
	function type(className: "org.apache.http.impl.client.CookieSpecRegistries"): Http.CookieSpecRegistries.Static;
	function type(className: "org.apache.http.auth.ContextAwareAuthScheme"): Http.ContextAwareAuthScheme.Static;
	function type(className: "org.apache.http.auth.AuthProtocolState"): Http.AuthProtocolState.Static;
	function type(className: "org.apache.http.auth.Credentials"): Http.Credentials.Static;
	function type(className: "org.apache.http.auth.AuthState"): Http.AuthState.Static;
	function type(className: "org.apache.http.client.RedirectStrategy"): Http.RedirectStrategy.Static;
	function type(className: "org.apache.http.client.methods.AbortableHttpRequest"): Http.AbortableHttpRequest.Static;
	function type(className: "org.apache.http.client.methods.HttpGet"): Http.HttpGet.Static;
	function type(className: "org.apache.http.client.methods.HttpUriRequest"): Http.HttpUriRequest.Static;
	function type(className: "org.apache.http.client.methods.HttpRequestWrapper"): Http.HttpRequestWrapper.Static;
	function type(className: "org.apache.http.client.methods.HttpRequestWrapper.HttpEntityEnclosingRequestWrapper"): Http.HttpRequestWrapper$HttpEntityEnclosingRequestWrapper.Static;
	function type(className: "org.apache.http.client.methods.HttpPut"): Http.HttpPut.Static;
	function type(className: "org.apache.http.client.params.HttpClientParams"): Http.HttpClientParams.Static;
	function type(className: "org.apache.http.client.params.AuthPolicy"): Http.AuthPolicy.Static;
	function type(className: "org.apache.http.client.params.HttpClientParamConfig"): Http.HttpClientParamConfig.Static;
	function type(className: "org.apache.http.client.utils.URLEncodedUtils"): Http.URLEncodedUtils.Static;
	function type(className: "org.apache.http.client.protocol.RequestAcceptEncoding"): Http.RequestAcceptEncoding.Static;
	function type(className: "org.apache.http.client.protocol.RequestDefaultHeaders"): Http.RequestDefaultHeaders.Static;
	function type(className: "org.apache.http.client.protocol.RequestTargetAuthentication"): Http.RequestTargetAuthentication.Static;
	function type(className: "org.apache.http.client.ResponseHandler"): Http.ResponseHandler.Static;
	function type(className: "org.apache.http.client.NonRepeatableRequestException"): Http.NonRepeatableRequestException.Static;
	function type(className: "org.apache.http.client.entity.UrlEncodedFormEntity"): Http.UrlEncodedFormEntity.Static;
	function type(className: "org.apache.http.client.entity.LazyDecompressingInputStream"): Http.LazyDecompressingInputStream.Static;
	function type(className: "org.apache.http.client.entity.GzipDecompressingEntity"): Http.GzipDecompressingEntity.Static;
	function type(className: "org.apache.http.client.entity.DeflateInputStreamFactory"): Http.DeflateInputStreamFactory.Static;
	function type(className: "org.apache.http.client.ServiceUnavailableRetryStrategy"): Http.ServiceUnavailableRetryStrategy.Static;
	function type(className: "org.apache.http.conn.ConnectionRequest"): Http.ConnectionRequest.Static;
	function type(className: "org.apache.http.conn.params.ConnManagerParams"): Http.ConnManagerParams.Static;
	function type(className: "org.apache.http.conn.params.ConnConnectionPNames"): Http.ConnConnectionPNames.Static;
	function type(className: "org.apache.http.conn.params.ConnRoutePNames"): Http.ConnRoutePNames.Static;
	function type(className: "org.apache.http.conn.socket.PlainConnectionSocketFactory"): Http.PlainConnectionSocketFactory.Static;
	function type(className: "org.apache.http.conn.ClientConnectionRequest"): Http.ClientConnectionRequest.Static;
	function type(className: "org.apache.http.conn.ssl.TrustAllStrategy"): Http.TrustAllStrategy.Static;
	function type(className: "org.apache.http.conn.ssl.BrowserCompatHostnameVerifier"): Http.BrowserCompatHostnameVerifier.Static;
	function type(className: "org.apache.http.conn.scheme.SchemeLayeredSocketFactory"): Http.SchemeLayeredSocketFactory.Static;
	function type(className: "org.apache.http.conn.scheme.HostNameResolver"): Http.HostNameResolver.Static;
	function type(className: "org.apache.http.conn.scheme.SocketFactoryAdaptor"): Http.SocketFactoryAdaptor.Static;
	function type(className: "org.apache.http.impl.auth.NTLMEngine"): Http.NTLMEngine.Static;
	function type(className: "org.apache.http.impl.auth.DigestScheme"): Http.DigestScheme.Static;
	function type(className: "org.apache.http.impl.auth.AuthSchemeBase"): Http.AuthSchemeBase.Static;
	function type(className: "org.apache.http.impl.auth.DigestSchemeFactory"): Http.DigestSchemeFactory.Static;
	function type(className: "org.apache.http.impl.auth.BasicScheme"): Http.BasicScheme.Static;
	function type(className: "org.apache.http.impl.cookie.BestMatchSpec"): Http.BestMatchSpec.Static;
	function type(className: "org.apache.http.impl.cookie.BasicSecureHandler"): Http.BasicSecureHandler.Static;
	function type(className: "org.apache.http.impl.cookie.RFC2965Spec"): Http.RFC2965Spec.Static;
	function type(className: "org.apache.http.impl.cookie.DefaultCookieSpecProvider"): Http.DefaultCookieSpecProvider.Static;
	function type(className: "org.apache.http.impl.cookie.RFC6265CookieSpec"): Http.RFC6265CookieSpec.Static;
	function type(className: "org.apache.http.impl.cookie.DateUtils"): Http.CookieDateUtils.Static;
	function type(className: "org.apache.http.impl.cookie.NetscapeDraftSpecProvider"): Http.NetscapeDraftSpecProvider.Static;
	function type(className: "org.apache.http.impl.client.LaxRedirectStrategy"): Http.LaxRedirectStrategy.Static;
	function type(className: "org.apache.http.impl.client.RoutedRequest"): Http.RoutedRequest.Static;
	function type(className: "org.apache.http.impl.client.CloseableHttpResponseProxy"): Http.CloseableHttpResponseProxy.Static;
	function type(className: "org.apache.http.impl.client.DefaultProxyAuthenticationHandler"): Http.DefaultProxyAuthenticationHandler.Static;
	function type(className: "org.apache.http.impl.client.FutureRequestExecutionService"): Http.FutureRequestExecutionService.Static;
	function type(className: "org.apache.http.impl.client.BasicCredentialsProvider"): Http.BasicCredentialsProvider.Static;
	function type(className: "org.apache.http.impl.client.AbstractResponseHandler"): Http.AbstractResponseHandler.Static;
	function type(className: "org.apache.http.impl.client.HttpRequestFutureTask"): Http.HttpRequestFutureTask.Static;
	function type(className: "org.apache.http.impl.client.ProxyClient"): Http.ProxyClient.Static;
	function type(className: "org.apache.http.impl.client.HttpRequestTaskCallable"): Http.HttpRequestTaskCallable.Static;
	function type(className: "org.apache.http.impl.client.AIMDBackoffManager"): Http.AIMDBackoffManager.Static;
	function type(className: "org.apache.http.impl.client.DecompressingHttpClient"): Http.DecompressingHttpClient.Static;
	function type(className: "org.apache.http.impl.client.SystemDefaultHttpClient"): Http.SystemDefaultHttpClient.Static;
	function type(className: "org.apache.http.impl.execchain.ServiceUnavailableRetryExec"): Http.ServiceUnavailableRetryExec.Static;
	function type(className: "org.apache.http.impl.execchain.MinimalClientExec"): Http.MinimalClientExec.Static;
	function type(className: "org.apache.http.impl.execchain.ClientExecChain"): Http.ClientExecChain.Static;
	function type(className: "org.apache.http.impl.execchain.HttpResponseProxy"): Http.HttpResponseProxy.Static;
	function type(className: "org.apache.http.impl.execchain.TunnelRefusedException"): Http.TunnelRefusedException.Static;
	function type(className: "org.apache.http.impl.execchain.RequestAbortedException"): Http.RequestAbortedException.Static;
	function type(className: "org.apache.http.impl.conn.HttpPoolEntry"): Http.HttpPoolEntry.Static;
	function type(className: "org.apache.http.impl.conn.PoolingHttpClientConnectionManager"): Http.PoolingHttpClientConnectionManager.Static;
	function type(className: "org.apache.http.impl.conn.PoolingHttpClientConnectionManager.ConfigData"): Http.PoolingHttpClientConnectionManager$ConfigData.Static;
	function type(className: "org.apache.http.impl.conn.PoolingHttpClientConnectionManager.InternalConnectionFactory"): Http.PoolingHttpClientConnectionManager$InternalConnectionFactory.Static;
	function type(className: "org.apache.http.impl.conn.CPoolProxy"): Http.CPoolProxy.Static;
	function type(className: "org.apache.http.impl.conn.LoggingSessionInputBuffer"): Http.LoggingSessionInputBuffer.Static;
	function type(className: "org.apache.http.impl.conn.LoggingOutputStream"): Http.LoggingOutputStream.Static;
	function type(className: "org.apache.http.impl.conn.DefaultResponseParser"): Http.DefaultResponseParser.Static;
	function type(className: "org.apache.http.impl.conn.AbstractClientConnAdapter"): Http.AbstractClientConnAdapter.Static;
	function type(className: "org.apache.http.impl.conn.tsccm.RouteSpecificPool"): Http.ConnectionRouteSpecificPool.Static;
	function type(className: "org.apache.http.annotation.ThreadingBehavior"): Http.ThreadingBehavior.Static;
	function type(className: "org.apache.http.concurrent.BasicFuture"): Http.BasicFuture.Static;
	function type(className: "org.apache.http.concurrent.Cancellable"): Http.Cancellable.Static;
	function type(className: "org.apache.http.concurrent.FutureCallback"): Http.FutureCallback.Static;
	function type(className: "org.apache.http.config.ConnectionConfig"): Http.ConnectionConfig.Static;
	function type(className: "org.apache.http.config.ConnectionConfig.Builder"): Http.ConnectionConfig$Builder.Static;
	function type(className: "org.apache.http.config.Lookup"): Http.Lookup.Static;
	function type(className: "org.apache.http.config.MessageConstraints"): Http.MessageConstraints.Static;
	function type(className: "org.apache.http.config.MessageConstraints.Builder"): Http.MessageConstraints$Builder.Static;
	function type(className: "org.apache.http.config.Registry"): Http.Registry.Static;
	function type(className: "org.apache.http.config.RegistryBuilder"): Http.RegistryBuilder.Static;
	function type(className: "org.apache.http.config.SocketConfig"): Http.SocketConfig.Static;
	function type(className: "org.apache.http.config.SocketConfig.Builder"): Http.SocketConfig$Builder.Static;
	function type(className: "org.apache.http.ConnectionClosedException"): Http.ConnectionClosedException.Static;
	function type(className: "org.apache.http.ConnectionReuseStrategy"): Http.ConnectionReuseStrategy.Static;
	function type(className: "org.apache.http.Consts"): Http.Consts.Static;
	function type(className: "org.apache.http.ContentTooLongException"): Http.ContentTooLongException.Static;
	function type(className: "org.apache.http.entity.AbstractHttpEntity"): Http.AbstractHttpEntity.Static;
	function type(className: "org.apache.http.entity.BasicHttpEntity"): Http.BasicHttpEntity.Static;
	function type(className: "org.apache.http.entity.BufferedHttpEntity"): Http.BufferedHttpEntity.Static;
	function type(className: "org.apache.http.entity.ByteArrayEntity"): Http.ByteArrayEntity.Static;
	function type(className: "org.apache.http.entity.ContentLengthStrategy"): Http.ContentLengthStrategy.Static;
	function type(className: "org.apache.http.entity.ContentProducer"): Http.ContentProducer.Static;
	function type(className: "org.apache.http.entity.ContentType"): Http.ContentType.Static;
	function type(className: "org.apache.http.entity.EntityTemplate"): Http.EntityTemplate.Static;
	function type(className: "org.apache.http.entity.FileEntity"): Http.FileEntity.Static;
	function type(className: "org.apache.http.entity.HttpEntityWrapper"): Http.HttpEntityWrapper.Static;
	function type(className: "org.apache.http.entity.InputStreamEntity"): Http.InputStreamEntity.Static;
	function type(className: "org.apache.http.entity.SerializableEntity"): Http.SerializableEntity.Static;
	function type(className: "org.apache.http.entity.StringEntity"): Http.StringEntity.Static;
	function type(className: "org.apache.http.ExceptionLogger"): Http.ExceptionLogger.Static;
	function type(className: "org.apache.http.FormattedHeader"): Http.FormattedHeader.Static;
	function type(className: "org.apache.http.Header"): Http.Header.Static;
	function type(className: "org.apache.http.HeaderElement"): Http.HeaderElement.Static;
	function type(className: "org.apache.http.HeaderElementIterator"): Http.HeaderElementIterator.Static;
	function type(className: "org.apache.http.HeaderIterator"): Http.HeaderIterator.Static;
	function type(className: "org.apache.http.HttpClientConnection"): Http.HttpClientConnection.Static;
	function type(className: "org.apache.http.HttpConnection"): Http.HttpConnection.Static;
	function type(className: "org.apache.http.HttpConnectionFactory"): Http.HttpConnectionFactory.Static;
	function type(className: "org.apache.http.HttpConnectionMetrics"): Http.HttpConnectionMetrics.Static;
	function type(className: "org.apache.http.HttpEntity"): Http.HttpEntity.Static;
	function type(className: "org.apache.http.HttpEntityEnclosingRequest"): Http.HttpEntityEnclosingRequest.Static;
	function type(className: "org.apache.http.HttpException"): Http.HttpException.Static;
	function type(className: "org.apache.http.HttpHeaders"): Http.HttpHeaders.Static;
	function type(className: "org.apache.http.HttpHost"): Http.HttpHost.Static;
	function type(className: "org.apache.http.HttpInetConnection"): Http.HttpInetConnection.Static;
	function type(className: "org.apache.http.HttpMessage"): Http.HttpMessage.Static;
	function type(className: "org.apache.http.HttpRequest"): Http.HttpRequest.Static;
	function type(className: "org.apache.http.HttpRequestFactory"): Http.HttpRequestFactory.Static;
	function type(className: "org.apache.http.HttpRequestInterceptor"): Http.HttpRequestInterceptor.Static;
	function type(className: "org.apache.http.HttpResponse"): Http.HttpResponse.Static;
	function type(className: "org.apache.http.HttpResponseFactory"): Http.HttpResponseFactory.Static;
	function type(className: "org.apache.http.HttpResponseInterceptor"): Http.HttpResponseInterceptor.Static;
	function type(className: "org.apache.http.impl.AbstractHttpClientConnection"): Http.AbstractHttpClientConnection.Static;
	function type(className: "org.apache.http.impl.BHttpConnectionBase"): Http.BHttpConnectionBase.Static;
	function type(className: "org.apache.http.auth.params.AuthParamBean"): Http.AuthParamBean.Static;
	function type(className: "org.apache.http.impl.bootstrap.RequestListener"): Http.RequestListener.Static;
	function type(className: "org.apache.http.impl.bootstrap.SSLServerSetupHandler"): Http.SSLServerSetupHandler.Static;
	function type(className: "org.apache.http.impl.io.AbstractSessionOutputBuffer"): Http.AbstractSessionOutputBuffer.Static;
	function type(className: "org.apache.http.impl.io.ChunkedOutputStream"): Http.ChunkedOutputStream.Static;
	function type(className: "org.apache.http.impl.io.ChunkedInputStream"): Http.ChunkedInputStream.Static;
	function type(className: "org.apache.http.impl.io.ContentLengthOutputStream"): Http.ContentLengthOutputStream.Static;
	function type(className: "org.apache.http.impl.io.DefaultHttpRequestParser"): Http.DefaultHttpRequestParser.Static;
	function type(className: "org.apache.http.impl.io.DefaultHttpRequestParserFactory"): Http.DefaultHttpRequestParserFactory.Static;
	function type(className: "org.apache.http.impl.io.ContentLengthInputStream"): Http.ContentLengthInputStream.Static;
	function type(className: "org.apache.http.impl.io.DefaultHttpRequestWriter"): Http.DefaultHttpRequestWriter.Static;
	function type(className: "org.apache.http.impl.io.DefaultHttpResponseParser"): Http.DefaultHttpResponseParser.Static;
	function type(className: "org.apache.http.impl.io.DefaultHttpResponseParserFactory"): Http.DefaultHttpResponseParserFactory.Static;
	function type(className: "org.apache.http.impl.io.DefaultHttpResponseWriterFactory"): Http.DefaultHttpResponseWriterFactory.Static;
	function type(className: "org.apache.http.impl.io.HttpRequestParser"): Http.HttpRequestParser.Static;
	function type(className: "org.apache.http.impl.io.HttpResponseParser"): Http.HttpResponseParser.Static;
	function type(className: "org.apache.http.impl.io.DefaultHttpRequestWriterFactory"): Http.DefaultHttpRequestWriterFactory.Static;
	function type(className: "org.apache.http.impl.io.IdentityOutputStream"): Http.IdentityOutputStream.Static;
	function type(className: "org.apache.http.impl.io.HttpTransportMetricsImpl"): Http.HttpTransportMetricsImpl.Static;
	function type(className: "org.apache.http.impl.io.SocketInputBuffer"): Http.SocketInputBuffer.Static;
	function type(className: "org.apache.http.impl.io.SocketOutputBuffer"): Http.SocketOutputBuffer.Static;
	function type(className: "org.apache.http.impl.NoConnectionReuseStrategy"): Http.NoConnectionReuseStrategy.Static;
	function type(className: "org.apache.http.impl.io.SessionOutputBufferImpl"): Http.SessionOutputBufferImpl.Static;
	function type(className: "org.apache.http.impl.pool.BasicConnFactory"): Http.BasicConnFactory.Static;
	function type(className: "org.apache.http.impl.pool.BasicPoolEntry"): Http.BasicPoolEntry.Static;
	function type(className: "org.apache.http.impl.SocketHttpServerConnection"): Http.SocketHttpServerConnection.Static;
	function type(className: "org.apache.http.impl.pool.BasicConnPool"): Http.BasicConnPool.Static;
	function type(className: "org.apache.http.message.BasicHeader"): Http.BasicHeader.Static;
	function type(className: "org.apache.http.message.BasicHttpRequest"): Http.BasicHttpRequest.Static;
	function type(className: "org.apache.http.message.BasicHeaderIterator"): Http.BasicHeaderIterator.Static;
	function type(className: "org.apache.http.message.BasicTokenIterator"): Http.BasicTokenIterator.Static;
	function type(className: "org.apache.http.message.LineFormatter"): Http.LineFormatter.Static;
	function type(className: "org.apache.http.params.HttpProtocolParamBean"): Http.HttpProtocolParamBean.Static;
	function type(className: "org.apache.http.message.BasicListHeaderIterator"): Http.BasicListHeaderIterator.Static;
	function type(className: "org.apache.http.pool.PoolEntryCallback"): Http.PoolEntryCallback.Static;
	function type(className: "org.apache.http.pool.AbstractConnPool"): Http.AbstractConnPool.Static;
	function type(className: "org.apache.http.protocol.HTTP"): Http.HTTP.Static;
	function type(className: "org.apache.http.protocol.HttpExpectationVerifier"): Http.HttpExpectationVerifier.Static;
	function type(className: "org.apache.http.protocol.HttpRequestHandler"): Http.HttpRequestHandler.Static;
	function type(className: "org.apache.http.protocol.HttpRequestInterceptorList"): Http.HttpRequestInterceptorList.Static;
	function type(className: "org.apache.http.protocol.ImmutableHttpProcessor"): Http.ImmutableHttpProcessor.Static;
	function type(className: "org.apache.http.protocol.RequestExpectContinue"): Http.RequestExpectContinue.Static;
	function type(className: "org.apache.http.protocol.ResponseContent"): Http.ResponseContent.Static;
	function type(className: "org.apache.http.protocol.UriHttpRequestHandlerMapper"): Http.UriHttpRequestHandlerMapper.Static;
	function type(className: "org.apache.http.ReasonPhraseCatalog"): Http.ReasonPhraseCatalog.Static;
	function type(className: "org.apache.http.impl.DefaultConnectionReuseStrategy"): Http.DefaultConnectionReuseStrategy.Static;
	function type(className: "org.apache.http.impl.DefaultHttpClientConnection"): Http.DefaultHttpClientConnection.Static;
	function type(className: "org.apache.http.impl.DefaultHttpRequestFactory"): Http.DefaultHttpRequestFactory.Static;
	function type(className: "org.apache.http.impl.DefaultHttpResponseFactory"): Http.DefaultHttpResponseFactory.Static;
	function type(className: "org.apache.http.impl.DefaultHttpServerConnection"): Http.DefaultHttpServerConnection.Static;
	function type(className: "org.apache.http.impl.EnglishReasonPhraseCatalog"): Http.EnglishReasonPhraseCatalog.Static;
	function type(className: "org.apache.http.protocol.BasicHttpProcessor"): Http.BasicHttpProcessor.Static;
	function type(className: "org.apache.http.impl.entity.EntityDeserializer"): Http.EntityDeserializer.Static;
	function type(className: "org.apache.http.impl.entity.DisallowIdentityContentLengthStrategy"): Http.DisallowIdentityContentLengthStrategy.Static;
	function type(className: "org.apache.http.impl.entity.LaxContentLengthStrategy"): Http.LaxContentLengthStrategy.Static;
	function type(className: "org.apache.http.impl.entity.StrictContentLengthStrategy"): Http.StrictContentLengthStrategy.Static;
	function type(className: "org.apache.http.impl.HttpConnectionMetricsImpl"): Http.HttpConnectionMetricsImpl.Static;
	function type(className: "org.apache.http.impl.io.AbstractMessageParser"): Http.AbstractMessageParser.Static;
	function type(className: "org.apache.http.impl.io.AbstractMessageWriter"): Http.AbstractMessageWriter.Static;
	function type(className: "org.apache.http.impl.io.AbstractSessionInputBuffer"): Http.AbstractSessionInputBuffer.Static;
	function type(className: "org.apache.http.message.AbstractHttpMessage"): Http.AbstractHttpMessage.Static;
	function type(className: "org.apache.http.message.BasicHeaderValueFormatter"): Http.BasicHeaderValueFormatter.Static;
	function type(className: "org.apache.http.message.BasicHttpResponse"): Http.BasicHttpResponse.Static;
	function type(className: "org.apache.http.message.BasicNameValuePair"): Http.BasicNameValuePair.Static;
	function type(className: "org.apache.http.message.BufferedHeader"): Http.BufferedHeader.Static;
	function type(className: "org.apache.http.message.LineParser"): Http.LineParser.Static;
	function type(className: "org.apache.http.MessageConstraintException"): Http.MessageConstraintException.Static;
	function type(className: "org.apache.http.NameValuePair"): Http.NameValuePair.Static;
	function type(className: "org.apache.http.params.AbstractHttpParams"): Http.AbstractHttpParams.Static;
	function type(className: "org.apache.http.params.HttpConnectionParamBean"): Http.HttpConnectionParamBean.Static;
	function type(className: "org.apache.http.params.HttpParamConfig"): Http.HttpParamConfig.Static;
	function type(className: "org.apache.http.params.HttpProtocolParams"): Http.HttpProtocolParams.Static;
	function type(className: "org.apache.http.pool.ConnFactory"): Http.ConnFactory.Static;
	function type(className: "org.apache.http.pool.PoolEntry"): Http.PoolEntry.Static;
	function type(className: "org.apache.http.protocol.BasicHttpContext"): Http.BasicHttpContext.Static;
	function type(className: "org.apache.http.protocol.ExecutionContext"): Http.ExecutionContext.Static;
	function type(className: "org.apache.http.protocol.HttpDateGenerator"): Http.HttpDateGenerator.Static;
	function type(className: "org.apache.http.protocol.HttpRequestExecutor"): Http.HttpRequestExecutor.Static;
	function type(className: "org.apache.http.protocol.HttpRequestHandlerResolver"): Http.HttpRequestHandlerResolver.Static;
	function type(className: "org.apache.http.protocol.RequestContent"): Http.RequestContent.Static;
	function type(className: "org.apache.http.protocol.RequestUserAgent"): Http.RequestUserAgent.Static;
	function type(className: "org.apache.http.protocol.ResponseServer"): Http.ResponseServer.Static;
	function type(className: "org.apache.http.ProtocolException"): Http.ProtocolException.Static;
	function type(className: "org.apache.http.impl.entity.EntitySerializer"): Http.EntitySerializer.Static;
	function type(className: "org.apache.http.ssl.PrivateKeyDetails"): Http.PrivateKeyDetails.Static;
	function type(className: "org.apache.http.ssl.TrustStrategy"): Http.TrustStrategy.Static;
	function type(className: "org.apache.http.StatusLine"): Http.StatusLine.Static;
	function type(className: "org.apache.http.TokenIterator"): Http.TokenIterator.Static;
	function type(className: "org.apache.http.TruncatedChunkException"): Http.TruncatedChunkException.Static;
	function type(className: "org.apache.http.UnsupportedHttpVersionException"): Http.UnsupportedHttpVersionException.Static;
	function type(className: "org.apache.http.ssl.SSLInitializationException"): Http.SSLInitializationException.Static;
	function type(className: "org.apache.http.util.Args"): Http.Args.Static;
	function type(className: "org.apache.http.util.ByteArrayBuffer"): Http.ByteArrayBuffer.Static;
	function type(className: "org.apache.http.util.CharArrayBuffer"): Http.CharArrayBuffer.Static;
	function type(className: "org.apache.http.util.CharsetUtils"): Http.CharsetUtils.Static;
	function type(className: "org.apache.http.util.EncodingUtils"): Http.EncodingUtils.Static;
	function type(className: "org.apache.http.util.EntityUtils"): Http.EntityUtils.Static;
	function type(className: "org.apache.http.util.ExceptionUtils"): Http.ExceptionUtils.Static;
	function type(className: "org.apache.http.util.LangUtils"): Http.LangUtils.Static;
	function type(className: "org.apache.http.util.NetUtils"): Http.NetUtils.Static;
	function type(className: "org.apache.http.util.TextUtils"): Http.TextUtils.Static;
	function type(className: "org.apache.http.util.VersionInfo"): Http.VersionInfo.Static;
	function type(className: "org.apache.http.impl.bootstrap.WorkerPoolExecutor"): Http.WorkerPoolExecutor.Static;
	function type(className: "org.apache.http.impl.DefaultBHttpClientConnection"): Http.DefaultBHttpClientConnection.Static;
	function type(className: "org.apache.http.impl.DefaultBHttpServerConnection"): Http.DefaultBHttpServerConnection.Static;
	function type(className: "org.apache.http.impl.DefaultBHttpServerConnectionFactory"): Http.DefaultBHttpServerConnectionFactory.Static;
	function type(className: "org.apache.http.MalformedChunkCodingException"): Http.MalformedChunkCodingException.Static;
	function type(className: "org.apache.http.message.BasicHeaderElementIterator"): Http.BasicHeaderElementIterator.Static;
	function type(className: "org.apache.http.message.BasicHttpEntityEnclosingRequest"): Http.BasicHttpEntityEnclosingRequest.Static;
	function type(className: "org.apache.http.message.BasicLineFormatter"): Http.BasicLineFormatter.Static;
	function type(className: "org.apache.http.message.BasicRequestLine"): Http.BasicRequestLine.Static;
	function type(className: "org.apache.http.message.HeaderGroup"): Http.HeaderGroup.Static;
	function type(className: "org.apache.http.message.ParserCursor"): Http.ParserCursor.Static;
	function type(className: "org.apache.http.MethodNotSupportedException"): Http.MethodNotSupportedException.Static;
	function type(className: "org.apache.http.NoHttpResponseException"): Http.NoHttpResponseException.Static;
	function type(className: "org.apache.http.params.BasicHttpParams"): Http.BasicHttpParams.Static;
	function type(className: "org.apache.http.params.CoreProtocolPNames"): Http.CoreProtocolPNames.Static;
	function type(className: "org.apache.http.params.HttpAbstractParamBean"): Http.HttpAbstractParamBean.Static;
	function type(className: "org.apache.http.params.HttpConnectionParams"): Http.HttpConnectionParams.Static;
	function type(className: "org.apache.http.params.HttpParams"): Http.HttpParams.Static;
	function type(className: "org.apache.http.params.SyncBasicHttpParams"): Http.SyncBasicHttpParams.Static;
	function type(className: "org.apache.http.pool.ConnPool"): Http.ConnPool.Static;
	function type(className: "org.apache.http.pool.PoolStats"): Http.PoolStats.Static;
	function type(className: "org.apache.http.protocol.ChainBuilder"): Http.ChainBuilder.Static;
	function type(className: "org.apache.http.protocol.HttpContext"): Http.HttpContext.Static;
	function type(className: "org.apache.http.protocol.HttpProcessor"): Http.HttpProcessor.Static;
	function type(className: "org.apache.http.protocol.HttpRequestHandlerMapper"): Http.HttpRequestHandlerMapper.Static;
	function type(className: "org.apache.http.protocol.HttpResponseInterceptorList"): Http.HttpResponseInterceptorList.Static;
	function type(className: "org.apache.http.protocol.RequestConnControl"): Http.RequestConnControl.Static;
	function type(className: "org.apache.http.protocol.RequestTargetHost"): Http.RequestTargetHost.Static;
	function type(className: "org.apache.http.protocol.ResponseDate"): Http.ResponseDate.Static;
	function type(className: "org.apache.http.protocol.UriPatternMatcher"): Http.UriPatternMatcher.Static;
	function type(className: "org.apache.http.RequestLine"): Http.RequestLine.Static;
	function type(className: "org.apache.http.ssl.SSLContextBuilder"): Http.SSLContextBuilder.Static;
	function type(className: "org.apache.http.ssl.SSLContextBuilder.TrustManagerDelegate"): Http.SSLContextBuilder$TrustManagerDelegate.Static;
	function type(className: "org.apache.http.ssl.SSLContextBuilder.KeyManagerDelegate"): Http.SSLContextBuilder$KeyManagerDelegate.Static;
	function type(className: "org.apache.http.ssl.SSLContexts"): Http.SSLContexts.Static;
	function type(className: "org.apache.http.HttpServerConnection"): Http.HttpServerConnection.Static;
	function type(className: "org.apache.http.HttpStatus"): Http.HttpStatus.Static;
	function type(className: "org.apache.http.HttpVersion"): Http.HttpVersion.Static;
	function type(className: "org.apache.http.impl.AbstractHttpServerConnection"): Http.AbstractHttpServerConnection.Static;
	function type(className: "org.apache.http.impl.bootstrap.HttpServer"): Http.HttpServer.Static;
	function type(className: "org.apache.http.impl.bootstrap.ServerBootstrap"): Http.ServerBootstrap.Static;
	function type(className: "org.apache.http.impl.bootstrap.ThreadFactoryImpl"): Http.ThreadFactoryImpl.Static;
	function type(className: "org.apache.http.impl.bootstrap.Worker"): Http.Worker.Static;
	function type(className: "org.apache.http.impl.ConnSupport"): Http.ConnSupport.Static;
	function type(className: "org.apache.http.impl.DefaultBHttpClientConnectionFactory"): Http.DefaultBHttpClientConnectionFactory.Static;
	function type(className: "org.apache.http.impl.io.DefaultHttpResponseWriter"): Http.DefaultHttpResponseWriter.Static;
	function type(className: "org.apache.http.impl.io.EmptyInputStream"): Http.EmptyInputStream.Static;
	function type(className: "org.apache.http.impl.io.HttpRequestWriter"): Http.HttpRequestWriter.Static;
	function type(className: "org.apache.http.impl.io.HttpResponseWriter"): Http.HttpResponseWriter.Static;
	function type(className: "org.apache.http.util.Asserts"): Http.Asserts.Static;
	function type(className: "org.apache.http.impl.io.IdentityInputStream"): Http.IdentityInputStream.Static;
	function type(className: "org.apache.http.impl.SocketHttpClientConnection"): Http.SocketHttpClientConnection.Static;
	function type(className: "org.apache.http.io.BufferInfo"): Http.BufferInfo.Static;
	function type(className: "org.apache.http.io.EofSensor"): Http.EofSensor.Static;
	function type(className: "org.apache.http.io.HttpMessageParser"): Http.HttpMessageParser.Static;
	function type(className: "org.apache.http.impl.io.SessionInputBufferImpl"): Http.SessionInputBufferImpl.Static;
	function type(className: "org.apache.http.io.HttpMessageWriter"): Http.HttpMessageWriter.Static;
	function type(className: "org.apache.http.io.HttpMessageWriterFactory"): Http.HttpMessageWriterFactory.Static;
	function type(className: "org.apache.http.io.HttpTransportMetrics"): Http.HttpTransportMetrics.Static;
	function type(className: "org.apache.http.io.HttpMessageParserFactory"): Http.HttpMessageParserFactory.Static;
	function type(className: "org.apache.http.io.SessionInputBuffer"): Http.SessionInputBuffer.Static;
	function type(className: "org.apache.http.message.BasicHeaderElement"): Http.BasicHeaderElement.Static;
	function type(className: "org.apache.http.message.BasicHeaderValueParser"): Http.BasicHeaderValueParser.Static;
	function type(className: "org.apache.http.message.BasicLineParser"): Http.BasicLineParser.Static;
	function type(className: "org.apache.http.message.BasicStatusLine"): Http.BasicStatusLine.Static;
	function type(className: "org.apache.http.message.HeaderValueFormatter"): Http.HeaderValueFormatter.Static;
	function type(className: "org.apache.http.message.HeaderValueParser"): Http.HeaderValueParser.Static;
	function type(className: "org.apache.http.message.TokenParser"): Http.TokenParser.Static;
	function type(className: "org.apache.http.params.CoreConnectionPNames"): Http.CoreConnectionPNames.Static;
	function type(className: "org.apache.http.params.DefaultedHttpParams"): Http.DefaultedHttpParams.Static;
	function type(className: "org.apache.http.params.HttpParamsNames"): Http.HttpParamsNames.Static;
	function type(className: "org.apache.http.ParseException"): Http.ParseException.Static;
	function type(className: "org.apache.http.pool.ConnPoolControl"): Http.ConnPoolControl.Static;
	function type(className: "org.apache.http.pool.RouteSpecificPool"): Http.RouteSpecificPool.Static;
	function type(className: "org.apache.http.protocol.DefaultedHttpContext"): Http.DefaultedHttpContext.Static;
	function type(className: "org.apache.http.protocol.HttpCoreContext"): Http.HttpCoreContext.Static;
	function type(className: "org.apache.http.protocol.HttpProcessorBuilder"): Http.HttpProcessorBuilder.Static;
	function type(className: "org.apache.http.protocol.HttpRequestHandlerRegistry"): Http.HttpRequestHandlerRegistry.Static;
	function type(className: "org.apache.http.protocol.HttpService"): Http.HttpService.Static;
	function type(className: "org.apache.http.protocol.RequestDate"): Http.RequestDate.Static;
	function type(className: "org.apache.http.protocol.ResponseConnControl"): Http.ResponseConnControl.Static;
	function type(className: "org.apache.http.protocol.SyncBasicHttpContext"): Http.SyncBasicHttpContext.Static;
	function type(className: "org.apache.http.ProtocolVersion"): Http.ProtocolVersion.Static;
	function type(className: "org.apache.http.ssl.PrivateKeyStrategy"): Http.PrivateKeyStrategy.Static;
	function type(className: "org.apache.http.io.SessionOutputBuffer"): Http.SessionOutputBuffer.Static;
	function type(className: "org.apache.commons.logging.Log"): Commons.Logging.Log.Static;
	function type(className: "org.ietf.jgss.GSSCredential"): JGSS.GSSCredential.Static;
	function type(className: "org.ietf.jgss.GSSName"): JGSS.GSSName.Static;
	function type(className: "org.ietf.jgss.Oid"): JGSS.Oid.Static;
	function type<T = any>(className: string): T;
}